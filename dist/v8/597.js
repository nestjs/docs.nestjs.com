"use strict";(self.webpackChunkdocs_nestjs_com=self.webpackChunkdocs_nestjs_com||[]).push([[597],{5597:(v,l,a)=>{a.r(l),a.d(l,{FaqModule:()=>y});var d=a(9808),u=a(215),g=a(4466),s=a(4834),e=a(4893),c=a(4521);let h=(()=>{class t extends s.y{}return t.\u0275fac=function(){let o;return function(r){return(o||(o=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-errors"]],features:[e.qOj],decls:156,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/faq/errors.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","common-errors"],["appAnchor","","id","cannot-resolve-dependency-error"],[1,"language-bash"],["href","/fundamentals/custom-providers#di-fundamentals"],["href","/faq/common-errors#circular-dependency-error"],["routerLink","/fundamentals/custom-providers"],[1,"language-text"],["rel","nofollow","target","_blank","href","https://classic.yarnpkg.com/blog/2018/02/15/nohoist"],["appAnchor","","id","circular-dependency-error"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/fundamentals/circular-dependency"],["appAnchor","","id","debugging-dependency-errors"],["src","/assets/injector_logs.png"]],template:function(n,r){1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Common errors"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"During your development with NestJS, you may encounter various errors as you learn the framework."),e.qZA(),e.TgZ(9,"h4",6)(10,"span"),e._uU(11,'"Cannot resolve dependency" error'),e.qZA()(),e.TgZ(12,"p"),e._uU(13,"Probably the most common error message is about Nest not being able to resolve dependencies of a provider. The error message usually looks something like this:"),e.qZA(),e.TgZ(14,"pre")(15,"code",7),e._uU(16,"\nNest can't resolve dependencies of the <provider> (?). Please make sure that the argument <unknown_token> at index [<index>] is available in the <module> context.\n\nPotential solutions:\n- If <unknown_token> is a provider, is it part of the current <module>?\n- If <unknown_token> is exported from a separate @Module, is that module imported within <module>?\n  @Module({\n    imports: [ /* the Module containing <unknown_token> */ ]\n  })\n"),e.qZA()(),e.TgZ(17,"p"),e._uU(18,"The most common culprit of the error, is not having the "),e.TgZ(19,"code"),e._uU(20,"<provider>"),e.qZA(),e._uU(21," in the module's "),e.TgZ(22,"code"),e._uU(23,"providers"),e.qZA(),e._uU(24," array. Please make sure that the provider is indeed in the "),e.TgZ(25,"code"),e._uU(26,"providers"),e.qZA(),e._uU(27," array and following "),e.TgZ(28,"a",8),e._uU(29,"standard NestJS provider practices"),e.qZA(),e._uU(30,"."),e.qZA(),e.TgZ(31,"p"),e._uU(32,"There are a few gotchas, that are common. One is putting a provider in an "),e.TgZ(33,"code"),e._uU(34,"imports"),e.qZA(),e._uU(35," array. If this is the case, the error will have the provider's name where "),e.TgZ(36,"code"),e._uU(37,"<module>"),e.qZA(),e._uU(38," should be."),e.qZA(),e.TgZ(39,"p"),e._uU(40,"If you run across this error while developing, take a look at the module mentioned in the error message and look at its "),e.TgZ(41,"code"),e._uU(42,"providers"),e.qZA(),e._uU(43,". For each provider in the "),e.TgZ(44,"code"),e._uU(45,"providers"),e.qZA(),e._uU(46," array, make sure the module has access to all of the dependencies. Often times, "),e.TgZ(47,"code"),e._uU(48,"providers"),e.qZA(),e._uU(49,' are duplicated in a "Feature Module" and a "Root Module" which means Nest will try to instantiate the provider twice. More than likely, the module containing the '),e.TgZ(50,"code"),e._uU(51,"<provider>"),e.qZA(),e._uU(52,' being duplicated should be added in the "Root Module"\'s '),e.TgZ(53,"code"),e._uU(54,"imports"),e.qZA(),e._uU(55," array instead."),e.qZA(),e.TgZ(56,"p"),e._uU(57,"If the "),e.TgZ(58,"code"),e._uU(59,"<unknown_token>"),e.qZA(),e._uU(60," above is the string "),e.TgZ(61,"code"),e._uU(62,"dependency"),e.qZA(),e._uU(63,", you might have a circular file import. This is different from the "),e.TgZ(64,"a",9),e._uU(65,"circular dependency"),e.qZA(),e._uU(66," below because instead of having providers depend on each other in their constructors, it just means that two files end up importing each other. A common case would be a module file declaring a token and importing a provider, and the provider import the token constant from the module file. If you are using barrel files, ensure that your barrel imports do not end up creating these circular imports as well."),e.qZA(),e.TgZ(67,"p"),e._uU(68,"If the "),e.TgZ(69,"code"),e._uU(70,"<unknown_token>"),e.qZA(),e._uU(71," above is the string "),e.TgZ(72,"code"),e._uU(73,"Object"),e.qZA(),e._uU(74,", it means that you're injecting using an type/interface without a proper provider's token. To fix that, make sure you're importing the class reference or use a custom token with "),e.TgZ(75,"code"),e._uU(76,"@Inject()"),e.qZA(),e._uU(77," decorator. Read the "),e.TgZ(78,"a",10),e._uU(79,"custom providers page"),e.qZA(),e._uU(80,"."),e.qZA(),e.TgZ(81,"p"),e._uU(82,"Also, make sure you didn't end up injecting the provider on itself because self-injections are not allowed on NetJS. When this happens, "),e.TgZ(83,"code"),e._uU(84,"<unknown_token>"),e.qZA(),e._uU(85," will likely be equal to "),e.TgZ(86,"code"),e._uU(87,"<provider>"),e.qZA(),e._uU(88,"."),e.qZA(),e.TgZ(89,"p"),e._uU(90,"If you are in a "),e.TgZ(91,"strong"),e._uU(92,"monorepo setup"),e.qZA(),e._uU(93,", you may face the same error as above but for core provider called "),e.TgZ(94,"code"),e._uU(95,"ModuleRef"),e.qZA(),e._uU(96," as a "),e.TgZ(97,"code"),e._uU(98,"<unknown_token>"),e.qZA(),e._uU(99,":"),e.qZA(),e.TgZ(100,"pre")(101,"code",7),e._uU(102,"\nNest can't resolve dependencies of the <provider> (?).\nPlease make sure that the argument ModuleRef at index [<index>] is available in the <module> context.\n...\n"),e.qZA()(),e.TgZ(103,"p"),e._uU(104,"This likely happens when your project end up loading two Node modules of the package "),e.TgZ(105,"code"),e._uU(106,"@nestjs/core"),e.qZA(),e._uU(107,", like this:"),e.qZA(),e.TgZ(108,"pre")(109,"code",11),e._uU(110,"\n.\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 apps\n\u2502   \u2514\u2500\u2500 api\n\u2502       \u2514\u2500\u2500 node_modules\n\u2502           \u2514\u2500\u2500 @nestjs/bull\n\u2502               \u2514\u2500\u2500 node_modules\n\u2502                   \u2514\u2500\u2500 @nestjs/core\n\u2514\u2500\u2500 node_modules\n    \u251c\u2500\u2500 (other packages)\n    \u2514\u2500\u2500 @nestjs/core\n"),e.qZA()(),e.TgZ(111,"p"),e._uU(112,"Solutions:"),e.qZA(),e.TgZ(113,"ul")(114,"li"),e._uU(115,"For "),e.TgZ(116,"strong"),e._uU(117,"Yarn"),e.qZA(),e._uU(118," Workspaces, use the "),e.TgZ(119,"a",12),e._uU(120,"nohoist feature"),e.qZA(),e._uU(121," to prevent hoisting the package "),e.TgZ(122,"code"),e._uU(123,"@nestjs/core"),e.qZA(),e._uU(124,"."),e.qZA()(),e.TgZ(125,"h4",13)(126,"span"),e._uU(127,'"Circular dependency" error'),e.qZA()(),e.TgZ(128,"p"),e._uU(129,"Occasionally you'll find it difficult to avoid "),e.TgZ(130,"a",14),e._uU(131,"circular dependencies"),e.qZA(),e._uU(132," in your application. You'll need to take some steps to help Nest resolve these. Errors that arise from circular dependencies look like this:"),e.qZA(),e.TgZ(133,"pre")(134,"code",7),e._uU(135,'\nNest cannot create the <module> instance.\nThe module at index [<index>] of the <module> "imports" array is undefined.\n\nPotential causes:\n- A circular dependency between modules. Use forwardRef() to avoid it. Read more: https://docs.nestjs.com/fundamentals/circular-dependency\n- The module at index [<index>] is of type "undefined". Check your import statements and the type of the module.\n\nScope [<module_import_chain>]\n# example chain AppModule -> FooModule\n'),e.qZA()(),e.TgZ(136,"p"),e._uU(137,"Circular dependencies can arise from both providers depending on each other, or typescript files depending on each other for constants, such as exporting constants from a module file and importing them in a service file. In the latter case, it is advised to create a separate file for your constants. In the former case, please follow the guide on circular dependencies and make sure that both the modules "),e.TgZ(138,"strong"),e._uU(139,"and"),e.qZA(),e._uU(140," the providers are marked with "),e.TgZ(141,"code"),e._uU(142,"forwardRef"),e.qZA(),e._uU(143,"."),e.qZA(),e.TgZ(144,"h4",15)(145,"span"),e._uU(146,"Debugging dependency errors"),e.qZA()(),e.TgZ(147,"p"),e._uU(148,"Along with just manually verifying your dependencies are correct, as of Nest 8.1.0 you can set the "),e.TgZ(149,"code"),e._uU(150,"NEST_DEBUG"),e.qZA(),e._uU(151," environment variable to a string that resolves as truthy, and get extra logging information while Nest is resolving all of the dependencies for the application."),e.qZA(),e.TgZ(152,"figure"),e._UZ(153,"img",16),e.qZA(),e.TgZ(154,"p"),e._uU(155,"In the above image, the string in yellow is the host class of the dependency being injected, the string in blue is the name of the injected dependency, or its injection token, and the string in purple is the module in which the dependency is being searched for. Using this, you can usually trace back the dependency resolution for what's happening and why you're getting dependency injection problems."),e.qZA()())},dependencies:[c.U,u.yS],encapsulation:2,changeDetection:0}),t})(),Z=(()=>{class t extends s.y{}return t.\u0275fac=function(){let o;return function(r){return(o||(o=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-global-prefix"]],features:[e.qOj],decls:31,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/faq/global-prefix.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","global-prefix"],[1,"language-typescript"]],template:function(n,r){1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Global prefix"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"To set a prefix for "),e.TgZ(9,"strong"),e._uU(10,"every route"),e.qZA(),e._uU(11," registered in an HTTP application, use the "),e.TgZ(12,"code"),e._uU(13,"setGlobalPrefix()"),e.qZA(),e._uU(14," method of the "),e.TgZ(15,"code"),e._uU(16,"INestApplication"),e.qZA(),e._uU(17," instance."),e.qZA(),e.TgZ(18,"pre")(19,"code",6),e._uU(20,"\nconst app = await NestFactory.create(AppModule);\napp.setGlobalPrefix('v1');\n"),e.qZA()(),e.TgZ(21,"p"),e._uU(22,"You can exclude routes from the global prefix using the following construction:"),e.qZA(),e.TgZ(23,"pre")(24,"code",6),e._uU(25,"\napp.setGlobalPrefix('v1', {\n  exclude: [{ path: 'health', method: RequestMethod.GET }],\n});\n"),e.qZA()(),e.TgZ(26,"p"),e._uU(27,"Alternatively, you can specify route as a string (it will apply to every request method):"),e.qZA(),e.TgZ(28,"pre")(29,"code",6),e._uU(30,"\napp.setGlobalPrefix('v1', { exclude: ['cats'] });\n"),e.qZA()()())},encapsulation:2,changeDetection:0}),t})();var p=a(4336);let m=(()=>{class t extends s.y{}return t.\u0275fac=function(){let o;return function(r){return(o||(o=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-http-adapter"]],features:[e.qOj],decls:100,vars:4,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/faq/http-adapter.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","http-adapter"],["appAnchor","","id","outside-application-context-strategy"],[1,"filename"],["appe8b5a99d6cab677280f8d3ab78282c34dedfc13a",""],[1,"language-typescript"],["appAnchor","","id","in-context-strategy"],["app4966eac9a0cf81b3c749e6b076140bcaf1a4c1d2",""],[1,"info"]],template:function(n,r){if(1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"HTTP adapter"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"Occasionally, you may want to access the underlying HTTP server, either within the Nest application context or from the outside."),e.qZA(),e.TgZ(9,"p"),e._uU(10,"Every native (platform-specific) HTTP server/library (e.g., Express and Fastify) instance is wrapped in an "),e.TgZ(11,"strong"),e._uU(12,"adapter"),e.qZA(),e._uU(13,". The adapter is registered as a globally available provider that can be retrieved from the application context, as well as injected into other providers."),e.qZA(),e.TgZ(14,"h4",6)(15,"span"),e._uU(16,"Outside application context strategy"),e.qZA()(),e.TgZ(17,"p"),e._uU(18,"To get a reference to the "),e.TgZ(19,"code"),e._uU(20,"HttpAdapter"),e.qZA(),e._uU(21," from outside of the application context, call the "),e.TgZ(22,"code"),e._uU(23,"getHttpAdapter()"),e.qZA(),e._uU(24," method."),e.qZA(),e.TgZ(25,"span",7),e._UZ(26,"app-tabs",null,8),e.qZA(),e.TgZ(28,"pre")(29,"code",9),e._uU(30,"\nconst app = await NestFactory.create(AppModule);\nconst httpAdapter = app.getHttpAdapter();\n"),e.qZA()(),e.TgZ(31,"h4",10)(32,"span"),e._uU(33,"In-context strategy"),e.qZA()(),e.TgZ(34,"p"),e._uU(35,"To get a reference to the "),e.TgZ(36,"code"),e._uU(37,"HttpAdapterHost"),e.qZA(),e._uU(38," from within the application context, inject it using the same technique as any other existing provider (e.g., using constructor injection)."),e.qZA(),e.TgZ(39,"span",7),e._UZ(40,"app-tabs",null,11),e.qZA(),e.TgZ(42,"pre")(43,"code",9),e._uU(44,"\nexport class CatsService {\n  constructor(private adapterHost: HttpAdapterHost) {}\n}\n"),e.qZA()(),e.TgZ(45,"pre")(46,"code",9),e._uU(47,"\n@Dependencies(HttpAdapterHost)\nexport class CatsService {\n  constructor(adapterHost) {\n    this.adapterHost = adapterHost;\n  }\n}\n"),e.qZA()(),e.TgZ(48,"blockquote",12)(49,"strong"),e._uU(50,"Hint"),e.qZA(),e._uU(51," The "),e.TgZ(52,"code"),e._uU(53,"HttpAdapterHost"),e.qZA(),e._uU(54," is imported from the "),e.TgZ(55,"code"),e._uU(56,"@nestjs/core"),e.qZA(),e._uU(57," package.\n"),e.qZA(),e.TgZ(58,"p"),e._uU(59,"The "),e.TgZ(60,"code"),e._uU(61,"HttpAdapterHost"),e.qZA(),e._uU(62," is "),e.TgZ(63,"strong"),e._uU(64,"not"),e.qZA(),e._uU(65," an actual "),e.TgZ(66,"code"),e._uU(67,"HttpAdapter"),e.qZA(),e._uU(68,". To get the actual "),e.TgZ(69,"code"),e._uU(70,"HttpAdapter"),e.qZA(),e._uU(71," instance, simply access the "),e.TgZ(72,"code"),e._uU(73,"httpAdapter"),e.qZA(),e._uU(74," property."),e.qZA(),e.TgZ(75,"pre")(76,"code",9),e._uU(77,"\nconst adapterHost = app.get(HttpAdapterHost);\nconst httpAdapter = adapterHost.httpAdapter;\n"),e.qZA()(),e.TgZ(78,"p"),e._uU(79,"The "),e.TgZ(80,"code"),e._uU(81,"httpAdapter"),e.qZA(),e._uU(82," is the actual instance of the HTTP adapter used by the underlying framework. It is an instance of either "),e.TgZ(83,"code"),e._uU(84,"ExpressAdapter"),e.qZA(),e._uU(85," or "),e.TgZ(86,"code"),e._uU(87,"FastifyAdapter"),e.qZA(),e._uU(88," (both classes extend "),e.TgZ(89,"code"),e._uU(90,"AbstractHttpAdapter"),e.qZA(),e._uU(91,")."),e.qZA(),e.TgZ(92,"p"),e._uU(93,"The adapter object exposes several useful methods to interact with the HTTP server. However, if you want to access the library instance (e.g., the Express instance) directly, call the "),e.TgZ(94,"code"),e._uU(95,"getInstance()"),e.qZA(),e._uU(96," method."),e.qZA(),e.TgZ(97,"pre")(98,"code",9),e._uU(99,"\nconst instance = httpAdapter.getInstance();\n"),e.qZA()()()),2&n){const i=e.MAs(41);e.xp6(42),e.ekj("hide",i.isJsActive),e.xp6(3),e.ekj("hide",!i.isJsActive)}},dependencies:[p.n,c.U],encapsulation:2,changeDetection:0}),t})(),f=(()=>{class t extends s.y{}return t.\u0275fac=function(){let o;return function(r){return(o||(o=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-hybrid-application"]],features:[e.qOj],decls:78,vars:4,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/faq/hybrid-application.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","hybrid-application"],[1,"language-typescript"],[1,"filename"],["appb7d1a4e889e5db82263e9acb7ebe365e11f7dd06",""],[1,"info"],["appAnchor","","id","sharing-configuration"]],template:function(n,r){if(1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Hybrid application"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"A hybrid application is one that both listens for HTTP requests, as well as makes use of connected microservices. The "),e.TgZ(9,"code"),e._uU(10,"INestApplication"),e.qZA(),e._uU(11," instance can be connected with "),e.TgZ(12,"code"),e._uU(13,"INestMicroservice"),e.qZA(),e._uU(14," instances through the "),e.TgZ(15,"code"),e._uU(16,"connectMicroservice()"),e.qZA(),e._uU(17," method."),e.qZA(),e.TgZ(18,"pre")(19,"code",6),e._uU(20,"\nconst app = await NestFactory.create(AppModule);\nconst microservice = app.connectMicroservice({\n  transport: Transport.TCP,\n});\n\nawait app.startAllMicroservices();\nawait app.listen(3001);\n"),e.qZA()(),e.TgZ(21,"p"),e._uU(22,"To connect multiple microservice instances, issue the call to "),e.TgZ(23,"code"),e._uU(24,"connectMicroservice()"),e.qZA(),e._uU(25," for each microservice:"),e.qZA(),e.TgZ(26,"pre")(27,"code",6),e._uU(28,"\nconst app = await NestFactory.create(AppModule);\n// microservice #1\nconst microserviceTcp = app.connectMicroservice<MicroserviceOptions>({\n  transport: Transport.TCP,\n  options: {\n    port: 3001,\n  },\n});\n// microservice #2\nconst microserviceRedis = app.connectMicroservice<MicroserviceOptions>({\n  transport: Transport.REDIS,\n  options: {\n    url: 'redis://localhost:6379',\n  },\n});\n\nawait app.startAllMicroservices();\nawait app.listen(3001);\n"),e.qZA()(),e.TgZ(29,"p"),e._uU(30,"To bind "),e.TgZ(31,"code"),e._uU(32,"@MessagePattern()"),e.qZA(),e._uU(33," to only one transport strategy (for example, MQTT) in a hybrid application with multiple microservices, we can pass the second argument of type "),e.TgZ(34,"code"),e._uU(35,"Transport"),e.qZA(),e._uU(36," which is an enum with all the built-in transport strategies defined."),e.qZA(),e.TgZ(37,"span",7),e._UZ(38,"app-tabs",null,8),e.qZA(),e.TgZ(40,"pre")(41,"code",6),e._uU(42,"\n@MessagePattern('time.us.*', Transport.NATS)\ngetDate(@Payload() data: number[], @Ctx() context: NatsContext) {\n  console.log(`Subject: ${context.getSubject()}`); // e.g. \"time.us.east\"\n  return new Date().toLocaleTimeString(...);\n}\n@MessagePattern({ cmd: 'time.us' }, Transport.TCP)\ngetTCPDate(@Payload() data: number[]) {\n  return new Date().toLocaleTimeString(...);\n}\n"),e.qZA()(),e.TgZ(43,"pre")(44,"code",6),e._uU(45,"\n@Bind(Payload(), Ctx())\n@MessagePattern('time.us.*', Transport.NATS)\ngetDate(data, context) {\n  console.log(`Subject: ${context.getSubject()}`); // e.g. \"time.us.east\"\n  return new Date().toLocaleTimeString(...);\n}\n@Bind(Payload(), Ctx())\n@MessagePattern({ cmd: 'time.us' }, Transport.TCP)\ngetTCPDate(data, context) {\n  return new Date().toLocaleTimeString(...);\n}\n"),e.qZA()(),e.TgZ(46,"blockquote",9)(47,"strong"),e._uU(48,"Hint"),e.qZA(),e.TgZ(49,"code"),e._uU(50,"@Payload()"),e.qZA(),e._uU(51,", "),e.TgZ(52,"code"),e._uU(53,"@Ctx()"),e.qZA(),e._uU(54,", "),e.TgZ(55,"code"),e._uU(56,"Transport"),e.qZA(),e._uU(57," and "),e.TgZ(58,"code"),e._uU(59,"NatsContext"),e.qZA(),e._uU(60," are imported from "),e.TgZ(61,"code"),e._uU(62,"@nestjs/microservices"),e.qZA(),e._uU(63,".\n"),e.qZA(),e.TgZ(64,"h4",10)(65,"span"),e._uU(66,"Sharing configuration"),e.qZA()(),e.TgZ(67,"p"),e._uU(68,"By default a hybrid application will not inherit global pipes, interceptors, guards and filters configured for the main (HTTP-based) application.\nTo inherit these configuration properties from the main application, set the "),e.TgZ(69,"code"),e._uU(70,"inheritAppConfig"),e.qZA(),e._uU(71," property in the second argument (an optional options object) of the "),e.TgZ(72,"code"),e._uU(73,"connectMicroservice()"),e.qZA(),e._uU(74," call, as follow:"),e.qZA(),e.TgZ(75,"pre")(76,"code",6),e._uU(77,"\nconst microservice = app.connectMicroservice({\n  transport: Transport.TCP\n}, { inheritAppConfig: true });\n"),e.qZA()()()),2&n){const i=e.MAs(39);e.xp6(40),e.ekj("hide",i.isJsActive),e.xp6(3),e.ekj("hide",!i.isJsActive)}},dependencies:[p.n,c.U],encapsulation:2,changeDetection:0}),t})(),U=(()=>{class t extends s.y{}return t.\u0275fac=function(){let o;return function(r){return(o||(o=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-multiple-servers"]],features:[e.qOj],decls:60,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/faq/multiple-servers.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","https"],[1,"language-typescript"],["appAnchor","","id","multiple-simultaneous-servers"],[1,"info"],[1,""],["routerLink","/graphql/subscriptions"]],template:function(n,r){1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"HTTPS"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"To create an application that uses the HTTPS protocol, set the "),e.TgZ(9,"code"),e._uU(10,"httpsOptions"),e.qZA(),e._uU(11," property in the options object passed to the "),e.TgZ(12,"code"),e._uU(13,"create()"),e.qZA(),e._uU(14," method of the "),e.TgZ(15,"code"),e._uU(16,"NestFactory"),e.qZA(),e._uU(17," class:"),e.qZA(),e.TgZ(18,"pre")(19,"code",6),e._uU(20,"\nconst httpsOptions = {\n  key: fs.readFileSync('./secrets/private-key.pem'),\n  cert: fs.readFileSync('./secrets/public-certificate.pem'),\n};\nconst app = await NestFactory.create(AppModule, {\n  httpsOptions,\n});\nawait app.listen(3000);\n"),e.qZA()(),e.TgZ(21,"p"),e._uU(22,"If you use the "),e.TgZ(23,"code"),e._uU(24,"FastifyAdapter"),e.qZA(),e._uU(25,", create the application as follows:"),e.qZA(),e.TgZ(26,"pre")(27,"code",6),e._uU(28,"\nconst app = await NestFactory.create<NestFastifyApplication>(\n  AppModule,\n  new FastifyAdapter({ https: httpsOptions }),\n);\n"),e.qZA()(),e.TgZ(29,"h4",7)(30,"span"),e._uU(31,"Multiple simultaneous servers"),e.qZA()(),e.TgZ(32,"p"),e._uU(33,"The following recipe shows how to instantiate a Nest application that listens on multiple ports (for example, on a non-HTTPS port and an HTTPS port) simultaneously."),e.qZA(),e.TgZ(34,"pre")(35,"code",6),e._uU(36,"\nconst httpsOptions = {\n  key: fs.readFileSync('./secrets/private-key.pem'),\n  cert: fs.readFileSync('./secrets/public-certificate.pem'),\n};\n\nconst server = express();\nconst app = await NestFactory.create(\n  AppModule,\n  new ExpressAdapter(server),\n);\nawait app.init();\n\nhttp.createServer(server).listen(3000);\nhttps.createServer(httpsOptions, server).listen(443);\n"),e.qZA()(),e.TgZ(37,"blockquote",8)(38,"strong"),e._uU(39,"Hint"),e.qZA(),e._uU(40," The "),e.TgZ(41,"code"),e._uU(42,"ExpressAdapter"),e.qZA(),e._uU(43," is imported from the "),e.TgZ(44,"code"),e._uU(45,"@nestjs/platform-express"),e.qZA(),e._uU(46," package. The "),e.TgZ(47,"code"),e._uU(48,"http"),e.qZA(),e._uU(49," and "),e.TgZ(50,"code"),e._uU(51,"https"),e.qZA(),e._uU(52," packages are native Node.js packages.\n"),e.qZA(),e.TgZ(53,"blockquote",9)(54,"strong"),e._uU(55,"Warning"),e.qZA(),e._uU(56," This recipe does not work with "),e.TgZ(57,"a",10),e._uU(58,"GraphQL Subscriptions"),e.qZA(),e._uU(59,".\n"),e.qZA()())},dependencies:[c.U,u.yS],encapsulation:2,changeDetection:0}),t})(),_=(()=>{class t extends s.y{}return t.\u0275fac=function(){let o;return function(r){return(o||(o=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-raw-body"]],features:[e.qOj],decls:53,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/faq/raw-body.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","raw-body"],["appAnchor","","id","use-with-express"],[1,"language-typescript"],["appAnchor","","id","use-with-fastify"]],template:function(n,r){1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Raw body"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"One of the most common use-case for having access to the raw request body is performing webhook signature verifications. Usually to perform webhook signature validations the unserialized request body is required to calculate an HMAC hash."),e.qZA(),e.TgZ(9,"h4",6)(10,"span"),e._uU(11,"Use with Express"),e.qZA()(),e.TgZ(12,"p"),e._uU(13,"First enable the option when creating your Nest Express application:"),e.qZA(),e.TgZ(14,"pre")(15,"code",7),e._uU(16,"\nconst app = await NestFactory.create(AppModule, {\n  rawBody: true,\n});\nawait app.listen(3000);\n"),e.qZA()(),e.TgZ(17,"p"),e._uU(18,"To access the raw request body in a controller, a convenience interface "),e.TgZ(19,"code"),e._uU(20,"RawBodyRequest"),e.qZA(),e._uU(21," is provided to expose a "),e.TgZ(22,"code"),e._uU(23,"rawBody"),e.qZA(),e._uU(24," field on the request: use the interface "),e.TgZ(25,"code"),e._uU(26,"RawBodyRequest"),e.qZA(),e._uU(27," type:"),e.qZA(),e.TgZ(28,"pre")(29,"code",7),e._uU(30,"\nimport { Controller, Post, RawBodyRequest, Req } from '@nestjs/common';\nimport { Request } from 'express';\n\n@Controller('cats')\nclass CatsController {\n  @Post()\n  create(@Req() req: RawBodyRequest<Request>) {\n    const raw = req.rawBody; // returns a `Buffer`.\n  }\n}\n"),e.qZA()(),e.TgZ(31,"h4",8)(32,"span"),e._uU(33,"Use with Fastify"),e.qZA()(),e.TgZ(34,"p"),e._uU(35,"First enable the option when creating your Nest Fastify application:"),e.qZA(),e.TgZ(36,"pre")(37,"code",7),e._uU(38,"\nconst app = await NestFactory.create<NestFastifyApplication>(\n  AppModule,\n  new FastifyAdapter()\n  {\n    rawBody: true,\n  }\n);\nawait app.listen(3000);\n"),e.qZA()(),e.TgZ(39,"p"),e._uU(40,"To access the raw request body in a controller, a convenience interface "),e.TgZ(41,"code"),e._uU(42,"RawBodyRequest"),e.qZA(),e._uU(43," is provided to expose a "),e.TgZ(44,"code"),e._uU(45,"rawBody"),e.qZA(),e._uU(46," field on the request: use the interface "),e.TgZ(47,"code"),e._uU(48,"RawBodyRequest"),e.qZA(),e._uU(49," type:"),e.qZA(),e.TgZ(50,"pre")(51,"code",7),e._uU(52,"\nimport { Controller, Post, RawBodyRequest, Req } from '@nestjs/common';\nimport { FastifyRequest } from 'fastify';\n\n@Controller('cats')\nclass CatsController {\n  @Post()\n  create(@Req() req: RawBodyRequest<FastifyRequest>) {\n    const raw = req.rawBody; // returns a `Buffer`.\n  }\n}\n"),e.qZA()()())},encapsulation:2,changeDetection:0}),t})(),A=(()=>{class t extends s.y{}return t.\u0275fac=function(){let o;return function(r){return(o||(o=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-request-lifecycle"]],features:[e.qOj],decls:145,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/faq/request-lifecycle.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","request-lifecycle"],["appAnchor","","id","middleware"],["routerLink","/middleware"],["appAnchor","","id","guards"],[1,"language-typescript"],[1,"info"],["appAnchor","","id","interceptors"],["rel","nofollow","target","_blank","href","https://github.com/ReactiveX/rxjs"],["appAnchor","","id","pipes"],["appAnchor","","id","filters"],["appAnchor","","id","summary"]],template:function(n,r){1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Request lifecycle"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"Nest applications handle requests and produce responses in a sequence we refer to as the "),e.TgZ(9,"strong"),e._uU(10,"request lifecycle"),e.qZA(),e._uU(11,". With the use of middleware, pipes, guards, and interceptors, it can be challenging to track down where a particular piece of code executes during the request lifecycle, especially as global, controller level, and route level components come into play. In general, a request flows through middleware to guards, then to interceptors, then to pipes and finally back to interceptors on the return path (as the response is generated)."),e.qZA(),e.TgZ(12,"h4",6)(13,"span"),e._uU(14,"Middleware"),e.qZA()(),e.TgZ(15,"p"),e._uU(16,"Middleware is executed in a particular sequence. First, Nest runs globally bound middleware (such as middleware bound with "),e.TgZ(17,"code"),e._uU(18,"app.use"),e.qZA(),e._uU(19,") and then it runs "),e.TgZ(20,"a",7),e._uU(21,"module bound middleware"),e.qZA(),e._uU(22,", which are determined on paths. Middleware are run sequentially in the order they are bound, similar to the way middleware in Express works. In the case of middleware bound across different modules, the middleware bound to the root module will run first, and then middleware will run in the order that the modules are added to the imports array."),e.qZA(),e.TgZ(23,"h4",8)(24,"span"),e._uU(25,"Guards"),e.qZA()(),e.TgZ(26,"p"),e._uU(27,"Guard execution starts with global guards, then proceeds to controller guards, and finally to route guards. As with middleware, guards run in the order in which they are bound. For example:"),e.qZA(),e.TgZ(28,"pre")(29,"code",9),e._uU(30,"\n@UseGuards(Guard1, Guard2)\n@Controller('cats')\nexport class CatsController {\n  constructor(private catsService: CatsService) {}\n\n  @UseGuards(Guard3)\n  @Get()\n  getCats(): Cats[] {\n    return this.catsService.getCats();\n  }\n}\n"),e.qZA()(),e.TgZ(31,"p")(32,"code"),e._uU(33,"Guard1"),e.qZA(),e._uU(34," will execute before "),e.TgZ(35,"code"),e._uU(36,"Guard2"),e.qZA(),e._uU(37," and both will execute before "),e.TgZ(38,"code"),e._uU(39,"Guard3"),e.qZA(),e._uU(40,"."),e.qZA(),e.TgZ(41,"blockquote",10)(42,"strong"),e._uU(43,"Hint"),e.qZA(),e._uU(44," When speaking about globally bound vs controller or locally bound, the difference is where the guard (or other component is bound). If you are using "),e.TgZ(45,"code"),e._uU(46,"app.useGlobalGuard()"),e.qZA(),e._uU(47," or providing the component via a module, it is globally bound. Otherwise, it is bound to a controller if the decorator precedes a controller class, or to a route if the decorator proceeds a route declaration.\n"),e.qZA(),e.TgZ(48,"h4",11)(49,"span"),e._uU(50,"Interceptors"),e.qZA()(),e.TgZ(51,"p"),e._uU(52,"Interceptors, for the most part, follow the same pattern as guards, with one catch: as interceptors return "),e.TgZ(53,"a",12),e._uU(54,"RxJS Observables"),e.qZA(),e._uU(55,", the observables will be resolved in a first in last out manner. So inbound requests will go through the standard global, controller, route level resolution, but the response side of the request (i.e., after returning from the controller method handler) will be resolved from route to controller to global. Also, any errors thrown by pipes, controllers, or services can be read in the "),e.TgZ(56,"code"),e._uU(57,"catchError"),e.qZA(),e._uU(58," operator of an interceptor."),e.qZA(),e.TgZ(59,"h4",13)(60,"span"),e._uU(61,"Pipes"),e.qZA()(),e.TgZ(62,"p"),e._uU(63,"Pipes follow the standard global to controller to route bound sequence, with the same first in first out in regards to the "),e.TgZ(64,"code"),e._uU(65,"@usePipes()"),e.qZA(),e._uU(66," parameters. However, at a route parameter level, if you have multiple pipes running, they will run in the order of the last parameter with a pipe to the first. This also applies to the route level and controller level pipes. For example, if we have the following controller:"),e.qZA(),e.TgZ(67,"pre")(68,"code",9),e._uU(69,"\n@UsePipes(GeneralValidationPipe)\n@Controller('cats')\nexport class CatsController {\n  constructor(private catsService: CatsService) {}\n\n  @UsePipes(RouteSpecificPipe)\n  @Patch(':id')\n  updateCat(\n    @Body() body: UpdateCatDTO,\n    @Param() params: UpdateCatParams,\n    @Query() query: UpdateCatQuery,\n  ) {\n    return this.catsService.updateCat(body, params, query);\n  }\n}\n"),e.qZA()(),e.TgZ(70,"p"),e._uU(71,"then the "),e.TgZ(72,"code"),e._uU(73,"GeneralValidationPipe"),e.qZA(),e._uU(74," will run for the "),e.TgZ(75,"code"),e._uU(76,"query"),e.qZA(),e._uU(77,", then the "),e.TgZ(78,"code"),e._uU(79,"params"),e.qZA(),e._uU(80,", and then the "),e.TgZ(81,"code"),e._uU(82,"body"),e.qZA(),e._uU(83," objects before moving on to the "),e.TgZ(84,"code"),e._uU(85,"RouteSpecificPipe"),e.qZA(),e._uU(86,", which follows the same order. If any parameter-specific pipes were in place, they would run (again, from the last to first parameter) after the controller and route level pipes."),e.qZA(),e.TgZ(87,"h4",14)(88,"span"),e._uU(89,"Filters"),e.qZA()(),e.TgZ(90,"p"),e._uU(91,"Filters are the only component that do not resolve global first. Instead, filters resolve from the lowest level possible, meaning execution starts with any route bound filters and proceeding next to controller level, and finally to global filters. Note that exceptions cannot be passed from filter to filter; if a route level filter catches the exception, a controller or global level filter cannot catch the same exception. The only way to achieve an effect like this is to use inheritance between the filters."),e.qZA(),e.TgZ(92,"blockquote",10)(93,"strong"),e._uU(94,"Hint"),e.qZA(),e._uU(95," Filters are only executed if any uncaught exception occurs during the request process. Caught exceptions, such as those caught with a "),e.TgZ(96,"code"),e._uU(97,"try/catch"),e.qZA(),e._uU(98," will not trigger Exception Filters to fire. As soon as an uncaught exception is encountered, the rest of the lifecycle is ignored and the request skips straight to the filter.\n"),e.qZA(),e.TgZ(99,"h4",15)(100,"span"),e._uU(101,"Summary"),e.qZA()(),e.TgZ(102,"p"),e._uU(103,"In general, the request lifecycle looks like the following:"),e.qZA(),e.TgZ(104,"ol")(105,"li"),e._uU(106,"Incoming request"),e.qZA(),e.TgZ(107,"li"),e._uU(108,"Globally bound middleware"),e.qZA(),e.TgZ(109,"li"),e._uU(110,"Module bound middleware"),e.qZA(),e.TgZ(111,"li"),e._uU(112,"Global guards"),e.qZA(),e.TgZ(113,"li"),e._uU(114,"Controller guards"),e.qZA(),e.TgZ(115,"li"),e._uU(116,"Route guards"),e.qZA(),e.TgZ(117,"li"),e._uU(118,"Global interceptors (pre-controller)"),e.qZA(),e.TgZ(119,"li"),e._uU(120,"Controller interceptors (pre-controller)"),e.qZA(),e.TgZ(121,"li"),e._uU(122,"Route interceptors (pre-controller)"),e.qZA(),e.TgZ(123,"li"),e._uU(124,"Global pipes"),e.qZA(),e.TgZ(125,"li"),e._uU(126,"Controller pipes"),e.qZA(),e.TgZ(127,"li"),e._uU(128,"Route pipes"),e.qZA(),e.TgZ(129,"li"),e._uU(130,"Route parameter pipes"),e.qZA(),e.TgZ(131,"li"),e._uU(132,"Controller (method handler)"),e.qZA(),e.TgZ(133,"li"),e._uU(134,"Service (if exists)"),e.qZA(),e.TgZ(135,"li"),e._uU(136,"Route interceptor (post-request)"),e.qZA(),e.TgZ(137,"li"),e._uU(138,"Controller interceptor (post-request)"),e.qZA(),e.TgZ(139,"li"),e._uU(140,"Global interceptor (post-request)"),e.qZA(),e.TgZ(141,"li"),e._uU(142,"Exception filters (route, then controller, then global)"),e.qZA(),e.TgZ(143,"li"),e._uU(144,"Server response"),e.qZA()()())},dependencies:[c.U,u.yS],encapsulation:2,changeDetection:0}),t})();var T=a(7297);const q=[{path:"global-prefix",component:Z,data:{title:"Global prefix - FAQ"}},{path:"hybrid-application",component:f,data:{title:"Hybrid application - FAQ"}},{path:"multiple-servers",component:U,data:{title:"HTTPS & Multiple Servers - FAQ"}},{path:"http-adapter",component:m,data:{title:"HTTP adapter - FAQ"}},{path:"raw-body",component:_,data:{title:"Raw Body"}},{path:"request-lifecycle",component:A,data:{title:"Request lifecycle - FAQ"}},{path:"common-errors",component:h,data:{title:"Common errors - FAQ"}},{path:"serverless",component:(()=>{class t extends s.y{}return t.\u0275fac=function(){let o;return function(r){return(o||(o=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-serverless"]],features:[e.qOj],decls:397,vars:4,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/faq/serverless.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","serverless"],["rel","nofollow","target","_blank","href","https://en.wikipedia.org/wiki/Serverless_computing"],[1,"info"],["appAnchor","","id","cold-start"],["routerLink","/standalone-applications"],["appAnchor","","id","benchmarks"],[1,"language-typescript"],["routerLink","/cli/overview"],[1,"language-javascript"],["appAnchor","","id","runtime-optimizations"],["routerLink","/fundamentals/async-providers"],["routerLink","/fundamentals/lazy-loading-modules"],["appAnchor","","id","example-integration"],["rel","nofollow","target","_blank","href","https://www.serverless.com/"],[1,"language-bash"],[1,"language-yaml"],["rel","nofollow","target","_blank","href","https://www.serverless.com/framework/docs/"],["href","/cli/monorepo#monorepo-mode"],[1,"warning"],["rel","nofollow","target","_blank","href","https://javascript.plainenglish.io/serverless-nestjs-document-your-api-with-swagger-and-aws-api-gateway-64a53962e8a2"],[1,"language-json"],["appAnchor","","id","using-standalone-application-feature"],[1,"filename"],["appbc2a59673c6674ef178e9c9cc991043376364264",""]],template:function(n,r){if(1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Serverless"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"Serverless computing is a cloud computing execution model in which the cloud provider allocates machine resources on-demand, taking care of the servers on behalf of their customers. When an app is not in use, there are no computing resources allocated to the app. Pricing is based on the actual amount of resources consumed by an application ("),e.TgZ(9,"a",6),e._uU(10,"source"),e.qZA(),e._uU(11,")."),e.qZA(),e.TgZ(12,"p"),e._uU(13,"With a "),e.TgZ(14,"strong"),e._uU(15,"serverless architecture"),e.qZA(),e._uU(16,", you focus purely on the individual functions in your application code. Services such as AWS Lambda, Google Cloud Functions, and Microsoft Azure Functions take care of all the physical hardware, virtual machine operating system, and web server software management."),e.qZA(),e.TgZ(17,"blockquote",7)(18,"strong"),e._uU(19,"Hint"),e.qZA(),e._uU(20," This chapter does not cover the pros and cons of serverless functions nor dives into the specifics of any cloud providers.\n"),e.qZA(),e.TgZ(21,"h4",8)(22,"span"),e._uU(23,"Cold start"),e.qZA()(),e.TgZ(24,"p"),e._uU(25,"A cold start is the first time your code has been executed in a while. Depending on a cloud provider you use, it may span several different operations, from downloading the code and bootstrapping the runtime to eventually running your code.\nThis process adds "),e.TgZ(26,"strong"),e._uU(27,"significant latency"),e.qZA(),e._uU(28," depending on several factors, the language, the number of packages your application require, etc."),e.qZA(),e.TgZ(29,"p"),e._uU(30,"The cold start is important and although there are things which are beyond our control, there's still a lot of things we can do on our side to make it as short as possible."),e.qZA(),e.TgZ(31,"p"),e._uU(32,"While you can think of Nest as a fully-fledged framework designed to be used in complex, enterprise applications,\nit is also "),e.TgZ(33,"strong"),e._uU(34,'suitable for much "simpler" applications'),e.qZA(),e._uU(35," (or scripts). For example, with the use of "),e.TgZ(36,"a",9),e._uU(37,"Standalone applications"),e.qZA(),e._uU(38," feature, you can take advantage of Nest's DI system in simple workers, CRON jobs, CLIs, or serverless functions."),e.qZA(),e.TgZ(39,"h4",10)(40,"span"),e._uU(41,"Benchmarks"),e.qZA()(),e.TgZ(42,"p"),e._uU(43,"To better understand what's the cost of using Nest or other, well-known libraries (like "),e.TgZ(44,"code"),e._uU(45,"express"),e.qZA(),e._uU(46,") in the context of serverless functions, let's compare how much time Node runtime needs to run the following scripts:"),e.qZA(),e.TgZ(47,"pre")(48,"code",11),e._uU(49,"\n// #1 Express\nimport * as express from 'express';\n\nasync function bootstrap() {\n  const app = express();\n  app.get('/', (req, res) => res.send('Hello world!'));\n  await new Promise<void>((resolve) => app.listen(3000, resolve));\n}\nbootstrap();\n\n// #2 Nest (with @nestjs/platform-express)\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule, { logger: ['error'] });\n  await app.listen(3000);\n}\nbootstrap();\n\n// #3 Nest as a Standalone application (no HTTP server)\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { AppService } from './app.service';\n\nasync function bootstrap() {\n  const app = await NestFactory.createApplicationContext(AppModule, {\n    logger: ['error'],\n  });\n  console.log(app.get(AppService).getHello());\n}\nbootstrap();\n\n// #4 Raw Node.js script\nasync function bootstrap() {\n  console.log('Hello world!');\n}\nbootstrap();\n"),e.qZA()(),e.TgZ(50,"p"),e._uU(51,"For all these scripts, we used the "),e.TgZ(52,"code"),e._uU(53,"tsc"),e.qZA(),e._uU(54," (TypeScript) compiler and so the code remains unbundled ("),e.TgZ(55,"code"),e._uU(56,"webpack"),e.qZA(),e._uU(57," isn't used)."),e.qZA(),e.TgZ(58,"table"),e._UZ(59,"thead"),e.TgZ(60,"tbody")(61,"tr")(62,"td"),e._uU(63,"Express"),e.qZA(),e.TgZ(64,"td"),e._uU(65,"0.0079s (7.9ms)"),e.qZA()(),e.TgZ(66,"tr")(67,"td"),e._uU(68,"Nest with "),e.TgZ(69,"code"),e._uU(70,"@nestjs/platform-express"),e.qZA()(),e.TgZ(71,"td"),e._uU(72,"0.1974s (197.4ms)"),e.qZA()(),e.TgZ(73,"tr")(74,"td"),e._uU(75,"Nest (standalone application)"),e.qZA(),e.TgZ(76,"td"),e._uU(77,"0.1117s (111.7ms)"),e.qZA()(),e.TgZ(78,"tr")(79,"td"),e._uU(80,"Raw Node.js script"),e.qZA(),e.TgZ(81,"td"),e._uU(82,"0.0071s (7.1ms)"),e.qZA()()()(),e.TgZ(83,"blockquote",7)(84,"strong"),e._uU(85,"Note"),e.qZA(),e._uU(86," Machine: MacBook Pro Mid 2014, 2.5 GHz Quad-Core Intel Core i7, 16 GB 1600 MHz DDR3, SSD.\n"),e.qZA(),e.TgZ(87,"p"),e._uU(88,"Now, let's repeat all benchmarks but this time, using "),e.TgZ(89,"code"),e._uU(90,"webpack"),e.qZA(),e._uU(91," (if you have "),e.TgZ(92,"a",12),e._uU(93,"Nest CLI"),e.qZA(),e._uU(94," installed, you can run "),e.TgZ(95,"code"),e._uU(96,"nest build --webpack"),e.qZA(),e._uU(97,") to bundle our application into a single executable JavaScript file.\nHowever, instead of using the default "),e.TgZ(98,"code"),e._uU(99,"webpack"),e.qZA(),e._uU(100," configuration that Nest CLI ships with, we'll make sure to bundle all dependencies ("),e.TgZ(101,"code"),e._uU(102,"node_modules"),e.qZA(),e._uU(103,") together, as follows:"),e.qZA(),e.TgZ(104,"pre")(105,"code",13),e._uU(106,"\nmodule.exports = (options, webpack) => {\n  const lazyImports = [\n    '@nestjs/microservices/microservices-module',\n    '@nestjs/websockets/socket-module',\n  ];\n\n  return {\n    ...options,\n    externals: [],\n    plugins: [\n      ...options.plugins,\n      new webpack.IgnorePlugin({\n        checkResource(resource) {\n          if (lazyImports.includes(resource)) {\n            try {\n              require.resolve(resource);\n            } catch (err) {\n              return true;\n            }\n          }\n          return false;\n        },\n      }),\n    ],\n  };\n};\n"),e.qZA()(),e.TgZ(107,"blockquote",7)(108,"strong"),e._uU(109,"Hint"),e.qZA(),e._uU(110," To instruct Nest CLI to use this configuration, create a new "),e.TgZ(111,"code"),e._uU(112,"webpack.config.js"),e.qZA(),e._uU(113," file in the root directory of your project.\n"),e.qZA(),e.TgZ(114,"p"),e._uU(115,"With this configuration, we received the following results:"),e.qZA(),e.TgZ(116,"table"),e._UZ(117,"thead"),e.TgZ(118,"tbody")(119,"tr")(120,"td"),e._uU(121,"Express"),e.qZA(),e.TgZ(122,"td"),e._uU(123,"0.0068s (6.8ms)"),e.qZA()(),e.TgZ(124,"tr")(125,"td"),e._uU(126,"Nest with "),e.TgZ(127,"code"),e._uU(128,"@nestjs/platform-express"),e.qZA()(),e.TgZ(129,"td"),e._uU(130,"0.0815s (81.5ms)"),e.qZA()(),e.TgZ(131,"tr")(132,"td"),e._uU(133,"Nest (standalone application)"),e.qZA(),e.TgZ(134,"td"),e._uU(135,"0.0319s (31.9ms)"),e.qZA()(),e.TgZ(136,"tr")(137,"td"),e._uU(138,"Raw Node.js script"),e.qZA(),e.TgZ(139,"td"),e._uU(140,"0.0066s (6.6ms)"),e.qZA()()()(),e.TgZ(141,"blockquote",7)(142,"strong"),e._uU(143,"Note"),e.qZA(),e._uU(144," Machine: MacBook Pro Mid 2014, 2.5 GHz Quad-Core Intel Core i7, 16 GB 1600 MHz DDR3, SSD.\n"),e.qZA(),e.TgZ(145,"blockquote",7)(146,"strong"),e._uU(147,"Hint"),e.qZA(),e._uU(148," You could optimize it even further by applying additional code minification & optimization techniques (using "),e.TgZ(149,"code"),e._uU(150,"webpack"),e.qZA(),e._uU(151," plugins, etc.).\n"),e.qZA(),e.TgZ(152,"p"),e._uU(153,"As you can see, the way you compile (and whether you bundle your code) is crucial and has a significant impact on the overall startup time. With "),e.TgZ(154,"code"),e._uU(155,"webpack"),e.qZA(),e._uU(156,", you can get the bootstrap time of a standalone Nest application (starter project with one module, controller, and service) down to ~32ms on average, and down to ~81.5ms for a regular HTTP, express-based NestJS app."),e.qZA(),e.TgZ(157,"p"),e._uU(158,"For more complicated Nest applications, for example, with 10 resources (generated through "),e.TgZ(159,"code"),e._uU(160,"$ nest g resource"),e.qZA(),e._uU(161," schematic = 10 modules, 10 controllers, 10 services, 20 DTO classes, 50 HTTP endpoints + "),e.TgZ(162,"code"),e._uU(163,"AppModule"),e.qZA(),e._uU(164,"), the overall startup on MacBook Pro Mid 2014, 2.5 GHz Quad-Core Intel Core i7, 16 GB 1600 MHz DDR3, SSD is approximately 0.1298s (129.8ms). Running a monolithic application as a serverless function typically doesn't make too much sense anyway, so think of this benchmark more as an example of how the bootstrap time may potentially increase as your application grows."),e.qZA(),e.TgZ(165,"h4",14)(166,"span"),e._uU(167,"Runtime optimizations"),e.qZA()(),e.TgZ(168,"p"),e._uU(169,"Thus far we covered compile-time optimizations. These are unrelated to the way you define providers and load Nest modules in your application, and that plays an essential role as your application gets bigger."),e.qZA(),e.TgZ(170,"p"),e._uU(171,"For example, imagine having a database connection defined as an "),e.TgZ(172,"a",15),e._uU(173,"asynchronous provider"),e.qZA(),e._uU(174,". Async providers are designed to delay the application start until one or more asynchronous tasks are completed.\nThat means, if your serverless function on average requires 2s to connect to the database (on bootstrap), your endpoint will need at least two extra seconds (because it must wait till the connection is established) to send a response back (when it's a cold start and your application wasn't running already)."),e.qZA(),e.TgZ(175,"p"),e._uU(176,"As you can see, the way you structure your providers is somewhat different in a "),e.TgZ(177,"strong"),e._uU(178,"serverless environment"),e.qZA(),e._uU(179," where bootstrap time is important.\nAnother good example is if you use Redis for caching, but only in certain scenarios. Perhaps, in this case, you should not define a Redis connection as an async provider, as it would slow down the bootstrap time, even if it's not required for this specific function invocation."),e.qZA(),e.TgZ(180,"p"),e._uU(181,"Also, sometimes you could lazy-load entire modules, using the "),e.TgZ(182,"code"),e._uU(183,"LazyModuleLoader"),e.qZA(),e._uU(184," class, as described in "),e.TgZ(185,"a",16),e._uU(186,"this chapter"),e.qZA(),e._uU(187,". Caching is a great example here too.\nImagine that your application has, let's say, "),e.TgZ(188,"code"),e._uU(189,"CacheModule"),e.qZA(),e._uU(190," which internally connects to Redis and also, exports the "),e.TgZ(191,"code"),e._uU(192,"CacheService"),e.qZA(),e._uU(193," to interact with the Redis storage. If you don't need it for all potential function invocations,\nyou can just load it on-demand, lazily. This way you'll get a faster startup time (when a cold start occurs) for all invocations that don't require caching."),e.qZA(),e.TgZ(194,"pre")(195,"code",11),e._uU(196,"\nif (request.method === RequestMethod[RequestMethod.GET]) {\n  const { CacheModule } = await import('./cache.module');\n  const moduleRef = await this.lazyModuleLoader.load(() => CacheModule);\n\n  const { CacheService } = await import('./cache.service');\n  const cacheService = moduleRef.get(CacheService);\n\n  return cacheService.get(ENDPOINT_KEY);\n}\n"),e.qZA()(),e.TgZ(197,"p"),e._uU(198,"Another great example is a webhook or worker, which depending on some specific conditions (e.g., input arguments), may perform different operations.\nIn such a case, you could specify a condition inside your route handler that lazily loads an appropriate module for the specific function invocation, and just load every other module lazily."),e.qZA(),e.TgZ(199,"pre")(200,"code",11),e._uU(201,"\nif (workerType === WorkerType.A) {\n  const { WorkerAModule } = await import('./worker-a.module');\n  const moduleRef = await this.lazyModuleLoader.load(() => WorkerAModule);\n  // ...\n} else if (workerType === WorkerType.B) {\n  const { WorkerBModule } = await import('./worker-b.module');\n  const moduleRef = await this.lazyModuleLoader.load(() => WorkerBModule);\n  // ...\n}\n"),e.qZA()(),e.TgZ(202,"h4",17)(203,"span"),e._uU(204,"Example integration"),e.qZA()(),e.TgZ(205,"p"),e._uU(206,"The way your application's entry file (typically "),e.TgZ(207,"code"),e._uU(208,"main.ts"),e.qZA(),e._uU(209," file) is supposed to look like "),e.TgZ(210,"strong"),e._uU(211,"depends on several factors"),e.qZA(),e._uU(212," and so "),e.TgZ(213,"strong"),e._uU(214,"there's no single template"),e.qZA(),e._uU(215," that just works for every scenario.\nFor example, the initialization file required to spin up your serverless function varies by cloud providers (AWS, Azure, GCP, etc.).\nAlso, depending on whether you want to run a typical HTTP application with multiple routes/endpoints or just provide a single route (or execute a specific portion of code),\nyour application's code will look different (for example, for the endpoint-per-function approach you could use the "),e.TgZ(216,"code"),e._uU(217,"NestFactory.createApplicationContext"),e.qZA(),e._uU(218," instead of booting the HTTP server, setting up middleware, etc.)."),e.qZA(),e.TgZ(219,"p"),e._uU(220,"Just for illustration purposes, we'll integrate Nest (using "),e.TgZ(221,"code"),e._uU(222,"@nestjs/platform-express"),e.qZA(),e._uU(223," and so spinning up the whole, fully functional HTTP router)\nwith the "),e.TgZ(224,"a",18),e._uU(225,"Serverless"),e.qZA(),e._uU(226," framework (in this case, targetting AWS Lambda). As we've mentioned earlier, your code will differ depending on the cloud provider you choose, and many other factors."),e.qZA(),e.TgZ(227,"p"),e._uU(228,"First, let's install the required packages:"),e.qZA(),e.TgZ(229,"pre")(230,"code",19),e._uU(231,"\n$ npm i @vendia/serverless-express aws-lambda\n$ npm i -D @types/aws-lambda serverless-offline\n"),e.qZA()(),e.TgZ(232,"blockquote",7)(233,"strong"),e._uU(234,"Hint"),e.qZA(),e._uU(235," To speed up development cycles, we install the "),e.TgZ(236,"code"),e._uU(237,"serverless-offline"),e.qZA(),e._uU(238," plugin which emulates AWS \u03bb and API Gateway.\n"),e.qZA(),e.TgZ(239,"p"),e._uU(240,"Once the installation process is complete, let's create the "),e.TgZ(241,"code"),e._uU(242,"serverless.yml"),e.qZA(),e._uU(243," file to configure the Serverless framework:"),e.qZA(),e.TgZ(244,"pre")(245,"code",20),e._uU(246,"\nservice: serverless-example\n\nplugins:\n  - serverless-offline\n\nprovider:\n  name: aws\n  runtime: nodejs14.x\n\nfunctions:\n  main:\n    handler: dist/main.handler\n    events:\n      - http:\n          method: ANY\n          path: /\n      - http:\n          method: ANY\n          path: '{proxy+}'\n"),e.qZA()(),e.TgZ(247,"blockquote",7)(248,"strong"),e._uU(249,"Hint"),e.qZA(),e._uU(250," To learn more about the Serverless framework, visit the "),e.TgZ(251,"a",21),e._uU(252,"official documentation"),e.qZA(),e._uU(253,".\n"),e.qZA(),e.TgZ(254,"p"),e._uU(255,"With this place, we can now navigate to the "),e.TgZ(256,"code"),e._uU(257,"main.ts"),e.qZA(),e._uU(258," file and update our bootstrap code with the required boilerplate:"),e.qZA(),e.TgZ(259,"pre")(260,"code",11),e._uU(261,"\nimport { NestFactory } from '@nestjs/core';\nimport serverlessExpress from '@vendia/serverless-express';\nimport { Callback, Context, Handler } from 'aws-lambda';\nimport { AppModule } from './app.module';\n\nlet server: Handler;\n\nasync function bootstrap(): Promise<Handler> {\n  const app = await NestFactory.create(AppModule);\n  await app.init();\n\n  const expressApp = app.getHttpAdapter().getInstance();\n  return serverlessExpress({ app: expressApp });\n}\n\nexport const handler: Handler = async (\n  event: any,\n  context: Context,\n  callback: Callback,\n) => {\n  server = server ?? (await bootstrap());\n  return server(event, context, callback);\n};\n"),e.qZA()(),e.TgZ(262,"blockquote",7)(263,"strong"),e._uU(264,"Hint"),e.qZA(),e._uU(265," For creating multiple serverless functions and sharing common modules between them, we recommend using the "),e.TgZ(266,"a",22),e._uU(267,"CLI Monorepo mode"),e.qZA(),e._uU(268,".\n"),e.qZA(),e.TgZ(269,"blockquote",23)(270,"strong"),e._uU(271,"Warning"),e.qZA(),e._uU(272," If you use "),e.TgZ(273,"code"),e._uU(274,"@nestjs/swagger"),e.qZA(),e._uU(275," package, there are a few additional steps required to make it work properly in the context of serverless function. Check out this "),e.TgZ(276,"a",24),e._uU(277,"article"),e.qZA(),e._uU(278," for more information.\n"),e.qZA(),e.TgZ(279,"p"),e._uU(280,"Next, open up the "),e.TgZ(281,"code"),e._uU(282,"tsconfig.json"),e.qZA(),e._uU(283," file and make sure to enable the "),e.TgZ(284,"code"),e._uU(285,"esModuleInterop"),e.qZA(),e._uU(286," option to make the "),e.TgZ(287,"code"),e._uU(288,"@vendia/serverless-express"),e.qZA(),e._uU(289," package load properly."),e.qZA(),e.TgZ(290,"pre")(291,"code",25),e._uU(292,'\n{\n  "compilerOptions": {\n    ...\n    "esModuleInterop": true\n  }\n}\n'),e.qZA()(),e.TgZ(293,"p"),e._uU(294,"Now we can build our application (with "),e.TgZ(295,"code"),e._uU(296,"nest build"),e.qZA(),e._uU(297," or "),e.TgZ(298,"code"),e._uU(299,"tsc"),e.qZA(),e._uU(300,") and use the "),e.TgZ(301,"code"),e._uU(302,"serverless"),e.qZA(),e._uU(303," CLI to start our lambda function locally:"),e.qZA(),e.TgZ(304,"pre")(305,"code",19),e._uU(306,"\n$ npm run build\n$ npx serverless offline\n"),e.qZA()(),e.TgZ(307,"p"),e._uU(308,"Once the application is running, open your browser and navigate to "),e.TgZ(309,"code"),e._uU(310,"http://localhost:3000/dev/[ANY_ROUTE]"),e.qZA(),e._uU(311," (where "),e.TgZ(312,"code"),e._uU(313,"[ANY_ROUTE]"),e.qZA(),e._uU(314," is any endpoint registered in your application)."),e.qZA(),e.TgZ(315,"p"),e._uU(316,"In the sections above, we've shown that using "),e.TgZ(317,"code"),e._uU(318,"webpack"),e.qZA(),e._uU(319," and bundling your app can have significant impact on the overall bootstrap time.\nHowever, to make it work with our example, there are a few additional configurations you must add in your "),e.TgZ(320,"code"),e._uU(321,"webpack.config.js"),e.qZA(),e._uU(322," file. Generally,\nto make sure our "),e.TgZ(323,"code"),e._uU(324,"handler"),e.qZA(),e._uU(325," function will be picked up, we must change the "),e.TgZ(326,"code"),e._uU(327,"output.libraryTarget"),e.qZA(),e._uU(328," property to "),e.TgZ(329,"code"),e._uU(330,"commonjs2"),e.qZA(),e._uU(331,"."),e.qZA(),e.TgZ(332,"pre")(333,"code",13),e._uU(334,"\nreturn {\n  ...options,\n  externals: [],\n  output: {\n    ...options.output,\n    libraryTarget: 'commonjs2',\n  },\n  // ... the rest of the configuration\n};\n"),e.qZA()(),e.TgZ(335,"p"),e._uU(336,"With this in place, you can now use "),e.TgZ(337,"code"),e._uU(338,"$ nest build --webpack"),e.qZA(),e._uU(339," to compile your function's code (and then "),e.TgZ(340,"code"),e._uU(341,"$ npx serverless offline"),e.qZA(),e._uU(342," to test it)."),e.qZA(),e.TgZ(343,"p"),e._uU(344,"It's also recommended (but "),e.TgZ(345,"strong"),e._uU(346,"not required"),e.qZA(),e._uU(347," as it will slow down your build process) to install the "),e.TgZ(348,"code"),e._uU(349,"terser-webpack-plugin"),e.qZA(),e._uU(350," package and override its configuration to keep classnames intact when minifying your production build. Not doing so can result in incorrect behavior when using "),e.TgZ(351,"code"),e._uU(352,"class-validator"),e.qZA(),e._uU(353," within your application."),e.qZA(),e.TgZ(354,"pre")(355,"code",13),e._uU(356,"\nconst TerserPlugin = require('terser-webpack-plugin');\n\nreturn {\n  ...options,\n  externals: [],\n  optimization: {\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          keep_classnames: true,\n        },\n      }),\n    ],\n  },\n  output: {\n    ...options.output,\n    libraryTarget: 'commonjs2',\n  },\n  // ... the rest of the configuration\n};\n"),e.qZA()(),e.TgZ(357,"h4",26)(358,"span"),e._uU(359,"Using standalone application feature"),e.qZA()(),e.TgZ(360,"p"),e._uU(361,"Alternatively, if you want to keep your function very lightweight and you don't need any HTTP-related features (routing, but also guards, interceptors, pipes, etc.),\nyou can just use "),e.TgZ(362,"code"),e._uU(363,"NestFactory.createApplicationContext"),e.qZA(),e._uU(364," (as mentioned earlier) instead of running the entire HTTP server (and "),e.TgZ(365,"code"),e._uU(366,"express"),e.qZA(),e._uU(367," under the hood), as follows:"),e.qZA(),e.TgZ(368,"span",27),e._uU(369),e.ALo(370,"extension"),e._UZ(371,"app-tabs",null,28),e.qZA(),e.TgZ(373,"pre")(374,"code",11),e._uU(375,"\nimport { HttpStatus } from '@nestjs/common';\nimport { NestFactory } from '@nestjs/core';\nimport { Callback, Context, Handler } from 'aws-lambda';\nimport { AppModule } from './app.module';\nimport { AppService } from './app.service';\n\nexport const handler: Handler = async (\n  event: any,\n  context: Context,\n  callback: Callback,\n) => {\n  const appContext = await NestFactory.createApplicationContext(AppModule);\n  const appService = appContext.get(AppService);\n\n  return {\n    body: appService.getHello(),\n    statusCode: HttpStatus.OK,\n  };\n};\n"),e.qZA()(),e.TgZ(376,"blockquote",7)(377,"strong"),e._uU(378,"Hint"),e.qZA(),e._uU(379," Be aware that "),e.TgZ(380,"code"),e._uU(381,"NestFactory.createApplicationContext"),e.qZA(),e._uU(382," does not wrap controller methods with enhancers (guard, interceptors, etc.). For this, you must use the "),e.TgZ(383,"code"),e._uU(384,"NestFactory.create"),e.qZA(),e._uU(385," method.\n"),e.qZA(),e.TgZ(386,"p"),e._uU(387,"You could also pass the "),e.TgZ(388,"code"),e._uU(389,"event"),e.qZA(),e._uU(390," object down to, let's say, "),e.TgZ(391,"code"),e._uU(392,"EventsService"),e.qZA(),e._uU(393," provider that could process it and return a corresponding value (depending on the input value and your business logic)."),e.qZA(),e.TgZ(394,"pre")(395,"code",11),e._uU(396,"\nexport const handler: Handler = async (\n  event: any,\n  context: Context,\n  callback: Callback,\n) => {\n  const appContext = await NestFactory.createApplicationContext(AppModule);\n  const eventsService = appContext.get(EventsService);\n  return eventsService.process(event);\n};\n"),e.qZA()()()),2&n){const i=e.MAs(372);e.xp6(369),e.hij(" ",e.xi3(370,1,"main",i.isJsActive),"\n")}},dependencies:[p.n,c.U,u.yS,T.F],encapsulation:2,changeDetection:0}),t})(),data:{title:"Serverless - FAQ"}}];let y=(()=>{class t{}return t.\u0275fac=function(n){return new(n||t)},t.\u0275mod=e.oAB({type:t}),t.\u0275inj=e.cJS({imports:[d.ez,g.m,u.Bz.forChild(q)]}),t})()}}]);