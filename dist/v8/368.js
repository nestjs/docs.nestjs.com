"use strict";(self.webpackChunkdocs_nestjs_com=self.webpackChunkdocs_nestjs_com||[]).push([[368],{3368:(M,h,i)=>{i.r(h),i.d(h,{GraphqlModule:()=>j});var g=i(9808),u=i(215),Z=i(4466),s=i(4834),e=i(4893),a=i(4521);let U=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-migration"]],features:[e.qOj],decls:122,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/migration.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","migrating-to-v10"],["appAnchor","","id","introducing-driver-packages"],[1,"language-typescript"],["appAnchor","","id","plugins"],["appAnchor","","id","directives"],["rel","nofollow","target","_blank","href","https://www.graphql-tools.com/docs/schema-directives"],["appAnchor","","id","federation"],[1,"info"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Migrating to v10"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"This article provides a set of guidelines for migrating from "),e.TgZ(9,"code"),e._uU(10,"@nestjs/graphql"),e.qZA(),e._uU(11," version 9 to version 10. The focus of this major-version release is to provide a lighter, platform-agnostic core library."),e.qZA(),e.TgZ(12,"h4",6)(13,"span"),e._uU(14,'Introducing "driver" packages'),e.qZA()(),e.TgZ(15,"p"),e._uU(16,"In the latest version, we made a decision to break the "),e.TgZ(17,"code"),e._uU(18,"@nestjs/graphql"),e.qZA(),e._uU(19," package up into a few separate libraries, letting you choose whether to use Apollo ("),e.TgZ(20,"code"),e._uU(21,"@nestjs/apollo"),e.qZA(),e._uU(22,"), Mercurius ("),e.TgZ(23,"code"),e._uU(24,"@nestjs/mercurius"),e.qZA(),e._uU(25,"), or another GraphQL library in your project."),e.qZA(),e.TgZ(26,"p"),e._uU(27,"This implies that now you have to explicitly specify what driver your application will use."),e.qZA(),e.TgZ(28,"pre")(29,"code",7),e._uU(30,"\n// Before\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot({\n      autoSchemaFile: 'schema.gql',\n    }),\n  ],\n})\nexport class AppModule {}\n\n// After\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<ApolloDriverConfig>({\n      driver: ApolloDriver,\n      autoSchemaFile: 'schema.gql',\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(31,"h4",8)(32,"span"),e._uU(33,"Plugins"),e.qZA()(),e.TgZ(34,"p"),e._uU(35,"Apollo Server plugins let you perform custom operations in response to certain events. Since this is an exclusive Apollo feature, we moved it from the "),e.TgZ(36,"code"),e._uU(37,"@nestjs/graphql"),e.qZA(),e._uU(38," to the newly created "),e.TgZ(39,"code"),e._uU(40,"@nestjs/apollo"),e.qZA(),e._uU(41," package so you'll have to update imports in your application."),e.qZA(),e.TgZ(42,"pre")(43,"code",7),e._uU(44,"\n// Before\nimport { Plugin } from '@nestjs/graphql';\n\n// After\nimport { Plugin } from '@nestjs/apollo';\n"),e.qZA()(),e.TgZ(45,"h4",9)(46,"span"),e._uU(47,"Directives"),e.qZA()(),e.TgZ(48,"p")(49,"code"),e._uU(50,"schemaDirectives"),e.qZA(),e._uU(51," feature has been replaced with the new "),e.TgZ(52,"a",10),e._uU(53,"Schema directives API"),e.qZA(),e._uU(54," in v8 of "),e.TgZ(55,"code"),e._uU(56,"@graphql-tools/schema"),e.qZA(),e._uU(57," package."),e.qZA(),e.TgZ(58,"pre")(59,"code",7),e._uU(60,"\n// Before\nimport { SchemaDirectiveVisitor } from '@graphql-tools/utils';\nimport { defaultFieldResolver, GraphQLField } from 'graphql';\n\nexport class UpperCaseDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field: GraphQLField<any, any>) {\n    const { resolve = defaultFieldResolver } = field;\n    field.resolve = async function (...args) {\n      const result = await resolve.apply(this, args);\n      if (typeof result === 'string') {\n        return result.toUpperCase();\n      }\n      return result;\n    };\n  }\n}\n\n// After\nimport { getDirective, MapperKind, mapSchema } from '@graphql-tools/utils';\nimport { defaultFieldResolver, GraphQLSchema } from 'graphql';\n\nexport function upperDirectiveTransformer(\n  schema: GraphQLSchema,\n  directiveName: string,\n) {\n  return mapSchema(schema, {\n    [MapperKind.OBJECT_FIELD]: (fieldConfig) => {\n      const upperDirective = getDirective(\n        schema,\n        fieldConfig,\n        directiveName,\n      )?.[0];\n\n      if (upperDirective) {\n        const { resolve = defaultFieldResolver } = fieldConfig;\n\n        // Replace the original resolver with a function that *first* calls\n        // the original resolver, then converts its result to upper case\n        fieldConfig.resolve = async function (source, args, context, info) {\n          const result = await resolve(source, args, context, info);\n          if (typeof result === 'string') {\n            return result.toUpperCase();\n          }\n          return result;\n        };\n        return fieldConfig;\n      }\n    },\n  });\n}\n"),e.qZA()(),e.TgZ(61,"p"),e._uU(62,"To apply this directive implementation to a schema that contains "),e.TgZ(63,"code"),e._uU(64,"@upper"),e.qZA(),e._uU(65," directives, use the "),e.TgZ(66,"code"),e._uU(67,"transformSchema"),e.qZA(),e._uU(68," function:"),e.qZA(),e.TgZ(69,"pre")(70,"code",7),e._uU(71,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  ...\n  transformSchema: schema => upperDirectiveTransformer(schema, 'upper'),\n})\n"),e.qZA()(),e.TgZ(72,"h4",11)(73,"span"),e._uU(74,"Federation"),e.qZA()(),e.TgZ(75,"p")(76,"code"),e._uU(77,"GraphQLFederationModule"),e.qZA(),e._uU(78," has been removed and replaced with the corresponding driver class:"),e.qZA(),e.TgZ(79,"pre")(80,"code",7),e._uU(81,"\n// Before\nGraphQLFederationModule.forRoot({\n  autoSchemaFile: true,\n});\n\n// After\nGraphQLModule.forRoot<ApolloFederationDriverConfig>({\n  driver: ApolloFederationDriver,\n  autoSchemaFile: true,\n});\n"),e.qZA()(),e.TgZ(82,"blockquote",12)(83,"strong"),e._uU(84,"Hint"),e.qZA(),e._uU(85," Both "),e.TgZ(86,"code"),e._uU(87,"ApolloFederationDriver"),e.qZA(),e._uU(88," class and "),e.TgZ(89,"code"),e._uU(90,"ApolloFederationDriverConfig"),e.qZA(),e._uU(91," are exported from the "),e.TgZ(92,"code"),e._uU(93,"@nestjs/apollo"),e.qZA(),e._uU(94," package.\n"),e.qZA(),e.TgZ(95,"p"),e._uU(96,"Likewise, instead of using a dedicated "),e.TgZ(97,"code"),e._uU(98,"GraphQLGatewayModule"),e.qZA(),e._uU(99,", simply pass the appropriate "),e.TgZ(100,"code"),e._uU(101,"driver"),e.qZA(),e._uU(102," class to your "),e.TgZ(103,"code"),e._uU(104,"GraphQLModule"),e.qZA(),e._uU(105," settings:"),e.qZA(),e.TgZ(106,"pre")(107,"code",7),e._uU(108,"\n// Before\nGraphQLGatewayModule.forRoot({\n  gateway: {\n    supergraphSdl: new IntrospectAndCompose({\n      subgraphs: [\n        { name: 'users', url: 'http://localhost:3000/graphql' },\n        { name: 'posts', url: 'http://localhost:3001/graphql' },\n      ],\n    }),\n  },\n});\n\n// After\nGraphQLModule.forRoot<ApolloGatewayDriverConfig>({\n  driver: ApolloGatewayDriver,\n  gateway: {\n    supergraphSdl: new IntrospectAndCompose({\n      subgraphs: [\n        { name: 'users', url: 'http://localhost:3000/graphql' },\n        { name: 'posts', url: 'http://localhost:3001/graphql' },\n      ],\n    }),\n  },\n});\n"),e.qZA()(),e.TgZ(109,"blockquote",12)(110,"strong"),e._uU(111,"Hint"),e.qZA(),e._uU(112," Both "),e.TgZ(113,"code"),e._uU(114,"ApolloGatewayDriver"),e.qZA(),e._uU(115," class and "),e.TgZ(116,"code"),e._uU(117,"ApolloGatewayDriverConfig"),e.qZA(),e._uU(118," are exported from the "),e.TgZ(119,"code"),e._uU(120,"@nestjs/apollo"),e.qZA(),e._uU(121," package.\n"),e.qZA()())},dependencies:[a.U],encapsulation:2,changeDetection:0}),t})();var l=i(4336),d=i(7297);let m=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-cli-plugin"]],features:[e.qOj],decls:241,vars:8,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/cli-plugin.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","cli-plugin"],[1,"warning"],[1,"info"],["appAnchor","","id","overview"],[1,"filename"],["app3f8acd4375b250d137528cf029da70670a1b86de",""],[1,"language-typescript"],["appb5217189ea12517a1aa7f09a531181616bafabca",""],["appAnchor","","id","comments-introspection"],["appAnchor","","id","using-the-cli-plugin"],["routerLink","/cli/overview"],[1,"language-javascript"],["appAnchor","","id","integration-with-ts-jest-e2e-tests"],[1,"language-json"]],template:function(o,r){if(1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"CLI Plugin"),e.qZA(),e.TgZ(7,"blockquote",6)(8,"strong"),e._uU(9,"Warning"),e.qZA(),e._uU(10," This chapter applies only to the code first approach.\n"),e.qZA(),e.TgZ(11,"p"),e._uU(12,"TypeScript's metadata reflection system has several limitations which make it impossible to, for instance, determine what properties a class consists of or recognize whether a given property is optional or required. However, some of these constraints can be addressed at compilation time. Nest provides a plugin that enhances the TypeScript compilation process to reduce the amount of boilerplate code required."),e.qZA(),e.TgZ(13,"blockquote",7)(14,"strong"),e._uU(15,"Hint"),e.qZA(),e._uU(16," This plugin is "),e.TgZ(17,"strong"),e._uU(18,"opt-in"),e.qZA(),e._uU(19,". If you prefer, you can declare all decorators manually, or only specific decorators where you need them.\n"),e.qZA(),e.TgZ(20,"h4",8)(21,"span"),e._uU(22,"Overview"),e.qZA()(),e.TgZ(23,"p"),e._uU(24,"The GraphQL plugin will automatically:"),e.qZA(),e.TgZ(25,"ul")(26,"li"),e._uU(27,"annotate all input object, object type and args classes properties with "),e.TgZ(28,"code"),e._uU(29,"@Field"),e.qZA(),e._uU(30," unless "),e.TgZ(31,"code"),e._uU(32,"@HideField"),e.qZA(),e._uU(33," is used"),e.qZA(),e.TgZ(34,"li"),e._uU(35,"set the "),e.TgZ(36,"code"),e._uU(37,"nullable"),e.qZA(),e._uU(38," property depending on the question mark (e.g. "),e.TgZ(39,"code"),e._uU(40,"name?: string"),e.qZA(),e._uU(41," will set "),e.TgZ(42,"code"),e._uU(43,"nullable: true"),e.qZA(),e._uU(44,")"),e.qZA(),e.TgZ(45,"li"),e._uU(46,"set the "),e.TgZ(47,"code"),e._uU(48,"type"),e.qZA(),e._uU(49," property depending on the type (supports arrays as well)"),e.qZA(),e.TgZ(50,"li"),e._uU(51,"generate descriptions for properties based on comments (if "),e.TgZ(52,"code"),e._uU(53,"introspectComments"),e.qZA(),e._uU(54," set to "),e.TgZ(55,"code"),e._uU(56,"true"),e.qZA(),e._uU(57,")"),e.qZA()(),e.TgZ(58,"p"),e._uU(59,"Please, note that your filenames "),e.TgZ(60,"strong"),e._uU(61,"must have"),e.qZA(),e._uU(62," one of the following suffixes in order to be analyzed by the plugin: "),e.TgZ(63,"code"),e._uU(64,"['.input.ts', '.args.ts', '.entity.ts', '.model.ts']"),e.qZA(),e._uU(65," (e.g., "),e.TgZ(66,"code"),e._uU(67,"author.entity.ts"),e.qZA(),e._uU(68,"). If you are using a different suffix, you can adjust the plugin's behavior by specifying the "),e.TgZ(69,"code"),e._uU(70,"typeFileNameSuffix"),e.qZA(),e._uU(71," option (see below)."),e.qZA(),e.TgZ(72,"p"),e._uU(73,"With what we've learned so far, you have to duplicate a lot of code to let the package know how your type should be declared in GraphQL. For example, you could define a simple "),e.TgZ(74,"code"),e._uU(75,"Author"),e.qZA(),e._uU(76," class as follows:"),e.qZA(),e.TgZ(77,"span",9),e._uU(78),e.ALo(79,"extension"),e._UZ(80,"app-tabs",null,10),e.qZA(),e.TgZ(82,"pre")(83,"code",11),e._uU(84,"\n@ObjectType()\nexport class Author {\n  @Field(type => ID)\n  id: number;\n\n  @Field({ nullable: true })\n  firstName?: string;\n\n  @Field({ nullable: true })\n  lastName?: string;\n\n  @Field(type => [Post])\n  posts: Post[];\n}\n"),e.qZA()(),e.TgZ(85,"p"),e._uU(86,"While not a significant issue with medium-sized projects, it becomes verbose & hard to maintain once you have a large set of classes."),e.qZA(),e.TgZ(87,"p"),e._uU(88,"By enabling the GraphQL plugin, the above class definition can be declared simply:"),e.qZA(),e.TgZ(89,"span",9),e._uU(90),e.ALo(91,"extension"),e._UZ(92,"app-tabs",null,12),e.qZA(),e.TgZ(94,"pre")(95,"code",11),e._uU(96,"\n@ObjectType()\nexport class Author {\n  @Field(type => ID)\n  id: number;\n  firstName?: string;\n  lastName?: string;\n  posts: Post[];\n}\n"),e.qZA()(),e.TgZ(97,"p"),e._uU(98,"The plugin adds appropriate decorators on-the-fly based on the "),e.TgZ(99,"strong"),e._uU(100,"Abstract Syntax Tree"),e.qZA(),e._uU(101,". Thus, you won't have to struggle with "),e.TgZ(102,"code"),e._uU(103,"@Field"),e.qZA(),e._uU(104," decorators scattered throughout the code."),e.qZA(),e.TgZ(105,"blockquote",7)(106,"strong"),e._uU(107,"Hint"),e.qZA(),e._uU(108," The plugin will automatically generate any missing GraphQL properties, but if you need to override them, simply set them explicitly via "),e.TgZ(109,"code"),e._uU(110,"@Field()"),e.qZA(),e._uU(111,".\n"),e.qZA(),e.TgZ(112,"h4",13)(113,"span"),e._uU(114,"Comments introspection"),e.qZA()(),e.TgZ(115,"p"),e._uU(116,"With the comments introspection feature enabled, CLI plugin will generate descriptions for fields based on comments."),e.qZA(),e.TgZ(117,"p"),e._uU(118,"For example, given an example "),e.TgZ(119,"code"),e._uU(120,"roles"),e.qZA(),e._uU(121," property:"),e.qZA(),e.TgZ(122,"pre")(123,"code",11),e._uU(124,"\n/**\n * A list of user's roles\n */\n@Field(() => [String], {\n  description: `A list of user's roles`\n})\nroles: string[];\n"),e.qZA()(),e.TgZ(125,"p"),e._uU(126,"You must duplicate description values. With "),e.TgZ(127,"code"),e._uU(128,"introspectComments"),e.qZA(),e._uU(129," enabled, the CLI plugin can extract these comments and automatically provide descriptions for properties. Now, the above field can be declared simply as follows:"),e.qZA(),e.TgZ(130,"pre")(131,"code",11),e._uU(132,"\n/**\n * A list of user's roles\n */\nroles: string[];\n"),e.qZA()(),e.TgZ(133,"h4",14)(134,"span"),e._uU(135,"Using the CLI plugin"),e.qZA()(),e.TgZ(136,"p"),e._uU(137,"To enable the plugin, open "),e.TgZ(138,"code"),e._uU(139,"nest-cli.json"),e.qZA(),e._uU(140," (if you use "),e.TgZ(141,"a",15),e._uU(142,"Nest CLI"),e.qZA(),e._uU(143,") and add the following "),e.TgZ(144,"code"),e._uU(145,"plugins"),e.qZA(),e._uU(146," configuration:"),e.qZA(),e.TgZ(147,"pre")(148,"code",16),e._uU(149,'\n{\n  "collection": "@nestjs/schematics",\n  "sourceRoot": "src",\n  "compilerOptions": {\n    "plugins": ["@nestjs/graphql"]\n  }\n}\n'),e.qZA()(),e.TgZ(150,"p"),e._uU(151,"You can use the "),e.TgZ(152,"code"),e._uU(153,"options"),e.qZA(),e._uU(154," property to customize the behavior of the plugin."),e.qZA(),e.TgZ(155,"pre")(156,"code",16),e._uU(157,'\n"plugins": [\n  {\n    "name": "@nestjs/graphql",\n    "options": {\n      "typeFileNameSuffix": [".input.ts", ".args.ts"],\n      "introspectComments": true\n    }\n  }\n]\n'),e.qZA()(),e.TgZ(158,"p"),e._uU(159,"The "),e.TgZ(160,"code"),e._uU(161,"options"),e.qZA(),e._uU(162," property has to fulfill the following interface:"),e.qZA(),e.TgZ(163,"pre")(164,"code",11),e._uU(165,"\nexport interface PluginOptions {\n  typeFileNameSuffix?: string[];\n  introspectComments?: boolean;\n}\n"),e.qZA()(),e.TgZ(166,"table")(167,"tr")(168,"th"),e._uU(169,"Option"),e.qZA(),e.TgZ(170,"th"),e._uU(171,"Default"),e.qZA(),e.TgZ(172,"th"),e._uU(173,"Description"),e.qZA()(),e.TgZ(174,"tr")(175,"td")(176,"code"),e._uU(177,"typeFileNameSuffix"),e.qZA()(),e.TgZ(178,"td")(179,"code"),e._uU(180,"['.input.ts', '.args.ts', '.entity.ts', '.model.ts']"),e.qZA()(),e.TgZ(181,"td"),e._uU(182,"GraphQL types files suffix"),e.qZA()(),e.TgZ(183,"tr")(184,"td")(185,"code"),e._uU(186,"introspectComments"),e.qZA()(),e.TgZ(187,"td")(188,"code"),e._uU(189,"false"),e.qZA()(),e.TgZ(190,"td"),e._uU(191,"If set to true, plugin will generate descriptions for properties based on comments"),e.qZA()()(),e.TgZ(192,"p"),e._uU(193,"If you don't use the CLI but instead have a custom "),e.TgZ(194,"code"),e._uU(195,"webpack"),e.qZA(),e._uU(196," configuration, you can use this plugin in combination with "),e.TgZ(197,"code"),e._uU(198,"ts-loader"),e.qZA(),e._uU(199,":"),e.qZA(),e.TgZ(200,"pre")(201,"code",16),e._uU(202,"\ngetCustomTransformers: (program: any) => ({\n  before: [require('@nestjs/graphql/plugin').before({}, program)]\n}),\n"),e.qZA()(),e.TgZ(203,"h4",17)(204,"span"),e._uU(205,"Integration with "),e.TgZ(206,"code"),e._uU(207,"ts-jest"),e.qZA(),e._uU(208," (e2e tests)"),e.qZA()(),e.TgZ(209,"p"),e._uU(210,"When running e2e tests with this plugin enabled, you may run into issues with compiling schema. For example, one of the most common errors is:"),e.qZA(),e.TgZ(211,"pre")(212,"code",18),e._uU(213,"\nObject type <name> must define one or more fields.\n"),e.qZA()(),e.TgZ(214,"p"),e._uU(215,"This happens because "),e.TgZ(216,"code"),e._uU(217,"jest"),e.qZA(),e._uU(218," configuration does not import "),e.TgZ(219,"code"),e._uU(220,"@nestjs/graphql/plugin"),e.qZA(),e._uU(221," plugin anywhere."),e.qZA(),e.TgZ(222,"p"),e._uU(223,"To fix this, create the following file in your e2e tests directory:"),e.qZA(),e.TgZ(224,"pre")(225,"code",16),e._uU(226,"\nconst transformer = require('@nestjs/graphql/plugin');\n\nmodule.exports.name = 'nestjs-graphql-transformer';\n// you should change the version number anytime you change the configuration below - otherwise, jest will not detect changes\nmodule.exports.version = 1;\n\nmodule.exports.factory = (cs) => {\n  return transformer.before(\n    {\n      // @nestjs/graphql/plugin options (can be empty)\n    },\n    cs.program, // \"cs.tsCompiler.program\" for older versions of Jest (<= v27)\n  );\n};\n"),e.qZA()(),e.TgZ(227,"p"),e._uU(228,"With this in place, import AST transformer within your "),e.TgZ(229,"code"),e._uU(230,"jest"),e.qZA(),e._uU(231," configuration file. By default (in the starter application), e2e tests configuration file is located under the "),e.TgZ(232,"code"),e._uU(233,"test"),e.qZA(),e._uU(234," folder and is named "),e.TgZ(235,"code"),e._uU(236,"jest-e2e.json"),e.qZA(),e._uU(237,"."),e.qZA(),e.TgZ(238,"pre")(239,"code",18),e._uU(240,'\n{\n  ... // other configuration\n  "globals": {\n    "ts-jest": {\n      "astTransformers": {\n        "before": ["<path to the file created above>"],\n      }\n    }\n  }\n}\n'),e.qZA()()()),2&o){const p=e.MAs(81),c=e.MAs(93);e.xp6(78),e.hij(" ",e.xi3(79,2,"authors/models/author.model",p.isJsActive),"\n"),e.xp6(12),e.hij(" ",e.xi3(91,5,"authors/models/author.model",c.isJsActive),"\n")}},dependencies:[l.n,a.U,u.yS,d.F],encapsulation:2,changeDetection:0}),t})(),_=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-complexity"]],features:[e.qOj],decls:106,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/complexity.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","complexity"],[1,"warning"],["rel","nofollow","target","_blank","href","https://github.com/slicknode/graphql-query-complexity"],["appAnchor","","id","installation"],[1,"language-bash"],["appAnchor","","id","getting-started"],[1,"language-typescript"],[1,"info"],["appAnchor","","id","field-level-complexity"],["appAnchor","","id","querymutation-level-complexity"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Complexity"),e.qZA(),e.TgZ(7,"blockquote",6)(8,"strong"),e._uU(9,"Warning"),e.qZA(),e._uU(10," This chapter applies only to the code first approach.\n"),e.qZA(),e.TgZ(11,"p"),e._uU(12,"Query complexity allows you to define how complex certain fields are, and to restrict queries with a "),e.TgZ(13,"strong"),e._uU(14,"maximum complexity"),e.qZA(),e._uU(15,". The idea is to define how complex each field is by using a simple number. A common default is to give each field a complexity of "),e.TgZ(16,"code"),e._uU(17,"1"),e.qZA(),e._uU(18,". In addition, the complexity calculation of a GraphQL query can be customized with so-called complexity estimators. A complexity estimator is a simple function that calculates the complexity for a field. You can add any number of complexity estimators to the rule, which are then executed one after another. The first estimator that returns a numeric complexity value determines the complexity for that field."),e.qZA(),e.TgZ(19,"p"),e._uU(20,"The "),e.TgZ(21,"code"),e._uU(22,"@nestjs/graphql"),e.qZA(),e._uU(23," package integrates very well with tools like "),e.TgZ(24,"a",7),e._uU(25,"graphql-query-complexity"),e.qZA(),e._uU(26," that provides a cost analysis-based solution. With this library, you can reject queries to your GraphQL server that are deemed too costly to execute."),e.qZA(),e.TgZ(27,"h4",8)(28,"span"),e._uU(29,"Installation"),e.qZA()(),e.TgZ(30,"p"),e._uU(31,"To begin using it, we first install the required dependency."),e.qZA(),e.TgZ(32,"pre")(33,"code",9),e._uU(34,"\n$ npm install --save graphql-query-complexity\n"),e.qZA()(),e.TgZ(35,"h4",10)(36,"span"),e._uU(37,"Getting started"),e.qZA()(),e.TgZ(38,"p"),e._uU(39,"Once the installation process is complete, we can define the "),e.TgZ(40,"code"),e._uU(41,"ComplexityPlugin"),e.qZA(),e._uU(42," class:"),e.qZA(),e.TgZ(43,"pre")(44,"code",11),e._uU(45,"\nimport { GraphQLSchemaHost } from \"@nestjs/graphql\";\nimport { Plugin } from \"@nestjs/apollo\";\nimport {\n  ApolloServerPlugin,\n  GraphQLRequestListener,\n} from 'apollo-server-plugin-base';\nimport { GraphQLError } from 'graphql';\nimport {\n  fieldExtensionsEstimator,\n  getComplexity,\n  simpleEstimator,\n} from 'graphql-query-complexity';\n\n@Plugin()\nexport class ComplexityPlugin implements ApolloServerPlugin {\n  constructor(private gqlSchemaHost: GraphQLSchemaHost) {}\n\n  async requestDidStart(): Promise<GraphQLRequestListener> {\n    const maxComplexity = 20;\n    const { schema } = this.gqlSchemaHost;\n\n    return {\n      async didResolveOperation({ request, document }) {\n        const complexity = getComplexity({\n          schema,\n          operationName: request.operationName,\n          query: document,\n          variables: request.variables,\n          estimators: [\n            fieldExtensionsEstimator(),\n            simpleEstimator({ defaultComplexity: 1 }),\n          ],\n        });\n        if (complexity > maxComplexity) {\n          throw new GraphQLError(\n            `Query is too complex: ${complexity}. Maximum allowed complexity: ${maxComplexity}`,\n          );\n        }\n        console.log('Query Complexity:', complexity);\n      },\n    };\n  }\n}\n"),e.qZA()(),e.TgZ(46,"p"),e._uU(47,"For demonstration purposes, we specified the maximum allowed complexity as "),e.TgZ(48,"code"),e._uU(49,"20"),e.qZA(),e._uU(50,". In the example above, we used 2 estimators, the "),e.TgZ(51,"code"),e._uU(52,"simpleEstimator"),e.qZA(),e._uU(53," and the "),e.TgZ(54,"code"),e._uU(55,"fieldExtensionsEstimator"),e.qZA(),e._uU(56,"."),e.qZA(),e.TgZ(57,"ul")(58,"li")(59,"code"),e._uU(60,"simpleEstimator"),e.qZA(),e._uU(61,": the simple estimator returns a fixed complexity for each field"),e.qZA(),e.TgZ(62,"li")(63,"code"),e._uU(64,"fieldExtensionsEstimator"),e.qZA(),e._uU(65,": the field extensions estimator extracts the complexity value for each field of your schema"),e.qZA()(),e.TgZ(66,"blockquote",12)(67,"strong"),e._uU(68,"Hint"),e.qZA(),e._uU(69," Remember to add this class to the providers array in any module.\n"),e.qZA(),e.TgZ(70,"h4",13)(71,"span"),e._uU(72,"Field-level complexity"),e.qZA()(),e.TgZ(73,"p"),e._uU(74,"With this plugin in place, we can now define the complexity for any field by specifying the "),e.TgZ(75,"code"),e._uU(76,"complexity"),e.qZA(),e._uU(77," property in the options object passed into the "),e.TgZ(78,"code"),e._uU(79,"@Field()"),e.qZA(),e._uU(80," decorator, as follows:"),e.qZA(),e.TgZ(81,"pre")(82,"code",11),e._uU(83,"\n@Field({ complexity: 3 })\ntitle: string;\n"),e.qZA()(),e.TgZ(84,"p"),e._uU(85,"Alternatively, you can define the estimator function:"),e.qZA(),e.TgZ(86,"pre")(87,"code",11),e._uU(88,"\n@Field({ complexity: (options: ComplexityEstimatorArgs) => ... })\ntitle: string;\n"),e.qZA()(),e.TgZ(89,"h4",14)(90,"span"),e._uU(91,"Query/Mutation-level complexity"),e.qZA()(),e.TgZ(92,"p"),e._uU(93,"In addition, "),e.TgZ(94,"code"),e._uU(95,"@Query()"),e.qZA(),e._uU(96," and "),e.TgZ(97,"code"),e._uU(98,"@Mutation()"),e.qZA(),e._uU(99," decorators may have a "),e.TgZ(100,"code"),e._uU(101,"complexity"),e.qZA(),e._uU(102," property specified like so:"),e.qZA(),e.TgZ(103,"pre")(104,"code",11),e._uU(105,"\n@Query({ complexity: (options: ComplexityEstimatorArgs) => options.args.count * options.childComplexity })\nitems(@Args('count') count: number) {\n  return this.itemsService.getItems({ count });\n}\n"),e.qZA()()())},dependencies:[a.U],encapsulation:2,changeDetection:0}),t})(),A=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-directives"]],features:[e.qOj],decls:122,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/directives.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","directives"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/queries/#directives"],["appAnchor","","id","custom-directives"],[1,"language-typescript"],["appAnchor","","id","code-first"],[1,"info"],[1,"warn"],["appAnchor","","id","schema-first"],[1,"language-graphql"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Directives"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"A directive can be attached to a field or fragment inclusion, and can affect execution of the query in any way the server desires (read more "),e.TgZ(9,"a",6),e._uU(10,"here"),e.qZA(),e._uU(11,"). The GraphQL specification provides several default directives:"),e.qZA(),e.TgZ(12,"ul")(13,"li")(14,"code"),e._uU(15,"@include(if: Boolean)"),e.qZA(),e._uU(16," - only include this field in the result if the argument is true"),e.qZA(),e.TgZ(17,"li")(18,"code"),e._uU(19,"@skip(if: Boolean)"),e.qZA(),e._uU(20," - skip this field if the argument is true"),e.qZA(),e.TgZ(21,"li")(22,"code"),e._uU(23,"@deprecated(reason: String)"),e.qZA(),e._uU(24," - marks field as deprecated with message"),e.qZA()(),e.TgZ(25,"p"),e._uU(26,"A directive is an identifier preceded by a "),e.TgZ(27,"code"),e._uU(28,"@"),e.qZA(),e._uU(29," character, optionally followed by a list of named arguments, which can appear after almost any element in the GraphQL query and schema languages."),e.qZA(),e.TgZ(30,"h4",7)(31,"span"),e._uU(32,"Custom directives"),e.qZA()(),e.TgZ(33,"p"),e._uU(34,"To instruct what should happen when Apollo/Mercurius encounters your directive, you can create a transformer function. This function uses the "),e.TgZ(35,"code"),e._uU(36,"mapSchema"),e.qZA(),e._uU(37," function to iterate through locations in your schema (field definitions, type definitions, etc.) and perform corresponding transformations."),e.qZA(),e.TgZ(38,"pre")(39,"code",8),e._uU(40,"\nimport { getDirective, MapperKind, mapSchema } from '@graphql-tools/utils';\nimport { defaultFieldResolver, GraphQLSchema } from 'graphql';\n\nexport function upperDirectiveTransformer(\n  schema: GraphQLSchema,\n  directiveName: string,\n) {\n  return mapSchema(schema, {\n    [MapperKind.OBJECT_FIELD]: (fieldConfig) => {\n      const upperDirective = getDirective(\n        schema,\n        fieldConfig,\n        directiveName,\n      )?.[0];\n\n      if (upperDirective) {\n        const { resolve = defaultFieldResolver } = fieldConfig;\n\n        // Replace the original resolver with a function that *first* calls\n        // the original resolver, then converts its result to upper case\n        fieldConfig.resolve = async function (source, args, context, info) {\n          const result = await resolve(source, args, context, info);\n          if (typeof result === 'string') {\n            return result.toUpperCase();\n          }\n          return result;\n        };\n        return fieldConfig;\n      }\n    },\n  });\n}\n"),e.qZA()(),e.TgZ(41,"p"),e._uU(42,"Now, apply the "),e.TgZ(43,"code"),e._uU(44,"upperDirectiveTransformer"),e.qZA(),e._uU(45," transformation function in the "),e.TgZ(46,"code"),e._uU(47,"GraphQLModule#forRoot"),e.qZA(),e._uU(48," method using the "),e.TgZ(49,"code"),e._uU(50,"transformSchema"),e.qZA(),e._uU(51," function:"),e.qZA(),e.TgZ(52,"pre")(53,"code",8),e._uU(54,"\nGraphQLModule.forRoot({\n  // ...\n  transformSchema: (schema) => upperDirectiveTransformer(schema, 'upper'),\n});\n"),e.qZA()(),e.TgZ(55,"p"),e._uU(56,"Once registered, the "),e.TgZ(57,"code"),e._uU(58,"@upper"),e.qZA(),e._uU(59," directive can be used in our schema. However, the way you apply the directive will vary depending on the approach you use (code first or schema first)."),e.qZA(),e.TgZ(60,"h4",9)(61,"span"),e._uU(62,"Code first"),e.qZA()(),e.TgZ(63,"p"),e._uU(64,"In the code first approach, use the "),e.TgZ(65,"code"),e._uU(66,"@Directive()"),e.qZA(),e._uU(67," decorator to apply the directive."),e.qZA(),e.TgZ(68,"pre")(69,"code",8),e._uU(70,"\n@Directive('@upper')\n@Field()\ntitle: string;\n"),e.qZA()(),e.TgZ(71,"blockquote",10)(72,"strong"),e._uU(73,"Hint"),e.qZA(),e._uU(74," The "),e.TgZ(75,"code"),e._uU(76,"@Directive()"),e.qZA(),e._uU(77," decorator is exported from the "),e.TgZ(78,"code"),e._uU(79,"@nestjs/graphql"),e.qZA(),e._uU(80," package.\n"),e.qZA(),e.TgZ(81,"p"),e._uU(82,"Directives can be applied on fields, field resolvers, input and object types, as well as queries, mutations, and subscriptions. Here's an example of the directive applied on the query handler level:"),e.qZA(),e.TgZ(83,"pre")(84,"code",8),e._uU(85,"\n@Directive('@deprecated(reason: \"This query will be removed in the next version\")')\n@Query(returns => Author, { name: 'author' })\nasync getAuthor(@Args({ name: 'id', type: () => Int }) id: number) {\n  return this.authorsService.findOneById(id);\n}\n"),e.qZA()(),e.TgZ(86,"blockquote",11)(87,"strong"),e._uU(88,"Warning"),e.qZA(),e._uU(89," Directives applied through the "),e.TgZ(90,"code"),e._uU(91,"@Directive()"),e.qZA(),e._uU(92," decorator will not be reflected in the generated schema definition file.\n"),e.qZA(),e.TgZ(93,"p"),e._uU(94,"Lastly, make sure to declare directives in the "),e.TgZ(95,"code"),e._uU(96,"GraphQLModule"),e.qZA(),e._uU(97,", as follows:"),e.qZA(),e.TgZ(98,"pre")(99,"code",8),e._uU(100,"\nGraphQLModule.forRoot({\n  // ...,\n  transformSchema: schema => upperDirectiveTransformer(schema, 'upper'),\n  buildSchemaOptions: {\n    directives: [\n      new GraphQLDirective({\n        name: 'upper',\n        locations: [DirectiveLocation.FIELD_DEFINITION],\n      }),\n    ],\n  },\n}),\n"),e.qZA()(),e.TgZ(101,"blockquote",10)(102,"strong"),e._uU(103,"Hint"),e.qZA(),e._uU(104," Both "),e.TgZ(105,"code"),e._uU(106,"GraphQLDirective"),e.qZA(),e._uU(107," and "),e.TgZ(108,"code"),e._uU(109,"DirectiveLocation"),e.qZA(),e._uU(110," are exported from the "),e.TgZ(111,"code"),e._uU(112,"graphql"),e.qZA(),e._uU(113," package.\n"),e.qZA(),e.TgZ(114,"h4",12)(115,"span"),e._uU(116,"Schema first"),e.qZA()(),e.TgZ(117,"p"),e._uU(118,"In the schema first approach, apply directives directly in SDL."),e.qZA(),e.TgZ(119,"pre")(120,"code",13),e._uU(121,"\ndirective @upper on FIELD_DEFINITION\n\ntype Post {\n  id: Int!\n  title: String! @upper\n  votes: Int\n}\n"),e.qZA()()())},dependencies:[a.U],encapsulation:2,changeDetection:0}),t})(),f=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-extensions"]],features:[e.qOj],decls:70,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/extensions.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","extensions"],[1,"warning"],["appAnchor","","id","adding-custom-metadata"],[1,"language-typescript"],["appAnchor","","id","using-custom-metadata"],["routerLink","/graphql/field-middleware"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Extensions"),e.qZA(),e.TgZ(7,"blockquote",6)(8,"strong"),e._uU(9,"Warning"),e.qZA(),e._uU(10," This chapter applies only to the code first approach.\n"),e.qZA(),e.TgZ(11,"p"),e._uU(12,"Extensions is an "),e.TgZ(13,"strong"),e._uU(14,"advanced, low-level feature"),e.qZA(),e._uU(15," that lets you define arbitrary data in the types configuration. Attaching custom metadata to certain fields allows you to create more sophisticated, generic solutions. For example, with extensions, you can define field-level roles required to access particular fields. Such roles can be reflected at runtime to determine whether the caller has sufficient permissions to retrieve a specific field."),e.qZA(),e.TgZ(16,"h4",7)(17,"span"),e._uU(18,"Adding custom metadata"),e.qZA()(),e.TgZ(19,"p"),e._uU(20,"To attach custom metadata for a field, use the "),e.TgZ(21,"code"),e._uU(22,"@Extensions()"),e.qZA(),e._uU(23," decorator exported from the "),e.TgZ(24,"code"),e._uU(25,"@nestjs/graphql"),e.qZA(),e._uU(26," package."),e.qZA(),e.TgZ(27,"pre")(28,"code",8),e._uU(29,"\n@Field()\n@Extensions({ role: Role.ADMIN })\npassword: string;\n"),e.qZA()(),e.TgZ(30,"p"),e._uU(31,"In the example above, we assigned the "),e.TgZ(32,"code"),e._uU(33,"role"),e.qZA(),e._uU(34," metadata property the value of "),e.TgZ(35,"code"),e._uU(36,"Role.ADMIN"),e.qZA(),e._uU(37,". "),e.TgZ(38,"code"),e._uU(39,"Role"),e.qZA(),e._uU(40," is a simple TypeScript enum that groups all the user roles available in our system."),e.qZA(),e.TgZ(41,"p"),e._uU(42,"Note, in addition to setting metadata on fields, you can use the "),e.TgZ(43,"code"),e._uU(44,"@Extensions()"),e.qZA(),e._uU(45," decorator at the class level and method level (e.g., on the query handler)."),e.qZA(),e.TgZ(46,"h4",9)(47,"span"),e._uU(48,"Using custom metadata"),e.qZA()(),e.TgZ(49,"p"),e._uU(50,"Logic that leverages the custom metadata can be as complex as needed. For example, you can create a simple interceptor that stores/logs events per method invocation, or a "),e.TgZ(51,"a",10),e._uU(52,"field middleware"),e.qZA(),e._uU(53," that matches roles required to retrieve a field with the caller permissions (field-level permissions system)."),e.qZA(),e.TgZ(54,"p"),e._uU(55,"For illustration purposes, let's define a "),e.TgZ(56,"code"),e._uU(57,"checkRoleMiddleware"),e.qZA(),e._uU(58," that compares a user's role (hardcoded here) with a role required to access a target field:"),e.qZA(),e.TgZ(59,"pre")(60,"code",8),e._uU(61,'\nexport const checkRoleMiddleware: FieldMiddleware = async (\n  ctx: MiddlewareContext,\n  next: NextFn,\n) => {\n  const { info } = ctx;\n  const { extensions } = info.parentType.getFields()[info.fieldName];\n\n  /**\n   * In a real-world application, the "userRole" variable\n   * should represent the caller\'s (user) role (for example, "ctx.user.role").\n   */\n  const userRole = Role.USER;\n  if (userRole === extensions.role) {\n    // or just "return null" to ignore\n    throw new ForbiddenException(\n      `User does not have sufficient permissions to access "${info.fieldName}" field.`,\n    );\n  }\n  return next();\n};\n'),e.qZA()(),e.TgZ(62,"p"),e._uU(63,"With this in place, we can register a middleware for the "),e.TgZ(64,"code"),e._uU(65,"password"),e.qZA(),e._uU(66," field, as follows:"),e.qZA(),e.TgZ(67,"pre")(68,"code",8),e._uU(69,"\n@Field({ middleware: [checkRoleMiddleware] })\n@Extensions({ role: Role.ADMIN })\npassword: string;\n"),e.qZA()()())},dependencies:[a.U,u.yS],encapsulation:2,changeDetection:0}),t})(),q=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-federation"]],features:[e.qOj],decls:508,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/federation.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","federation"],["rel","nofollow","target","_blank","href","https://blog.apollographql.com/apollo-federation-f260cf525d21"],[1,"warning"],["appAnchor","","id","federation-with-apollo"],[1,"language-bash"],["appAnchor","","id","schema-first"],[1,"language-graphql"],[1,"language-typescript"],["appAnchor","","id","code-first"],[1,"language-ts"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/tree/master/sample/31-graphql-federation-code-first/users-application"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/tree/master/sample/32-graphql-federation-schema-first/users-application"],["appAnchor","","id","federated-example-posts"],["appAnchor","","id","schema-first-1"],["appAnchor","","id","code-first-1"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/tree/master/sample/31-graphql-federation-code-first/posts-application"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/tree/master/sample/32-graphql-federation-schema-first/posts-application"],["appAnchor","","id","federated-example-gateway"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/tree/master/sample/31-graphql-federation-code-first/gateway"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/tree/master/sample/32-graphql-federation-schema-first/gateway"],["appAnchor","","id","federation-with-mercurius"],[1,"info"],["appAnchor","","id","schema-first-2"],["appAnchor","","id","code-first-2"],["appAnchor","","id","federated-example-posts-1"],["appAnchor","","id","schema-first-3"],["appAnchor","","id","code-first-3"],["appAnchor","","id","federated-example-gateway-1"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Federation"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"Federation offers a means of splitting your monolithic GraphQL server into independent microservices. It consists of two components: a gateway and one or more federated microservices. Each microservice holds part of the schema and the gateway merges the schemas into a single schema that can be consumed by the client."),e.qZA(),e.TgZ(9,"p"),e._uU(10,"To quote the "),e.TgZ(11,"a",6),e._uU(12,"Apollo docs"),e.qZA(),e._uU(13,", Federation is designed with these core principles:"),e.qZA(),e.TgZ(14,"ul")(15,"li"),e._uU(16,"Building a graph should be "),e.TgZ(17,"strong"),e._uU(18,"declarative."),e.qZA(),e._uU(19," With federation, you compose a graph declaratively from within your schema instead of writing imperative schema stitching code."),e.qZA(),e.TgZ(20,"li"),e._uU(21,"Code should be separated by "),e.TgZ(22,"strong"),e._uU(23,"concern"),e.qZA(),e._uU(24,", not by types. Often no single team controls every aspect of an important type like a User or Product, so the definition of these types should be distributed across teams and codebases, rather than centralized."),e.qZA(),e.TgZ(25,"li"),e._uU(26,"The graph should be simple for clients to consume. Together, federated services can form a complete, product-focused graph that accurately reflects how it\u2019s being consumed on the client."),e.qZA(),e.TgZ(27,"li"),e._uU(28,"It\u2019s just "),e.TgZ(29,"strong"),e._uU(30,"GraphQL"),e.qZA(),e._uU(31,", using only spec-compliant features of the language. Any language, not just JavaScript, can implement federation."),e.qZA()(),e.TgZ(32,"blockquote",7)(33,"strong"),e._uU(34,"Warning"),e.qZA(),e._uU(35," Federation currently does not support subscriptions.\n"),e.qZA(),e.TgZ(36,"p"),e._uU(37,"In the following sections, we'll set up a demo application that consits of a gateway and two federated endpoints: Users service and Posts service."),e.qZA(),e.TgZ(38,"h4",8)(39,"span"),e._uU(40,"Federation with Apollo"),e.qZA()(),e.TgZ(41,"p"),e._uU(42,"Start by installing the required dependencies:"),e.qZA(),e.TgZ(43,"pre")(44,"code",9),e._uU(45,"\n$ npm install --save @apollo/federation @apollo/subgraph\n"),e.qZA()(),e.TgZ(46,"h4",10)(47,"span"),e._uU(48,"Schema first"),e.qZA()(),e.TgZ(49,"p"),e._uU(50,'The "User service" provides a simple schema. Note the '),e.TgZ(51,"code"),e._uU(52,"@key"),e.qZA(),e._uU(53," directive: it instructs the Apollo query planner that a particular instance of "),e.TgZ(54,"code"),e._uU(55,"User"),e.qZA(),e._uU(56," can be fetched if you specify its "),e.TgZ(57,"code"),e._uU(58,"id"),e.qZA(),e._uU(59,". Also, note that we "),e.TgZ(60,"code"),e._uU(61,"extend"),e.qZA(),e._uU(62," the "),e.TgZ(63,"code"),e._uU(64,"Query"),e.qZA(),e._uU(65," type."),e.qZA(),e.TgZ(66,"pre")(67,"code",11),e._uU(68,'\ntype User @key(fields: "id") {\n  id: ID!\n  name: String!\n}\n\nextend type Query {\n  getUser(id: ID!): User\n}\n'),e.qZA()(),e.TgZ(69,"p"),e._uU(70,"Resolver provides one additional method named "),e.TgZ(71,"code"),e._uU(72,"resolveReference()"),e.qZA(),e._uU(73,". This method is triggered by the Apollo Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later. Please note that the method must be annotated with the "),e.TgZ(74,"code"),e._uU(75,"@ResolveReference()"),e.qZA(),e._uU(76," decorator."),e.qZA(),e.TgZ(77,"pre")(78,"code",12),e._uU(79,"\nimport { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';\nimport { UsersService } from './users.service';\n\n@Resolver('User')\nexport class UsersResolver {\n  constructor(private usersService: UsersService) {}\n\n  @Query()\n  getUser(@Args('id') id: string) {\n    return this.usersService.findById(id);\n  }\n\n  @ResolveReference()\n  resolveReference(reference: { __typename: string; id: string }) {\n    return this.usersService.findById(reference.id);\n  }\n}\n"),e.qZA()(),e.TgZ(80,"p"),e._uU(81,"Finally, we hook everything up by registering the "),e.TgZ(82,"code"),e._uU(83,"GraphQLModule"),e.qZA(),e._uU(84," passing the "),e.TgZ(85,"code"),e._uU(86,"ApolloFederationDriver"),e.qZA(),e._uU(87," driver in the configuration object:"),e.qZA(),e.TgZ(88,"pre")(89,"code",12),e._uU(90,"\nimport {\n  ApolloFederationDriver,\n  ApolloFederationDriverConfig,\n} from '@nestjs/apollo';\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\nimport { UsersResolver } from './users.resolver';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<ApolloFederationDriverConfig>({\n      driver: ApolloFederationDriver,\n      typePaths: ['**/*.graphql'],\n    }),\n  ],\n  providers: [UsersResolver],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(91,"h4",13)(92,"span"),e._uU(93,"Code first"),e.qZA()(),e.TgZ(94,"p"),e._uU(95,"Start by adding some extra decorators to the "),e.TgZ(96,"code"),e._uU(97,"User"),e.qZA(),e._uU(98," entity."),e.qZA(),e.TgZ(99,"pre")(100,"code",14),e._uU(101,"\nimport { Directive, Field, ID, ObjectType } from '@nestjs/graphql';\n\n@ObjectType()\n@Directive('@key(fields: \"id\")')\nexport class User {\n  @Field((type) => ID)\n  id: number;\n\n  @Field()\n  name: string;\n}\n"),e.qZA()(),e.TgZ(102,"p"),e._uU(103,"Resolver provides one additional method named "),e.TgZ(104,"code"),e._uU(105,"resolveReference()"),e.qZA(),e._uU(106,". This method is triggered by the Apollo Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later. Please note that the method must be annotated with the "),e.TgZ(107,"code"),e._uU(108,"@ResolveReference()"),e.qZA(),e._uU(109," decorator."),e.qZA(),e.TgZ(110,"pre")(111,"code",14),e._uU(112,"\nimport { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';\nimport { User } from './user.entity';\nimport { UsersService } from './users.service';\n\n@Resolver((of) => User)\nexport class UsersResolver {\n  constructor(private usersService: UsersService) {}\n\n  @Query((returns) => User)\n  getUser(@Args('id') id: number): User {\n    return this.usersService.findById(id);\n  }\n\n  @ResolveReference()\n  resolveReference(reference: { __typename: string; id: number }): User {\n    return this.usersService.findById(reference.id);\n  }\n}\n"),e.qZA()(),e.TgZ(113,"p"),e._uU(114,"Finally, we hook everything up by registering the "),e.TgZ(115,"code"),e._uU(116,"GraphQLModule"),e.qZA(),e._uU(117," passing the "),e.TgZ(118,"code"),e._uU(119,"ApolloFederationDriver"),e.qZA(),e._uU(120," driver in the configuration object:"),e.qZA(),e.TgZ(121,"pre")(122,"code",12),e._uU(123,"\nimport {\n  ApolloFederationDriver,\n  ApolloFederationDriverConfig,\n} from '@nestjs/apollo';\nimport { Module } from '@nestjs/common';\nimport { UsersResolver } from './users.resolver';\nimport { UsersService } from './users.service'; // Not included in this example\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<ApolloFederationDriverConfig>({\n      driver: ApolloFederationDriver,\n      autoSchemaFile: true,\n    }),\n  ],\n  providers: [UsersResolver, UsersService],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(124,"p"),e._uU(125,"A working example is available "),e.TgZ(126,"a",15),e._uU(127,"here"),e.qZA(),e._uU(128," in code first mode and "),e.TgZ(129,"a",16),e._uU(130,"here"),e.qZA(),e._uU(131," in schema first mode."),e.qZA(),e.TgZ(132,"h4",17)(133,"span"),e._uU(134,"Federated example: Posts"),e.qZA()(),e.TgZ(135,"p"),e._uU(136,"Post service is supposed to serve aggregated posts through the "),e.TgZ(137,"code"),e._uU(138,"getPosts"),e.qZA(),e._uU(139," query, but also extend our "),e.TgZ(140,"code"),e._uU(141,"User"),e.qZA(),e._uU(142," type with the "),e.TgZ(143,"code"),e._uU(144,"user.posts"),e.qZA(),e._uU(145," field."),e.qZA(),e.TgZ(146,"h4",18)(147,"span"),e._uU(148,"Schema first"),e.qZA()(),e.TgZ(149,"p"),e._uU(150,'"Posts service" references the '),e.TgZ(151,"code"),e._uU(152,"User"),e.qZA(),e._uU(153," type in its schema by marking it with the "),e.TgZ(154,"code"),e._uU(155,"extend"),e.qZA(),e._uU(156," keyword. It also declares one additional property on the "),e.TgZ(157,"code"),e._uU(158,"User"),e.qZA(),e._uU(159," type ("),e.TgZ(160,"code"),e._uU(161,"posts"),e.qZA(),e._uU(162,"). Note the "),e.TgZ(163,"code"),e._uU(164,"@key"),e.qZA(),e._uU(165," directive used for matching instances of User, and the "),e.TgZ(166,"code"),e._uU(167,"@external"),e.qZA(),e._uU(168," directive indicating that the "),e.TgZ(169,"code"),e._uU(170,"id"),e.qZA(),e._uU(171," field is managed elsewhere."),e.qZA(),e.TgZ(172,"pre")(173,"code",11),e._uU(174,'\ntype Post @key(fields: "id") {\n  id: ID!\n  title: String!\n  body: String!\n  user: User\n}\n\nextend type User @key(fields: "id") {\n  id: ID! @external\n  posts: [Post]\n}\n\nextend type Query {\n  getPosts: [Post]\n}\n'),e.qZA()(),e.TgZ(175,"p"),e._uU(176,"In the following example, the "),e.TgZ(177,"code"),e._uU(178,"PostsResolver"),e.qZA(),e._uU(179," provides the "),e.TgZ(180,"code"),e._uU(181,"getUser()"),e.qZA(),e._uU(182," method that returns a reference containing "),e.TgZ(183,"code"),e._uU(184,"__typename"),e.qZA(),e._uU(185," and some additional properties your application may need to resolve the reference, in this case "),e.TgZ(186,"code"),e._uU(187,"id"),e.qZA(),e._uU(188,". "),e.TgZ(189,"code"),e._uU(190,"__typename"),e.qZA(),e._uU(191,' is used by the GraphQL Gateway to pinpoint the microservice responsible for the User type and retrieve the corresponding instance. The "Users service" described above will be requested upon execution of the '),e.TgZ(192,"code"),e._uU(193,"resolveReference()"),e.qZA(),e._uU(194," method."),e.qZA(),e.TgZ(195,"pre")(196,"code",12),e._uU(197,"\nimport { Query, Resolver, Parent, ResolveField } from '@nestjs/graphql';\nimport { PostsService } from './posts.service';\nimport { Post } from './posts.interfaces';\n\n@Resolver('Post')\nexport class PostsResolver {\n  constructor(private postsService: PostsService) {}\n\n  @Query('getPosts')\n  getPosts() {\n    return this.postsService.findAll();\n  }\n\n  @ResolveField('user')\n  getUser(@Parent() post: Post) {\n    return { __typename: 'User', id: post.userId };\n  }\n}\n"),e.qZA()(),e.TgZ(198,"p"),e._uU(199,"Lastly, we must register the "),e.TgZ(200,"code"),e._uU(201,"GraphQLModule"),e.qZA(),e._uU(202,', similarly to what we did in the "Users service" section.'),e.qZA(),e.TgZ(203,"pre")(204,"code",12),e._uU(205,"\nimport {\n  ApolloFederationDriver,\n  ApolloFederationDriverConfig,\n} from '@nestjs/apollo';\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\nimport { PostsResolver } from './posts.resolver';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<ApolloFederationDriverConfig>({\n      driver: ApolloFederationDriver,\n      typePaths: ['**/*.graphql'],\n    }),\n  ],\n  providers: [PostsResolvers],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(206,"h4",19)(207,"span"),e._uU(208,"Code first"),e.qZA()(),e.TgZ(209,"p"),e._uU(210,"First, we will have to declare a class representing the "),e.TgZ(211,"code"),e._uU(212,"User"),e.qZA(),e._uU(213," entity. Although the entity itself lives in another service, we will be using it (extending its definition) here. Note the "),e.TgZ(214,"code"),e._uU(215,"@extends"),e.qZA(),e._uU(216," and "),e.TgZ(217,"code"),e._uU(218,"@external"),e.qZA(),e._uU(219," directives."),e.qZA(),e.TgZ(220,"pre")(221,"code",14),e._uU(222,"\nimport { Directive, ObjectType, Field, ID } from '@nestjs/graphql';\nimport { Post } from './post.entity';\n\n@ObjectType()\n@Directive('@extends')\n@Directive('@key(fields: \"id\")')\nexport class User {\n  @Field((type) => ID)\n  @Directive('@external')\n  id: number;\n\n  @Field((type) => [Post])\n  posts?: Post[];\n}\n"),e.qZA()(),e.TgZ(223,"p"),e._uU(224,"Now let's create the corresponding resolver for our extension on the "),e.TgZ(225,"code"),e._uU(226,"User"),e.qZA(),e._uU(227," entity, as follows:"),e.qZA(),e.TgZ(228,"pre")(229,"code",14),e._uU(230,"\nimport { Parent, ResolveField, Resolver } from '@nestjs/graphql';\nimport { PostsService } from './posts.service';\nimport { Post } from './post.entity';\nimport { User } from './user.entity';\n\n@Resolver((of) => User)\nexport class UsersResolver {\n  constructor(private readonly postsService: PostsService) {}\n\n  @ResolveField((of) => [Post])\n  public posts(@Parent() user: User): Post[] {\n    return this.postsService.forAuthor(user.id);\n  }\n}\n"),e.qZA()(),e.TgZ(231,"p"),e._uU(232,"We also have to define the "),e.TgZ(233,"code"),e._uU(234,"Post"),e.qZA(),e._uU(235," entity class:"),e.qZA(),e.TgZ(236,"pre")(237,"code",14),e._uU(238,"\nimport { Directive, Field, ID, Int, ObjectType } from '@nestjs/graphql';\nimport { User } from './user.entity';\n\n@ObjectType()\n@Directive('@key(fields: \"id\")')\nexport class Post {\n  @Field((type) => ID)\n  id: number;\n\n  @Field()\n  title: string;\n\n  @Field((type) => Int)\n  authorId: number;\n\n  @Field((type) => User)\n  user?: User;\n}\n"),e.qZA()(),e.TgZ(239,"p"),e._uU(240,"And its resolver:"),e.qZA(),e.TgZ(241,"pre")(242,"code",14),e._uU(243,"\nimport { Query, Args, ResolveField, Resolver, Parent } from '@nestjs/graphql';\nimport { PostsService } from './posts.service';\nimport { Post } from './post.entity';\nimport { User } from './user.entity';\n\n@Resolver((of) => Post)\nexport class PostsResolver {\n  constructor(private readonly postsService: PostsService) {}\n\n  @Query((returns) => Post)\n  findPost(@Args('id') id: number): Post {\n    return this.postsService.findOne(id);\n  }\n\n  @Query((returns) => [Post])\n  getPosts(): Post[] {\n    return this.postsService.all();\n  }\n\n  @ResolveField((of) => User)\n  user(@Parent() post: Post): any {\n    return { __typename: 'User', id: post.authorId };\n  }\n}\n"),e.qZA()(),e.TgZ(244,"p"),e._uU(245,"And finally, tie it together in a module. Note the schema build options, where we specify that "),e.TgZ(246,"code"),e._uU(247,"User"),e.qZA(),e._uU(248," is an orphaned (external) type."),e.qZA(),e.TgZ(249,"pre")(250,"code",14),e._uU(251,"\nimport {\n  ApolloFederationDriver,\n  ApolloFederationDriverConfig,\n} from '@nestjs/apollo';\nimport { Module } from '@nestjs/common';\nimport { User } from './user.entity';\nimport { PostsResolvers } from './posts.resolvers';\nimport { UsersResolvers } from './users.resolvers';\nimport { PostsService } from './posts.service'; // Not included in example\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<ApolloFederationDriverConfig>({\n      driver: ApolloFederationDriver,\n      autoSchemaFile: true,\n      buildSchemaOptions: {\n        orphanedTypes: [User],\n      },\n    }),\n  ],\n  providers: [PostsResolver, UsersResolver, PostsService],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(252,"p"),e._uU(253,"A working example is available "),e.TgZ(254,"a",20),e._uU(255,"here"),e.qZA(),e._uU(256," for the code first mode and "),e.TgZ(257,"a",21),e._uU(258,"here"),e.qZA(),e._uU(259," for the schema first mode."),e.qZA(),e.TgZ(260,"h4",22)(261,"span"),e._uU(262,"Federated example: Gateway"),e.qZA()(),e.TgZ(263,"p"),e._uU(264,"Start by installing the required dependency:"),e.qZA(),e.TgZ(265,"pre")(266,"code",9),e._uU(267,"\n$ npm install --save @apollo/gateway\n"),e.qZA()(),e.TgZ(268,"p"),e._uU(269,"The gateway requires a list of endpoints to be specified and it will auto-discover the corresponding schemas. Therefore the implementation of the gateway servce will remain the same for both code and schema first approaches."),e.qZA(),e.TgZ(270,"pre")(271,"code",12),e._uU(272,"\nimport { IntrospectAndCompose } from '@apollo/gateway';\nimport { ApolloGatewayDriver, ApolloGatewayDriverConfig } from '@nestjs/apollo';\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<ApolloGatewayDriverConfig>({\n      driver: ApolloGatewayDriver,\n      server: {\n        // ... Apollo server options\n        cors: true,\n      },\n      gateway: {\n        supergraphSdl: new IntrospectAndCompose({\n          subgraphs: [\n            { name: 'users', url: 'http://user-service/graphql' },\n            { name: 'posts', url: 'http://post-service/graphql' },\n          ],\n        }),\n      },\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(273,"p"),e._uU(274,"A working example is available "),e.TgZ(275,"a",23),e._uU(276,"here"),e.qZA(),e._uU(277," for the code first mode and "),e.TgZ(278,"a",24),e._uU(279,"here"),e.qZA(),e._uU(280," for the schema first mode."),e.qZA(),e.TgZ(281,"h4",25)(282,"span"),e._uU(283,"Federation with Mercurius"),e.qZA()(),e.TgZ(284,"p"),e._uU(285,"Start by installing the required dependencies:"),e.qZA(),e.TgZ(286,"pre")(287,"code",9),e._uU(288,"\n$ npm install --save @apollo/subgraph @nestjs/mercurius\n"),e.qZA()(),e.TgZ(289,"blockquote",26)(290,"strong"),e._uU(291,"Note"),e.qZA(),e._uU(292," The "),e.TgZ(293,"code"),e._uU(294,"@apollo/subgraph"),e.qZA(),e._uU(295," package is required to build a subgraph schema ("),e.TgZ(296,"code"),e._uU(297,"buildSubgraphSchema"),e.qZA(),e._uU(298,", "),e.TgZ(299,"code"),e._uU(300,"printSubgraphSchema"),e.qZA(),e._uU(301," functions).\n"),e.qZA(),e.TgZ(302,"h4",27)(303,"span"),e._uU(304,"Schema first"),e.qZA()(),e.TgZ(305,"p"),e._uU(306,'The "User service" provides a simple schema. Note the '),e.TgZ(307,"code"),e._uU(308,"@key"),e.qZA(),e._uU(309," directive: it instructs the Mercurius query planner that a particular instance of "),e.TgZ(310,"code"),e._uU(311,"User"),e.qZA(),e._uU(312," can be fetched if you specify its "),e.TgZ(313,"code"),e._uU(314,"id"),e.qZA(),e._uU(315,". Also, note that we "),e.TgZ(316,"code"),e._uU(317,"extend"),e.qZA(),e._uU(318," the "),e.TgZ(319,"code"),e._uU(320,"Query"),e.qZA(),e._uU(321," type."),e.qZA(),e.TgZ(322,"pre")(323,"code",11),e._uU(324,'\ntype User @key(fields: "id") {\n  id: ID!\n  name: String!\n}\n\nextend type Query {\n  getUser(id: ID!): User\n}\n'),e.qZA()(),e.TgZ(325,"p"),e._uU(326,"Resolver provides one additional method named "),e.TgZ(327,"code"),e._uU(328,"resolveReference()"),e.qZA(),e._uU(329,". This method is triggered by the Mercurius Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later. Please note that the method must be annotated with the "),e.TgZ(330,"code"),e._uU(331,"@ResolveReference()"),e.qZA(),e._uU(332," decorator."),e.qZA(),e.TgZ(333,"pre")(334,"code",12),e._uU(335,"\nimport { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';\nimport { UsersService } from './users.service';\n\n@Resolver('User')\nexport class UsersResolver {\n  constructor(private usersService: UsersService) {}\n\n  @Query()\n  getUser(@Args('id') id: string) {\n    return this.usersService.findById(id);\n  }\n\n  @ResolveReference()\n  resolveReference(reference: { __typename: string; id: string }) {\n    return this.usersService.findById(reference.id);\n  }\n}\n"),e.qZA()(),e.TgZ(336,"p"),e._uU(337,"Finally, we hook everything up by registering the "),e.TgZ(338,"code"),e._uU(339,"GraphQLModule"),e.qZA(),e._uU(340," passing the "),e.TgZ(341,"code"),e._uU(342,"MercuriusFederationDriver"),e.qZA(),e._uU(343," driver in the configuration object:"),e.qZA(),e.TgZ(344,"pre")(345,"code",12),e._uU(346,"\nimport {\n  MercuriusFederationDriver,\n  MercuriusFederationDriverConfig,\n} from '@nestjs/mercurius';\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\nimport { UsersResolver } from './users.resolver';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<MercuriusFederationDriverConfig>({\n      driver: MercuriusFederationDriver,\n      typePaths: ['**/*.graphql'],\n      federationMetadata: true,\n    }),\n  ],\n  providers: [UsersResolver],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(347,"h4",28)(348,"span"),e._uU(349,"Code first"),e.qZA()(),e.TgZ(350,"p"),e._uU(351,"Start by adding some extra decorators to the "),e.TgZ(352,"code"),e._uU(353,"User"),e.qZA(),e._uU(354," entity."),e.qZA(),e.TgZ(355,"pre")(356,"code",14),e._uU(357,"\nimport { Directive, Field, ID, ObjectType } from '@nestjs/graphql';\n\n@ObjectType()\n@Directive('@key(fields: \"id\")')\nexport class User {\n  @Field((type) => ID)\n  id: number;\n\n  @Field()\n  name: string;\n}\n"),e.qZA()(),e.TgZ(358,"p"),e._uU(359,"Resolver provides one additional method named "),e.TgZ(360,"code"),e._uU(361,"resolveReference()"),e.qZA(),e._uU(362,". This method is triggered by the Mercurius Gateway whenever a related resource requires a User instance. We'll see an example of this in the Posts service later. Please note that the method must be annotated with the "),e.TgZ(363,"code"),e._uU(364,"@ResolveReference()"),e.qZA(),e._uU(365," decorator."),e.qZA(),e.TgZ(366,"pre")(367,"code",14),e._uU(368,"\nimport { Args, Query, Resolver, ResolveReference } from '@nestjs/graphql';\nimport { User } from './user.entity';\nimport { UsersService } from './users.service';\n\n@Resolver((of) => User)\nexport class UsersResolver {\n  constructor(private usersService: UsersService) {}\n\n  @Query((returns) => User)\n  getUser(@Args('id') id: number): User {\n    return this.usersService.findById(id);\n  }\n\n  @ResolveReference()\n  resolveReference(reference: { __typename: string; id: number }): User {\n    return this.usersService.findById(reference.id);\n  }\n}\n"),e.qZA()(),e.TgZ(369,"p"),e._uU(370,"Finally, we hook everything up by registering the "),e.TgZ(371,"code"),e._uU(372,"GraphQLModule"),e.qZA(),e._uU(373," passing the "),e.TgZ(374,"code"),e._uU(375,"MercuriusFederationDriver"),e.qZA(),e._uU(376," driver in the configuration object:"),e.qZA(),e.TgZ(377,"pre")(378,"code",12),e._uU(379,"\nimport {\n  MercuriusFederationDriver,\n  MercuriusFederationDriverConfig,\n} from '@nestjs/mercurius';\nimport { Module } from '@nestjs/common';\nimport { UsersResolver } from './users.resolver';\nimport { UsersService } from './users.service'; // Not included in this example\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<MercuriusFederationDriverConfig>({\n      driver: MercuriusFederationDriver,\n      autoSchemaFile: true,\n      federationMetadata: true,\n    }),\n  ],\n  providers: [UsersResolver, UsersService],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(380,"h4",29)(381,"span"),e._uU(382,"Federated example: Posts"),e.qZA()(),e.TgZ(383,"p"),e._uU(384,"Post service is supposed to serve aggregated posts through the "),e.TgZ(385,"code"),e._uU(386,"getPosts"),e.qZA(),e._uU(387," query, but also extend our "),e.TgZ(388,"code"),e._uU(389,"User"),e.qZA(),e._uU(390," type with the "),e.TgZ(391,"code"),e._uU(392,"user.posts"),e.qZA(),e._uU(393," field."),e.qZA(),e.TgZ(394,"h4",30)(395,"span"),e._uU(396,"Schema first"),e.qZA()(),e.TgZ(397,"p"),e._uU(398,'"Posts service" references the '),e.TgZ(399,"code"),e._uU(400,"User"),e.qZA(),e._uU(401," type in its schema by marking it with the "),e.TgZ(402,"code"),e._uU(403,"extend"),e.qZA(),e._uU(404," keyword. It also declares one additional property on the "),e.TgZ(405,"code"),e._uU(406,"User"),e.qZA(),e._uU(407," type ("),e.TgZ(408,"code"),e._uU(409,"posts"),e.qZA(),e._uU(410,"). Note the "),e.TgZ(411,"code"),e._uU(412,"@key"),e.qZA(),e._uU(413," directive used for matching instances of User, and the "),e.TgZ(414,"code"),e._uU(415,"@external"),e.qZA(),e._uU(416," directive indicating that the "),e.TgZ(417,"code"),e._uU(418,"id"),e.qZA(),e._uU(419," field is managed elsewhere."),e.qZA(),e.TgZ(420,"pre")(421,"code",11),e._uU(422,'\ntype Post @key(fields: "id") {\n  id: ID!\n  title: String!\n  body: String!\n  user: User\n}\n\nextend type User @key(fields: "id") {\n  id: ID! @external\n  posts: [Post]\n}\n\nextend type Query {\n  getPosts: [Post]\n}\n'),e.qZA()(),e.TgZ(423,"p"),e._uU(424,"In the following example, the "),e.TgZ(425,"code"),e._uU(426,"PostsResolver"),e.qZA(),e._uU(427," provides the "),e.TgZ(428,"code"),e._uU(429,"getUser()"),e.qZA(),e._uU(430," method that returns a reference containing "),e.TgZ(431,"code"),e._uU(432,"__typename"),e.qZA(),e._uU(433," and some additional properties your application may need to resolve the reference, in this case "),e.TgZ(434,"code"),e._uU(435,"id"),e.qZA(),e._uU(436,". "),e.TgZ(437,"code"),e._uU(438,"__typename"),e.qZA(),e._uU(439,' is used by the GraphQL Gateway to pinpoint the microservice responsible for the User type and retrieve the corresponding instance. The "Users service" described above will be requested upon execution of the '),e.TgZ(440,"code"),e._uU(441,"resolveReference()"),e.qZA(),e._uU(442," method."),e.qZA(),e.TgZ(443,"pre")(444,"code",12),e._uU(445,"\nimport { Query, Resolver, Parent, ResolveField } from '@nestjs/graphql';\nimport { PostsService } from './posts.service';\nimport { Post } from './posts.interfaces';\n\n@Resolver('Post')\nexport class PostsResolver {\n  constructor(private postsService: PostsService) {}\n\n  @Query('getPosts')\n  getPosts() {\n    return this.postsService.findAll();\n  }\n\n  @ResolveField('user')\n  getUser(@Parent() post: Post) {\n    return { __typename: 'User', id: post.userId };\n  }\n}\n"),e.qZA()(),e.TgZ(446,"p"),e._uU(447,"Lastly, we must register the "),e.TgZ(448,"code"),e._uU(449,"GraphQLModule"),e.qZA(),e._uU(450,', similarly to what we did in the "Users service" section.'),e.qZA(),e.TgZ(451,"pre")(452,"code",12),e._uU(453,"\nimport {\n  MercuriusFederationDriver,\n  MercuriusFederationDriverConfig,\n} from '@nestjs/mercurius';\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\nimport { PostsResolver } from './posts.resolver';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<MercuriusFederationDriverConfig>({\n      driver: MercuriusFederationDriver,\n      federationMetadata: true,\n      typePaths: ['**/*.graphql'],\n    }),\n  ],\n  providers: [PostsResolvers],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(454,"h4",31)(455,"span"),e._uU(456,"Code first"),e.qZA()(),e.TgZ(457,"p"),e._uU(458,"First, we will have to declare a class representing the "),e.TgZ(459,"code"),e._uU(460,"User"),e.qZA(),e._uU(461," entity. Although the entity itself lives in another service, we will be using it (extending its definition) here. Note the "),e.TgZ(462,"code"),e._uU(463,"@extends"),e.qZA(),e._uU(464," and "),e.TgZ(465,"code"),e._uU(466,"@external"),e.qZA(),e._uU(467," directives."),e.qZA(),e.TgZ(468,"pre")(469,"code",14),e._uU(470,"\nimport { Directive, ObjectType, Field, ID } from '@nestjs/graphql';\nimport { Post } from './post.entity';\n\n@ObjectType()\n@Directive('@extends')\n@Directive('@key(fields: \"id\")')\nexport class User {\n  @Field((type) => ID)\n  @Directive('@external')\n  id: number;\n\n  @Field((type) => [Post])\n  posts?: Post[];\n}\n"),e.qZA()(),e.TgZ(471,"p"),e._uU(472,"Now let's create the corresponding resolver for our extension on the "),e.TgZ(473,"code"),e._uU(474,"User"),e.qZA(),e._uU(475," entity, as follows:"),e.qZA(),e.TgZ(476,"pre")(477,"code",14),e._uU(478,"\nimport { Parent, ResolveField, Resolver } from '@nestjs/graphql';\nimport { PostsService } from './posts.service';\nimport { Post } from './post.entity';\nimport { User } from './user.entity';\n\n@Resolver((of) => User)\nexport class UsersResolver {\n  constructor(private readonly postsService: PostsService) {}\n\n  @ResolveField((of) => [Post])\n  public posts(@Parent() user: User): Post[] {\n    return this.postsService.forAuthor(user.id);\n  }\n}\n"),e.qZA()(),e.TgZ(479,"p"),e._uU(480,"We also have to define the "),e.TgZ(481,"code"),e._uU(482,"Post"),e.qZA(),e._uU(483," entity class:"),e.qZA(),e.TgZ(484,"pre")(485,"code",14),e._uU(486,"\nimport { Directive, Field, ID, Int, ObjectType } from '@nestjs/graphql';\nimport { User } from './user.entity';\n\n@ObjectType()\n@Directive('@key(fields: \"id\")')\nexport class Post {\n  @Field((type) => ID)\n  id: number;\n\n  @Field()\n  title: string;\n\n  @Field((type) => Int)\n  authorId: number;\n\n  @Field((type) => User)\n  user?: User;\n}\n"),e.qZA()(),e.TgZ(487,"p"),e._uU(488,"And its resolver:"),e.qZA(),e.TgZ(489,"pre")(490,"code",14),e._uU(491,"\nimport { Query, Args, ResolveField, Resolver, Parent } from '@nestjs/graphql';\nimport { PostsService } from './posts.service';\nimport { Post } from './post.entity';\nimport { User } from './user.entity';\n\n@Resolver((of) => Post)\nexport class PostsResolver {\n  constructor(private readonly postsService: PostsService) {}\n\n  @Query((returns) => Post)\n  findPost(@Args('id') id: number): Post {\n    return this.postsService.findOne(id);\n  }\n\n  @Query((returns) => [Post])\n  getPosts(): Post[] {\n    return this.postsService.all();\n  }\n\n  @ResolveField((of) => User)\n  user(@Parent() post: Post): any {\n    return { __typename: 'User', id: post.authorId };\n  }\n}\n"),e.qZA()(),e.TgZ(492,"p"),e._uU(493,"And finally, tie it together in a module. Note the schema build options, where we specify that "),e.TgZ(494,"code"),e._uU(495,"User"),e.qZA(),e._uU(496," is an orphaned (external) type."),e.qZA(),e.TgZ(497,"pre")(498,"code",14),e._uU(499,"\nimport {\n  MercuriusFederationDriver,\n  MercuriusFederationDriverConfig,\n} from '@nestjs/mercurius';\nimport { Module } from '@nestjs/common';\nimport { User } from './user.entity';\nimport { PostsResolvers } from './posts.resolvers';\nimport { UsersResolvers } from './users.resolvers';\nimport { PostsService } from './posts.service'; // Not included in example\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<MercuriusFederationDriverConfig>({\n      driver: MercuriusFederationDriver,\n      autoSchemaFile: true,\n      federationMetadata: true,\n      buildSchemaOptions: {\n        orphanedTypes: [User],\n      },\n    }),\n  ],\n  providers: [PostsResolver, UsersResolver, PostsService],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(500,"h4",32)(501,"span"),e._uU(502,"Federated example: Gateway"),e.qZA()(),e.TgZ(503,"p"),e._uU(504,"The gateway requires a list of endpoints to be specified and it will auto-discover the corresponding schemas. Therefore the implementation of the gateway servce will remain the same for both code and schema first approaches."),e.qZA(),e.TgZ(505,"pre")(506,"code",12),e._uU(507,"\nimport {\n  MercuriusGatewayDriver,\n  MercuriusGatewayDriverConfig,\n} from '@nestjs/mercurius';\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<MercuriusGatewayDriverConfig>({\n      driver: MercuriusGatewayDriver,\n      gateway: {\n        services: [\n          { name: 'users', url: 'http://user-service/graphql' },\n          { name: 'posts', url: 'http://post-service/graphql' },\n        ],\n      },\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()()())},dependencies:[a.U],encapsulation:2,changeDetection:0}),t})(),T=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-field-middleware"]],features:[e.qOj],decls:129,vars:2,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/field-middleware.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","field-middleware"],[1,"warning"],["appAnchor","","id","getting-started"],[1,"language-typescript"],[1,"info"],["routerLink","/graphql/extensions"],["href","/graphql/extensions#using-custom-metadata"],["href","/graphql/other-features#execute-enhancers-at-the-field-resolver-level"],["appAnchor","","id","global-field-middleware"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Field middleware"),e.qZA(),e.TgZ(7,"blockquote",6)(8,"strong"),e._uU(9,"Warning"),e.qZA(),e._uU(10," This chapter applies only to the code first approach.\n"),e.qZA(),e.TgZ(11,"p"),e._uU(12,"Field Middleware lets you run arbitrary code "),e.TgZ(13,"strong"),e._uU(14,"before or after"),e.qZA(),e._uU(15," a field is resolved. A field middleware can be used to convert the result of a field, validate the arguments of a field, or even check field-level roles (for example, required to access a target field for which a middleware function is executed)."),e.qZA(),e.TgZ(16,"p"),e._uU(17,"You can connect multiple middleware functions to a field. In this case, they will be called sequentially along the chain where the previous middleware decides to call the next one. The order of the middleware functions in the "),e.TgZ(18,"code"),e._uU(19,"middleware"),e.qZA(),e._uU(20,' array is important. The first resolver is the "most-outer" layer, so it gets executed first and last (similarly to the '),e.TgZ(21,"code"),e._uU(22,"graphql-middleware"),e.qZA(),e._uU(23,' package). The second resolver is the "second-outer" layer, so it gets executed second and second to last.'),e.qZA(),e.TgZ(24,"h4",7)(25,"span"),e._uU(26,"Getting started"),e.qZA()(),e.TgZ(27,"p"),e._uU(28,"Let's start off by creating a simple middleware that will log a field value before it's sent back to the client:"),e.qZA(),e.TgZ(29,"pre")(30,"code",8),e._uU(31,"\nimport { FieldMiddleware, MiddlewareContext, NextFn } from '@nestjs/graphql';\n\nconst loggerMiddleware: FieldMiddleware = async (\n  ctx: MiddlewareContext,\n  next: NextFn,\n) => {\n  const value = await next();\n  console.log(value);\n  return value;\n};\n"),e.qZA()(),e.TgZ(32,"blockquote",9)(33,"strong"),e._uU(34,"Hint"),e.qZA(),e._uU(35," The "),e.TgZ(36,"code"),e._uU(37,"MiddlewareContext"),e.qZA(),e._uU(38," is an object that consist of the same arguments that are normally received by the GraphQL resolver function ("),e.TgZ(39,"code"),e._uU(40),e.qZA(),e._uU(41,"), while "),e.TgZ(42,"code"),e._uU(43,"NextFn"),e.qZA(),e._uU(44," is a function that let you execute the next middleware in the stack (bound to this field) or the actual field resolver.\n"),e.qZA(),e.TgZ(45,"blockquote",6)(46,"strong"),e._uU(47,"Warning"),e.qZA(),e._uU(48," Field middleware functions cannot inject dependencies nor access Nest's DI container as they are designed to be very lightweight and shouldn't perform any potentially time-consuming operations (like retrieving data from the database). If you need to call external services/query data from the data source, you should do it in a guard/interceptor bounded to a root query/mutation handler and assign it to "),e.TgZ(49,"code"),e._uU(50,"context"),e.qZA(),e._uU(51," object which you can access from within the field middleware (specifically, from the "),e.TgZ(52,"code"),e._uU(53,"MiddlewareContext"),e.qZA(),e._uU(54," object).\n"),e.qZA(),e.TgZ(55,"p"),e._uU(56,"Note that field middleware must match the "),e.TgZ(57,"code"),e._uU(58,"FieldMiddleware"),e.qZA(),e._uU(59," interface. In the example above, we first run the "),e.TgZ(60,"code"),e._uU(61,"next()"),e.qZA(),e._uU(62," function (which executes the actual field resolver and returns a field value) and then, we log this value to our terminal. Also, the value returned from the middleware function completely overrides the previous value and since we don't want to perform any changes, we simply return the original value."),e.qZA(),e.TgZ(63,"p"),e._uU(64,"With this in place, we can register our middleware directly in the "),e.TgZ(65,"code"),e._uU(66,"@Field()"),e.qZA(),e._uU(67," decorator, as follows:"),e.qZA(),e.TgZ(68,"pre")(69,"code",8),e._uU(70,"\n@ObjectType()\nexport class Recipe {\n  @Field({ middleware: [loggerMiddleware] })\n  title: string;\n}\n"),e.qZA()(),e.TgZ(71,"p"),e._uU(72,"Now whenever we request the "),e.TgZ(73,"code"),e._uU(74,"title"),e.qZA(),e._uU(75," field of "),e.TgZ(76,"code"),e._uU(77,"Recipe"),e.qZA(),e._uU(78," object type, the original field's value will be logged to the console."),e.qZA(),e.TgZ(79,"blockquote",9)(80,"strong"),e._uU(81,"Hint"),e.qZA(),e._uU(82," To learn how you can implement a field-level permissions system with the use of "),e.TgZ(83,"a",10),e._uU(84,"extensions"),e.qZA(),e._uU(85," feature, check out this "),e.TgZ(86,"a",11),e._uU(87,"section"),e.qZA(),e._uU(88,".\n"),e.qZA(),e.TgZ(89,"p"),e._uU(90,"Also, as mentioned above, we can control the field's value from within the middleware function. For demonstration purposes, let's capitalise a recipe's title (if present):"),e.qZA(),e.TgZ(91,"pre")(92,"code",8),e._uU(93,"\nconst value = await next();\nreturn value?.toUpperCase();\n"),e.qZA()(),e.TgZ(94,"p"),e._uU(95,"In this case, every title will be automatically uppercased, when requested."),e.qZA(),e.TgZ(96,"p"),e._uU(97,"Likewise, you can bind a field middleware to a custom field resolver (a method annotated with the "),e.TgZ(98,"code"),e._uU(99,"@ResolveField()"),e.qZA(),e._uU(100," decorator), as follows:"),e.qZA(),e.TgZ(101,"pre")(102,"code",8),e._uU(103,"\n@ResolveField(() => String, { middleware: [loggerMiddleware] })\ntitle() {\n  return 'Placeholder';\n}\n"),e.qZA()(),e.TgZ(104,"blockquote",6)(105,"strong"),e._uU(106,"Warning"),e.qZA(),e._uU(107," In case enhancers are enabled at the field resolver level ("),e.TgZ(108,"a",12),e._uU(109,"read more"),e.qZA(),e._uU(110,"), field middleware functions will run before any interceptors, guards, etc., "),e.TgZ(111,"strong"),e._uU(112,"bounded to the method"),e.qZA(),e._uU(113," (but after the root-level enhancers registered for query or mutation handlers).\n"),e.qZA(),e.TgZ(114,"h4",13)(115,"span"),e._uU(116,"Global field middleware"),e.qZA()(),e.TgZ(117,"p"),e._uU(118,"In addition to binding a middleware directly to a specific field, you can also register one or multiple middleware functions globally. In this case, they will be automatically connected to all fields of your object types."),e.qZA(),e.TgZ(119,"pre")(120,"code",8),e._uU(121,"\nGraphQLModule.forRoot({\n  autoSchemaFile: 'schema.gql',\n  buildSchemaOptions: {\n    fieldMiddleware: [loggerMiddleware],\n  },\n}),\n"),e.qZA()(),e.TgZ(122,"blockquote",9)(123,"strong"),e._uU(124,"Hint"),e.qZA(),e._uU(125," Globally registered field middleware functions will be executed "),e.TgZ(126,"strong"),e._uU(127,"before"),e.qZA(),e._uU(128," locally registered ones (those bound directly to specific fields).\n"),e.qZA()()),2&o&&(e.xp6(40),e.AsE("","{"," source, args, context, info ","}",""))},dependencies:[a.U,u.yS],encapsulation:2,changeDetection:0}),t})(),y=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-guards-interceptors"]],features:[e.qOj],decls:236,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/guards-interceptors.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","other-features"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/schema/directives/"],["routerLink","/guards"],["routerLink","/interceptors"],["appAnchor","","id","overview"],["routerLink","/exception-filters"],["routerLink","/pipes"],["routerLink","/custom-decorators"],[1,"language-typescript"],["appAnchor","","id","execution-context"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/fundamentals/execution-context"],["appAnchor","","id","exception-filters"],[1,"info"],["appAnchor","","id","custom-decorators"],["appAnchor","","id","execute-enhancers-at-the-field-resolver-level"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/graphql/issues/320#issuecomment-511193229"],[1,""],["appAnchor","","id","creating-a-custom-driver"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Other features"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"In the GraphQL world, there is a lot of debate about handling issues like "),e.TgZ(9,"strong"),e._uU(10,"authentication"),e.qZA(),e._uU(11,", or "),e.TgZ(12,"strong"),e._uU(13,"side-effects"),e.qZA(),e._uU(14," of operations. Should we handle things inside the business logic? Should we use a higher-order function to enhance queries and mutations with authorization logic? Or should we use "),e.TgZ(15,"a",6),e._uU(16,"schema directives"),e.qZA(),e._uU(17,"? There is no single one-size-fits-all answer to these questions."),e.qZA(),e.TgZ(18,"p"),e._uU(19,"Nest helps address these issues with its cross-platform features like "),e.TgZ(20,"a",7),e._uU(21,"guards"),e.qZA(),e._uU(22," and "),e.TgZ(23,"a",8),e._uU(24,"interceptors"),e.qZA(),e._uU(25,". The philosophy is to reduce redundancy and provide tooling that helps create well-structured, readable, and consistent applications."),e.qZA(),e.TgZ(26,"h4",9)(27,"span"),e._uU(28,"Overview"),e.qZA()(),e.TgZ(29,"p"),e._uU(30,"You can use standard "),e.TgZ(31,"a",7),e._uU(32,"guards"),e.qZA(),e._uU(33,", "),e.TgZ(34,"a",8),e._uU(35,"interceptors"),e.qZA(),e._uU(36,", "),e.TgZ(37,"a",10),e._uU(38,"filters"),e.qZA(),e._uU(39," and "),e.TgZ(40,"a",11),e._uU(41,"pipes"),e.qZA(),e._uU(42," in the same fashion with GraphQL as with any RESTful application. Additionally, you can easily create your own decorators by leveraging the "),e.TgZ(43,"a",12),e._uU(44,"custom decorators"),e.qZA(),e._uU(45," feature. Let's take a look at a sample GraphQL query handler."),e.qZA(),e.TgZ(46,"pre")(47,"code",13),e._uU(48,"\n@Query('author')\n@UseGuards(AuthGuard)\nasync getAuthor(@Args('id', ParseIntPipe) id: number) {\n  return this.authorsService.findOneById(id);\n}\n"),e.qZA()(),e.TgZ(49,"p"),e._uU(50,"As you can see, GraphQL works with both guards and pipes in the same way as HTTP REST handlers. Because of this, you can move your authentication logic to a guard; you can even reuse the same guard class across both a REST and GraphQL API interface. Similarly, interceptors work across both types of applications in the same way:"),e.qZA(),e.TgZ(51,"pre")(52,"code",13),e._uU(53,"\n@Mutation()\n@UseInterceptors(EventsInterceptor)\nasync upvotePost(@Args('postId') postId: number) {\n  return this.postsService.upvoteById({ id: postId });\n}\n"),e.qZA()(),e.TgZ(54,"h4",14)(55,"span"),e._uU(56,"Execution context"),e.qZA()(),e.TgZ(57,"p"),e._uU(58,"Since GraphQL receives a different type of data in the incoming request, the "),e.TgZ(59,"a",15),e._uU(60,"execution context"),e.qZA(),e._uU(61," received by both guards and interceptors is somewhat different with GraphQL vs. REST. GraphQL resolvers have a distinct set of arguments: "),e.TgZ(62,"code"),e._uU(63,"root"),e.qZA(),e._uU(64,", "),e.TgZ(65,"code"),e._uU(66,"args"),e.qZA(),e._uU(67,", "),e.TgZ(68,"code"),e._uU(69,"context"),e.qZA(),e._uU(70,", and "),e.TgZ(71,"code"),e._uU(72,"info"),e.qZA(),e._uU(73,". Thus guards and interceptors must transform the generic "),e.TgZ(74,"code"),e._uU(75,"ExecutionContext"),e.qZA(),e._uU(76," to a "),e.TgZ(77,"code"),e._uU(78,"GqlExecutionContext"),e.qZA(),e._uU(79,". This is straightforward:"),e.qZA(),e.TgZ(80,"pre")(81,"code",13),e._uU(82,"\nimport { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\nimport { GqlExecutionContext } from '@nestjs/graphql';\n\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  canActivate(context: ExecutionContext): boolean {\n    const ctx = GqlExecutionContext.create(context);\n    return true;\n  }\n}\n"),e.qZA()(),e.TgZ(83,"p"),e._uU(84,"The GraphQL context object returned by "),e.TgZ(85,"code"),e._uU(86,"GqlExecutionContext.create()"),e.qZA(),e._uU(87," exposes a "),e.TgZ(88,"strong"),e._uU(89,"get"),e.qZA(),e._uU(90," method for each GraphQL resolver argument (e.g., "),e.TgZ(91,"code"),e._uU(92,"getArgs()"),e.qZA(),e._uU(93,", "),e.TgZ(94,"code"),e._uU(95,"getContext()"),e.qZA(),e._uU(96,", etc). Once transformed, we can easily pick out any GraphQL argument for the current request."),e.qZA(),e.TgZ(97,"h4",16)(98,"span"),e._uU(99,"Exception filters"),e.qZA()(),e.TgZ(100,"p"),e._uU(101,"Nest standard "),e.TgZ(102,"a",10),e._uU(103,"exception filters"),e.qZA(),e._uU(104," are compatible with GraphQL applications as well. As with "),e.TgZ(105,"code"),e._uU(106,"ExecutionContext"),e.qZA(),e._uU(107,", GraphQL apps should transform the "),e.TgZ(108,"code"),e._uU(109,"ArgumentsHost"),e.qZA(),e._uU(110," object to a "),e.TgZ(111,"code"),e._uU(112,"GqlArgumentsHost"),e.qZA(),e._uU(113," object."),e.qZA(),e.TgZ(114,"pre")(115,"code",13),e._uU(116,"\n@Catch(HttpException)\nexport class HttpExceptionFilter implements GqlExceptionFilter {\n  catch(exception: HttpException, host: ArgumentsHost) {\n    const gqlHost = GqlArgumentsHost.create(host);\n    return exception;\n  }\n}\n"),e.qZA()(),e.TgZ(117,"blockquote",17)(118,"strong"),e._uU(119,"Hint"),e.qZA(),e._uU(120," Both "),e.TgZ(121,"code"),e._uU(122,"GqlExceptionFilter"),e.qZA(),e._uU(123," and "),e.TgZ(124,"code"),e._uU(125,"GqlArgumentsHost"),e.qZA(),e._uU(126," are imported from the "),e.TgZ(127,"code"),e._uU(128,"@nestjs/graphql"),e.qZA(),e._uU(129," package.\n"),e.qZA(),e.TgZ(130,"p"),e._uU(131,"Note that unlike the REST case, you don't use the native "),e.TgZ(132,"code"),e._uU(133,"response"),e.qZA(),e._uU(134," object to generate a response."),e.qZA(),e.TgZ(135,"h4",18)(136,"span"),e._uU(137,"Custom decorators"),e.qZA()(),e.TgZ(138,"p"),e._uU(139,"As mentioned, the "),e.TgZ(140,"a",12),e._uU(141,"custom decorators"),e.qZA(),e._uU(142," feature works as expected with GraphQL resolvers."),e.qZA(),e.TgZ(143,"pre")(144,"code",13),e._uU(145,"\nexport const User = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) =>\n    GqlExecutionContext.create(ctx).getContext().user,\n);\n"),e.qZA()(),e.TgZ(146,"p"),e._uU(147,"Use the "),e.TgZ(148,"code"),e._uU(149,"@User()"),e.qZA(),e._uU(150," custom decorator as follows:"),e.qZA(),e.TgZ(151,"pre")(152,"code",13),e._uU(153,"\n@Mutation()\nasync upvotePost(\n  @User() user: UserEntity,\n  @Args('postId') postId: number,\n) {}\n"),e.qZA()(),e.TgZ(154,"blockquote",17)(155,"strong"),e._uU(156,"Hint"),e.qZA(),e._uU(157," In the above example, we have assumed that the "),e.TgZ(158,"code"),e._uU(159,"user"),e.qZA(),e._uU(160," object is assigned to the context of your GraphQL application.\n"),e.qZA(),e.TgZ(161,"h4",19)(162,"span"),e._uU(163,"Execute enhancers at the field resolver level"),e.qZA()(),e.TgZ(164,"p"),e._uU(165,"In the GraphQL context, Nest does not run "),e.TgZ(166,"strong"),e._uU(167,"enhancers"),e.qZA(),e._uU(168," (the generic name for interceptors, guards and filters) at the field level "),e.TgZ(169,"a",20),e._uU(170,"see this issue"),e.qZA(),e._uU(171,": they only run for the top level "),e.TgZ(172,"code"),e._uU(173,"@Query()"),e.qZA(),e._uU(174,"/"),e.TgZ(175,"code"),e._uU(176,"@Mutation()"),e.qZA(),e._uU(177," method. You can tell Nest to execute interceptors, guards or filters for methods annotated with "),e.TgZ(178,"code"),e._uU(179,"@ResolveField()"),e.qZA(),e._uU(180," by setting the "),e.TgZ(181,"code"),e._uU(182,"fieldResolverEnhancers"),e.qZA(),e._uU(183," option in "),e.TgZ(184,"code"),e._uU(185,"GqlModuleOptions"),e.qZA(),e._uU(186,". Pass it a list of "),e.TgZ(187,"code"),e._uU(188,"'interceptors'"),e.qZA(),e._uU(189,", "),e.TgZ(190,"code"),e._uU(191,"'guards'"),e.qZA(),e._uU(192,", and/or "),e.TgZ(193,"code"),e._uU(194,"'filters'"),e.qZA(),e._uU(195," as appropriate:"),e.qZA(),e.TgZ(196,"pre")(197,"code",13),e._uU(198,"\nGraphQLModule.forRoot({\n  fieldResolverEnhancers: ['interceptors']\n}),\n"),e.qZA()(),e.TgZ(199,"blockquote",21)(200,"strong"),e._uU(201,"Warning"),e.qZA(),e._uU(202," Enabling enhancers for field resolvers can cause performance issues when you are returning lots of records and your field resolver is executed thousands of times. For this reason, when you enable "),e.TgZ(203,"code"),e._uU(204,"fieldResolverEnhancers"),e.qZA(),e._uU(205,", we advise you to skip execution of enhancers that are not strictly necessary for your field resolvers. You can do this using the following helper function:\n"),e.qZA(),e.TgZ(206,"pre")(207,"code",13),e._uU(208,"\nexport function isResolvingGraphQLField(context: ExecutionContext): boolean {\n  if (context.getType<GqlContextType>() === 'graphql') {\n    const gqlContext = GqlExecutionContext.create(context);\n    const info = gqlContext.getInfo();\n    const parentType = info.parentType.name;\n    return parentType !== 'Query' && parentType !== 'Mutation';\n  }\n  return false;\n}\n"),e.qZA()(),e.TgZ(209,"h4",22)(210,"span"),e._uU(211,"Creating a custom driver"),e.qZA()(),e.TgZ(212,"p"),e._uU(213,"Nest provides two official drivers out-of-the-box: "),e.TgZ(214,"code"),e._uU(215,"@nestjs/apollo"),e.qZA(),e._uU(216," and "),e.TgZ(217,"code"),e._uU(218,"@nestjs/mercurius"),e.qZA(),e._uU(219,", as well as an API allowing developers to build new "),e.TgZ(220,"strong"),e._uU(221,"custom drivers"),e.qZA(),e._uU(222,". With a custom driver, you can integrate any GraphQL library or extend the existing integration, adding extra features on top."),e.qZA(),e.TgZ(223,"p"),e._uU(224,"For example, to integrate the "),e.TgZ(225,"code"),e._uU(226,"express-graphql"),e.qZA(),e._uU(227," package, you could create the following driver class:"),e.qZA(),e.TgZ(228,"pre")(229,"code",13),e._uU(230,"\nimport { AbstractGraphQLDriver, GqlModuleOptions } from '@nestjs/graphql';\nimport { graphqlHTTP } from 'express-graphql';\n\nclass ExpressGraphQLDriver extends AbstractGraphQLDriver {\n  async start(options: GqlModuleOptions<any>): Promise<void> {\n    options = await this.graphQlFactory.mergeWithSchema(options);\n\n    const { httpAdapter } = this.httpAdapterHost;\n    httpAdapter.use(\n      '/graphql',\n      graphqlHTTP({\n        schema: options.schema,\n        graphiql: true,\n      }),\n    );\n  }\n\n  async stop() {}\n}\n"),e.qZA()(),e.TgZ(231,"p"),e._uU(232,"And then use it as follows:"),e.qZA(),e.TgZ(233,"pre")(234,"code",13),e._uU(235,"\nGraphQLModule.forRoot({\n  driver: ExpressGraphQLDriver,\n});\n"),e.qZA()()())},dependencies:[a.U,u.yS],encapsulation:2,changeDetection:0}),t})(),v=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-interfaces"]],features:[e.qOj],decls:131,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/interfaces.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","interfaces"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/#interfaces"],["appAnchor","","id","code-first"],[1,"language-typescript"],[1,"warning"],[1,"language-graphql"],[1,"info"],["appAnchor","","id","interface-resolvers"],["appAnchor","","id","schema-first"],["routerLink","/graphql/quick-start"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Interfaces"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"Like many type systems, GraphQL supports interfaces. An "),e.TgZ(9,"strong"),e._uU(10,"Interface"),e.qZA(),e._uU(11," is an abstract type that includes a certain set of fields that a type must include to implement the interface (read more "),e.TgZ(12,"a",6),e._uU(13,"here"),e.qZA(),e._uU(14,")."),e.qZA(),e.TgZ(15,"h4",7)(16,"span"),e._uU(17,"Code first"),e.qZA()(),e.TgZ(18,"p"),e._uU(19,"When using the code first approach, you define a GraphQL interface by creating an abstract class annotated with the "),e.TgZ(20,"code"),e._uU(21,"@InterfaceType()"),e.qZA(),e._uU(22," decorator exported from the "),e.TgZ(23,"code"),e._uU(24,"@nestjs/graphql"),e.qZA(),e._uU(25,"."),e.qZA(),e.TgZ(26,"pre")(27,"code",8),e._uU(28,"\nimport { Field, ID, InterfaceType } from '@nestjs/graphql';\n\n@InterfaceType()\nexport abstract class Character {\n  @Field((type) => ID)\n  id: string;\n\n  @Field()\n  name: string;\n}\n"),e.qZA()(),e.TgZ(29,"blockquote",9)(30,"strong"),e._uU(31,"Warning"),e.qZA(),e._uU(32," TypeScript interfaces cannot be used to define GraphQL interfaces.\n"),e.qZA(),e.TgZ(33,"p"),e._uU(34,"This will result in generating the following part of the GraphQL schema in SDL:"),e.qZA(),e.TgZ(35,"pre")(36,"code",10),e._uU(37,"\ninterface Character {\n  id: ID!\n  name: String!\n}\n"),e.qZA()(),e.TgZ(38,"p"),e._uU(39,"Now, to implement the "),e.TgZ(40,"code"),e._uU(41,"Character"),e.qZA(),e._uU(42," interface, use the "),e.TgZ(43,"code"),e._uU(44,"implements"),e.qZA(),e._uU(45," key:"),e.qZA(),e.TgZ(46,"pre")(47,"code",8),e._uU(48,"\n@ObjectType({\n  implements: () => [Character],\n})\nexport class Human implements Character {\n  id: string;\n  name: string;\n}\n"),e.qZA()(),e.TgZ(49,"blockquote",11)(50,"strong"),e._uU(51,"Hint"),e.qZA(),e._uU(52," The "),e.TgZ(53,"code"),e._uU(54,"@ObjectType()"),e.qZA(),e._uU(55," decorator is exported from the "),e.TgZ(56,"code"),e._uU(57,"@nestjs/graphql"),e.qZA(),e._uU(58," package.\n"),e.qZA(),e.TgZ(59,"p"),e._uU(60,"The default "),e.TgZ(61,"code"),e._uU(62,"resolveType()"),e.qZA(),e._uU(63," function generated by the library extracts the type based on the value returned from the resolver method. This means that you must return class instances (you cannot return literal JavaScript objects)."),e.qZA(),e.TgZ(64,"p"),e._uU(65,"To provide a customized "),e.TgZ(66,"code"),e._uU(67,"resolveType()"),e.qZA(),e._uU(68," function, pass the "),e.TgZ(69,"code"),e._uU(70,"resolveType"),e.qZA(),e._uU(71," property to the options object passed into the "),e.TgZ(72,"code"),e._uU(73,"@InterfaceType()"),e.qZA(),e._uU(74," decorator, as follows:"),e.qZA(),e.TgZ(75,"pre")(76,"code",8),e._uU(77,"\n@InterfaceType({\n  resolveType(book) {\n    if (book.colors) {\n      return ColoringBook;\n    }\n    return TextBook;\n  },\n})\nexport abstract class Book {\n  @Field((type) => ID)\n  id: string;\n\n  @Field()\n  title: string;\n}\n"),e.qZA()(),e.TgZ(78,"h4",12)(79,"span"),e._uU(80,"Interface resolvers"),e.qZA()(),e.TgZ(81,"p"),e._uU(82,"So far, using interfaces, you could only share field definitions with your objects. If you also want to share the actual field resolvers implementation, you can create a dedicated interface resolver, as follows:"),e.qZA(),e.TgZ(83,"pre")(84,"code",8),e._uU(85,"\nimport { Resolver, ResolveField, Parent, Info } from '@nestjs/graphql';\n\n@Resolver(type => Character) // Reminder: Character is an interface\nexport class CharacterInterfaceResolver {\n  @ResolveField(() => [Character])\n  friends(\n    @Parent() character, // Resolved object that implements Character\n    @Info() { parentType }, // Type of the object that implements Character\n    @Args('search', { type: () => String }) searchTerm: string,\n  ) {\n    // Get character's friends\n    return [];\n  }\n}\n"),e.qZA()(),e.TgZ(86,"p"),e._uU(87,"Now the "),e.TgZ(88,"code"),e._uU(89,"friends"),e.qZA(),e._uU(90," field resolver is auto-registered for all object types that implement the "),e.TgZ(91,"code"),e._uU(92,"Character"),e.qZA(),e._uU(93," interface."),e.qZA(),e.TgZ(94,"h4",13)(95,"span"),e._uU(96,"Schema first"),e.qZA()(),e.TgZ(97,"p"),e._uU(98,"To define an interface in the schema first approach, simply create a GraphQL interface with SDL."),e.qZA(),e.TgZ(99,"pre")(100,"code",10),e._uU(101,"\ninterface Character {\n  id: ID!\n  name: String!\n}\n"),e.qZA()(),e.TgZ(102,"p"),e._uU(103,"Then, you can use the typings generation feature (as shown in the "),e.TgZ(104,"a",14),e._uU(105,"quick start"),e.qZA(),e._uU(106," chapter) to generate corresponding TypeScript definitions:"),e.qZA(),e.TgZ(107,"pre")(108,"code",8),e._uU(109,"\nexport interface Character {\n  id: string;\n  name: string;\n}\n"),e.qZA()(),e.TgZ(110,"p"),e._uU(111,"Interfaces require an extra "),e.TgZ(112,"code"),e._uU(113,"__resolveType"),e.qZA(),e._uU(114," field in the resolver map to determine which type the interface should resolve to. Let's create a "),e.TgZ(115,"code"),e._uU(116,"CharactersResolver"),e.qZA(),e._uU(117," class and define the "),e.TgZ(118,"code"),e._uU(119,"__resolveType"),e.qZA(),e._uU(120," method:"),e.qZA(),e.TgZ(121,"pre")(122,"code",8),e._uU(123,"\n@Resolver('Character')\nexport class CharactersResolver {\n  @ResolveField()\n  __resolveType(value) {\n    if ('age' in value) {\n      return Person;\n    }\n    return null;\n  }\n}\n"),e.qZA()(),e.TgZ(124,"blockquote",11)(125,"strong"),e._uU(126,"Hint"),e.qZA(),e._uU(127," All decorators are exported from the "),e.TgZ(128,"code"),e._uU(129,"@nestjs/graphql"),e.qZA(),e._uU(130," package.\n"),e.qZA()())},encapsulation:2,changeDetection:0}),t})(),b=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-mapped-types"]],features:[e.qOj],decls:202,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/mapped-types.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","mapped-types"],[1,"warning"],["appAnchor","","id","partial"],[1,"language-typescript"],[1,"info"],["appAnchor","","id","pick"],["appAnchor","","id","omit"],["appAnchor","","id","intersection"],["appAnchor","","id","composition"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Mapped types"),e.qZA(),e.TgZ(7,"blockquote",6)(8,"strong"),e._uU(9,"Warning"),e.qZA(),e._uU(10," This chapter applies only to the code first approach.\n"),e.qZA(),e.TgZ(11,"p"),e._uU(12,"As you build out features like CRUD (Create/Read/Update/Delete) it's often useful to construct variants on a base entity type. Nest provides several utility functions that perform type transformations to make this task more convenient."),e.qZA(),e.TgZ(13,"h4",7)(14,"span"),e._uU(15,"Partial"),e.qZA()(),e.TgZ(16,"p"),e._uU(17,"When building input validation types (also called Data Transfer Objects or DTOs), it's often useful to build "),e.TgZ(18,"strong"),e._uU(19,"create"),e.qZA(),e._uU(20," and "),e.TgZ(21,"strong"),e._uU(22,"update"),e.qZA(),e._uU(23," variations on the same type. For example, the "),e.TgZ(24,"strong"),e._uU(25,"create"),e.qZA(),e._uU(26," variant may require all fields, while the "),e.TgZ(27,"strong"),e._uU(28,"update"),e.qZA(),e._uU(29," variant may make all fields optional."),e.qZA(),e.TgZ(30,"p"),e._uU(31,"Nest provides the "),e.TgZ(32,"code"),e._uU(33,"PartialType()"),e.qZA(),e._uU(34," utility function to make this task easier and minimize boilerplate."),e.qZA(),e.TgZ(35,"p"),e._uU(36,"The "),e.TgZ(37,"code"),e._uU(38,"PartialType()"),e.qZA(),e._uU(39," function returns a type (class) with all the properties of the input type set to optional. For example, suppose we have a "),e.TgZ(40,"strong"),e._uU(41,"create"),e.qZA(),e._uU(42," type as follows:"),e.qZA(),e.TgZ(43,"pre")(44,"code",8),e._uU(45,"\n@InputType()\nclass CreateUserInput {\n  @Field()\n  email: string;\n\n  @Field()\n  password: string;\n\n  @Field()\n  firstName: string;\n}\n"),e.qZA()(),e.TgZ(46,"p"),e._uU(47,"By default, all of these fields are required. To create a type with the same fields, but with each one optional, use "),e.TgZ(48,"code"),e._uU(49,"PartialType()"),e.qZA(),e._uU(50," passing the class reference ("),e.TgZ(51,"code"),e._uU(52,"CreateUserInput"),e.qZA(),e._uU(53,") as an argument:"),e.qZA(),e.TgZ(54,"pre")(55,"code",8),e._uU(56,"\n@InputType()\nexport class UpdateUserInput extends PartialType(CreateUserInput) {}\n"),e.qZA()(),e.TgZ(57,"blockquote",9)(58,"strong"),e._uU(59,"Hint"),e.qZA(),e._uU(60," The "),e.TgZ(61,"code"),e._uU(62,"PartialType()"),e.qZA(),e._uU(63," function is imported from the "),e.TgZ(64,"code"),e._uU(65,"@nestjs/graphql"),e.qZA(),e._uU(66," package.\n"),e.qZA(),e.TgZ(67,"p"),e._uU(68,"The "),e.TgZ(69,"code"),e._uU(70,"PartialType()"),e.qZA(),e._uU(71," function takes an optional second argument that is a reference to a decorator factory. This argument can be used to change the decorator function applied to the resulting (child) class. If not specified, the child class effectively uses the same decorator as the "),e.TgZ(72,"strong"),e._uU(73,"parent"),e.qZA(),e._uU(74," class (the class referenced in the first argument). In the example above, we are extending "),e.TgZ(75,"code"),e._uU(76,"CreateUserInput"),e.qZA(),e._uU(77," which is annotated with the "),e.TgZ(78,"code"),e._uU(79,"@InputType()"),e.qZA(),e._uU(80," decorator. Since we want "),e.TgZ(81,"code"),e._uU(82,"UpdateUserInput"),e.qZA(),e._uU(83," to also be treated as if it were decorated with "),e.TgZ(84,"code"),e._uU(85,"@InputType()"),e.qZA(),e._uU(86,", we didn't need to pass "),e.TgZ(87,"code"),e._uU(88,"InputType"),e.qZA(),e._uU(89," as the second argument. If the parent and child types are different, (e.g., the parent is decorated with "),e.TgZ(90,"code"),e._uU(91,"@ObjectType"),e.qZA(),e._uU(92,"), we would pass "),e.TgZ(93,"code"),e._uU(94,"InputType"),e.qZA(),e._uU(95," as the second argument. For example:"),e.qZA(),e.TgZ(96,"pre")(97,"code",8),e._uU(98,"\n@InputType()\nexport class UpdateUserInput extends PartialType(User, InputType) {}\n"),e.qZA()(),e.TgZ(99,"h4",10)(100,"span"),e._uU(101,"Pick"),e.qZA()(),e.TgZ(102,"p"),e._uU(103,"The "),e.TgZ(104,"code"),e._uU(105,"PickType()"),e.qZA(),e._uU(106," function constructs a new type (class) by picking a set of properties from an input type. For example, suppose we start with a type like:"),e.qZA(),e.TgZ(107,"pre")(108,"code",8),e._uU(109,"\n@InputType()\nclass CreateUserInput {\n  @Field()\n  email: string;\n\n  @Field()\n  password: string;\n\n  @Field()\n  firstName: string;\n}\n"),e.qZA()(),e.TgZ(110,"p"),e._uU(111,"We can pick a set of properties from this class using the "),e.TgZ(112,"code"),e._uU(113,"PickType()"),e.qZA(),e._uU(114," utility function:"),e.qZA(),e.TgZ(115,"pre")(116,"code",8),e._uU(117,"\n@InputType()\nexport class UpdateEmailInput extends PickType(CreateUserInput, [\n  'email',\n] as const) {}\n"),e.qZA()(),e.TgZ(118,"blockquote",9)(119,"strong"),e._uU(120,"Hint"),e.qZA(),e._uU(121," The "),e.TgZ(122,"code"),e._uU(123,"PickType()"),e.qZA(),e._uU(124," function is imported from the "),e.TgZ(125,"code"),e._uU(126,"@nestjs/graphql"),e.qZA(),e._uU(127," package.\n"),e.qZA(),e.TgZ(128,"h4",11)(129,"span"),e._uU(130,"Omit"),e.qZA()(),e.TgZ(131,"p"),e._uU(132,"The "),e.TgZ(133,"code"),e._uU(134,"OmitType()"),e.qZA(),e._uU(135," function constructs a type by picking all properties from an input type and then removing a particular set of keys. For example, suppose we start with a type like:"),e.qZA(),e.TgZ(136,"pre")(137,"code",8),e._uU(138,"\n@InputType()\nclass CreateUserInput {\n  @Field()\n  email: string;\n\n  @Field()\n  password: string;\n\n  @Field()\n  firstName: string;\n}\n"),e.qZA()(),e.TgZ(139,"p"),e._uU(140,"We can generate a derived type that has every property "),e.TgZ(141,"strong"),e._uU(142,"except"),e.qZA(),e.TgZ(143,"code"),e._uU(144,"email"),e.qZA(),e._uU(145," as shown below. In this construct, the second argument to "),e.TgZ(146,"code"),e._uU(147,"OmitType"),e.qZA(),e._uU(148," is an array of property names."),e.qZA(),e.TgZ(149,"pre")(150,"code",8),e._uU(151,"\n@InputType()\nexport class UpdateUserInput extends OmitType(CreateUserInput, [\n  'email',\n] as const) {}\n"),e.qZA()(),e.TgZ(152,"blockquote",9)(153,"strong"),e._uU(154,"Hint"),e.qZA(),e._uU(155," The "),e.TgZ(156,"code"),e._uU(157,"OmitType()"),e.qZA(),e._uU(158," function is imported from the "),e.TgZ(159,"code"),e._uU(160,"@nestjs/graphql"),e.qZA(),e._uU(161," package.\n"),e.qZA(),e.TgZ(162,"h4",12)(163,"span"),e._uU(164,"Intersection"),e.qZA()(),e.TgZ(165,"p"),e._uU(166,"The "),e.TgZ(167,"code"),e._uU(168,"IntersectionType()"),e.qZA(),e._uU(169," function combines two types into one new type (class). For example, suppose we start with two types like:"),e.qZA(),e.TgZ(170,"pre")(171,"code",8),e._uU(172,"\n@InputType()\nclass CreateUserInput {\n  @Field()\n  email: string;\n\n  @Field()\n  password: string;\n}\n\n@ObjectType()\nexport class AdditionalUserInfo {\n  @Field()\n  firstName: string;\n\n  @Field()\n  lastName: string;\n}\n"),e.qZA()(),e.TgZ(173,"p"),e._uU(174,"We can generate a new type that combines all properties in both types."),e.qZA(),e.TgZ(175,"pre")(176,"code",8),e._uU(177,"\n@InputType()\nexport class UpdateUserInput extends IntersectionType(\n  CreateUserInput,\n  AdditionalUserInfo,\n) {}\n"),e.qZA()(),e.TgZ(178,"blockquote",9)(179,"strong"),e._uU(180,"Hint"),e.qZA(),e._uU(181," The "),e.TgZ(182,"code"),e._uU(183,"IntersectionType()"),e.qZA(),e._uU(184," function is imported from the "),e.TgZ(185,"code"),e._uU(186,"@nestjs/graphql"),e.qZA(),e._uU(187," package.\n"),e.qZA(),e.TgZ(188,"h4",13)(189,"span"),e._uU(190,"Composition"),e.qZA()(),e.TgZ(191,"p"),e._uU(192,"The type mapping utility functions are composable. For example, the following will produce a type (class) that has all of the properties of the "),e.TgZ(193,"code"),e._uU(194,"CreateUserInput"),e.qZA(),e._uU(195," type except for "),e.TgZ(196,"code"),e._uU(197,"email"),e.qZA(),e._uU(198,", and those properties will be set to optional:"),e.qZA(),e.TgZ(199,"pre")(200,"code",8),e._uU(201,"\n@InputType()\nexport class UpdateUserInput extends PartialType(\n  OmitType(CreateUserInput, ['email'] as const),\n) {}\n"),e.qZA()()())},dependencies:[a.U],encapsulation:2,changeDetection:0}),t})(),w=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-mutations"]],features:[e.qOj],decls:145,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/mutations.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","mutations"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/queries/#mutations"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/graphql-tools/generate-schema.html"],["appAnchor","","id","code-first"],["routerLink","/graphql/resolvers"],[1,"language-typescript"],[1,"info"],[1,"language-graphql"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/#input-types"],["routerLink","/graphql/cli-plugin"],["appAnchor","","id","schema-first"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Mutations"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"Most discussions of GraphQL focus on data fetching, but any complete data platform needs a way to modify server-side data as well. In REST, any request could end up causing side-effects on the server, but best practice suggests we should not modify data in GET requests. GraphQL is similar - technically any query could be implemented to cause a data write. However, like REST, it's recommended to observe the convention that any operations that cause writes should be sent explicitly via a mutation (read more "),e.TgZ(9,"a",6),e._uU(10,"here"),e.qZA(),e._uU(11,")."),e.qZA(),e.TgZ(12,"p"),e._uU(13,"The official "),e.TgZ(14,"a",7),e._uU(15,"Apollo"),e.qZA(),e._uU(16," documentation uses an "),e.TgZ(17,"code"),e._uU(18,"upvotePost()"),e.qZA(),e._uU(19," mutation example. This mutation implements a method to increase a post's "),e.TgZ(20,"code"),e._uU(21,"votes"),e.qZA(),e._uU(22," property value. To create an equivalent mutation in Nest, we'll make use of the "),e.TgZ(23,"code"),e._uU(24,"@Mutation()"),e.qZA(),e._uU(25," decorator."),e.qZA(),e.TgZ(26,"h4",8)(27,"span"),e._uU(28,"Code first"),e.qZA()(),e.TgZ(29,"p"),e._uU(30,"Let's add another method to the "),e.TgZ(31,"code"),e._uU(32,"AuthorResolver"),e.qZA(),e._uU(33," used in the previous section (see "),e.TgZ(34,"a",9),e._uU(35,"resolvers"),e.qZA(),e._uU(36,")."),e.qZA(),e.TgZ(37,"pre")(38,"code",10),e._uU(39,"\n@Mutation(returns => Post)\nasync upvotePost(@Args({ name: 'postId', type: () => Int }) postId: number) {\n  return this.postsService.upvoteById({ id: postId });\n}\n"),e.qZA()(),e.TgZ(40,"blockquote",11)(41,"strong"),e._uU(42,"Hint"),e.qZA(),e._uU(43," All decorators (e.g., "),e.TgZ(44,"code"),e._uU(45,"@Resolver"),e.qZA(),e._uU(46,", "),e.TgZ(47,"code"),e._uU(48,"@ResolveField"),e.qZA(),e._uU(49,", "),e.TgZ(50,"code"),e._uU(51,"@Args"),e.qZA(),e._uU(52,", etc.) are exported from the "),e.TgZ(53,"code"),e._uU(54,"@nestjs/graphql"),e.qZA(),e._uU(55," package.\n"),e.qZA(),e.TgZ(56,"p"),e._uU(57,"This will result in generating the following part of the GraphQL schema in SDL:"),e.qZA(),e.TgZ(58,"pre")(59,"code",12),e._uU(60,"\ntype Mutation {\n  upvotePost(postId: Int!): Post\n}\n"),e.qZA()(),e.TgZ(61,"p"),e._uU(62,"The "),e.TgZ(63,"code"),e._uU(64,"upvotePost()"),e.qZA(),e._uU(65," method takes "),e.TgZ(66,"code"),e._uU(67,"postId"),e.qZA(),e._uU(68," ("),e.TgZ(69,"code"),e._uU(70,"Int"),e.qZA(),e._uU(71,") as an argument and returns an updated "),e.TgZ(72,"code"),e._uU(73,"Post"),e.qZA(),e._uU(74," entity. For the reasons explained in the "),e.TgZ(75,"a",9),e._uU(76,"resolvers"),e.qZA(),e._uU(77," section, we have to explicitly set the expected type."),e.qZA(),e.TgZ(78,"p"),e._uU(79,"If the mutation needs to take an object as an argument, we can create an "),e.TgZ(80,"strong"),e._uU(81,"input type"),e.qZA(),e._uU(82,". The input type is a special kind of object type that can be passed in as an argument (read more "),e.TgZ(83,"a",13),e._uU(84,"here"),e.qZA(),e._uU(85,"). To declare an input type, use the "),e.TgZ(86,"code"),e._uU(87,"@InputType()"),e.qZA(),e._uU(88," decorator."),e.qZA(),e.TgZ(89,"pre")(90,"code",10),e._uU(91,"\nimport { InputType, Field } from '@nestjs/graphql';\n\n@InputType()\nexport class UpvotePostInput {\n  @Field()\n  postId: number;\n}\n"),e.qZA()(),e.TgZ(92,"blockquote",11)(93,"strong"),e._uU(94,"Hint"),e.qZA(),e._uU(95," The "),e.TgZ(96,"code"),e._uU(97,"@InputType()"),e.qZA(),e._uU(98," decorator takes an options object as an argument, so you can, for example, specify the input type's description. Note that, due to TypeScript's metadata reflection system limitations, you must either use the "),e.TgZ(99,"code"),e._uU(100,"@Field"),e.qZA(),e._uU(101," decorator to manually indicate a type, or use a "),e.TgZ(102,"a",14),e._uU(103,"CLI plugin"),e.qZA(),e._uU(104,".\n"),e.qZA(),e.TgZ(105,"p"),e._uU(106,"We can then use this type in the resolver class:"),e.qZA(),e.TgZ(107,"pre")(108,"code",10),e._uU(109,"\n@Mutation(returns => Post)\nasync upvotePost(\n  @Args('upvotePostData') upvotePostData: UpvotePostInput,\n) {}\n"),e.qZA()(),e.TgZ(110,"h4",15)(111,"span"),e._uU(112,"Schema first"),e.qZA()(),e.TgZ(113,"p"),e._uU(114,"Let's extend our "),e.TgZ(115,"code"),e._uU(116,"AuthorResolver"),e.qZA(),e._uU(117," used in the previous section (see "),e.TgZ(118,"a",9),e._uU(119,"resolvers"),e.qZA(),e._uU(120,")."),e.qZA(),e.TgZ(121,"pre")(122,"code",10),e._uU(123,"\n@Mutation()\nasync upvotePost(@Args('postId') postId: number) {\n  return this.postsService.upvoteById({ id: postId });\n}\n"),e.qZA()(),e.TgZ(124,"p"),e._uU(125,"Note that we assumed above that the business logic has been moved to the "),e.TgZ(126,"code"),e._uU(127,"PostsService"),e.qZA(),e._uU(128," (querying the post and incrementing its "),e.TgZ(129,"code"),e._uU(130,"votes"),e.qZA(),e._uU(131," property). The logic inside the "),e.TgZ(132,"code"),e._uU(133,"PostsService"),e.qZA(),e._uU(134," class can be as simple or sophisticated as needed. The main point of this example is to show how resolvers can interact with other providers."),e.qZA(),e.TgZ(135,"p"),e._uU(136,"The last step is to add our mutation to the existing types definition."),e.qZA(),e.TgZ(137,"pre")(138,"code",12),e._uU(139,"\ntype Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post]\n}\n\ntype Post {\n  id: Int!\n  title: String\n  votes: Int\n}\n\ntype Query {\n  author(id: Int!): Author\n}\n\ntype Mutation {\n  upvotePost(postId: Int!): Post\n}\n"),e.qZA()(),e.TgZ(140,"p"),e._uU(141,"The "),e.TgZ(142,"code"),e._uU(143,"upvotePost(postId: Int!): Post"),e.qZA(),e._uU(144," mutation is now available to be called as part of our application's GraphQL API."),e.qZA()())},dependencies:[a.U,u.yS],encapsulation:2,changeDetection:0}),t})(),x=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-plugins"]],features:[e.qOj],decls:70,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/plugins.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","plugins"],[1,"warning"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/integrations/plugins/"],["appAnchor","","id","custom-plugins"],[1,"language-typescript"],["appAnchor","","id","using-external-plugins"],[1,"info"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Plugins"),e.qZA(),e.TgZ(7,"blockquote",6)(8,"strong"),e._uU(9,"Warning"),e.qZA(),e._uU(10," This chapter applies only to the "),e.TgZ(11,"code"),e._uU(12,"@nestjs/apollo"),e.qZA(),e._uU(13," driver.\n"),e.qZA(),e.TgZ(14,"p"),e._uU(15,"Plugins enable you to extend Apollo Server's core functionality by performing custom operations in response to certain events. Currently, these events correspond to individual phases of the GraphQL request lifecycle, and to the startup of Apollo Server itself (read more "),e.TgZ(16,"a",7),e._uU(17,"here"),e.qZA(),e._uU(18,"). For example, a basic logging plugin might log the GraphQL query string associated with each request that's sent to Apollo Server."),e.qZA(),e.TgZ(19,"h4",8)(20,"span"),e._uU(21,"Custom plugins"),e.qZA()(),e.TgZ(22,"p"),e._uU(23,"To create a plugin, declare a class annotated with the "),e.TgZ(24,"code"),e._uU(25,"@Plugin"),e.qZA(),e._uU(26," decorator exported from the "),e.TgZ(27,"code"),e._uU(28,"@nestjs/apollo"),e.qZA(),e._uU(29," package. Also, for better code autocompletion, implement the "),e.TgZ(30,"code"),e._uU(31,"ApolloServerPlugin"),e.qZA(),e._uU(32," interface from the "),e.TgZ(33,"code"),e._uU(34,"apollo-server-plugin-base"),e.qZA(),e._uU(35," package."),e.qZA(),e.TgZ(36,"pre")(37,"code",9),e._uU(38,"\nimport { Plugin } from '@nestjs/apollo';\nimport {\n  ApolloServerPlugin,\n  GraphQLRequestListener,\n} from 'apollo-server-plugin-base';\n\n@Plugin()\nexport class LoggingPlugin implements ApolloServerPlugin {\n  async requestDidStart(): Promise<GraphQLRequestListener> {\n    console.log('Request started');\n    return {\n      async willSendResponse() {\n        console.log('Will send response');\n      },\n    };\n  }\n}\n"),e.qZA()(),e.TgZ(39,"p"),e._uU(40,"With this in place, we can register the "),e.TgZ(41,"code"),e._uU(42,"LoggingPlugin"),e.qZA(),e._uU(43," as a provider."),e.qZA(),e.TgZ(44,"pre")(45,"code",9),e._uU(46,"\n@Module({\n  providers: [LoggingPlugin],\n})\nexport class CommonModule {}\n"),e.qZA()(),e.TgZ(47,"p"),e._uU(48,"Nest will automatically instantiate a plugin and apply it to the Apollo Server."),e.qZA(),e.TgZ(49,"h4",10)(50,"span"),e._uU(51,"Using external plugins"),e.qZA()(),e.TgZ(52,"p"),e._uU(53,"There are several plugins provided out-of-the-box. To use an existing plugin, simply import it and add it to the "),e.TgZ(54,"code"),e._uU(55,"plugins"),e.qZA(),e._uU(56," array:"),e.qZA(),e.TgZ(57,"pre")(58,"code",9),e._uU(59,"\nGraphQLModule.forRoot({\n  // ...\n  plugins: [ApolloServerOperationRegistry({ /* options */})]\n}),\n"),e.qZA()(),e.TgZ(60,"blockquote",11)(61,"strong"),e._uU(62,"Hint"),e.qZA(),e._uU(63," The "),e.TgZ(64,"code"),e._uU(65,"ApolloServerOperationRegistry"),e.qZA(),e._uU(66," plugin is exported from the "),e.TgZ(67,"code"),e._uU(68,"apollo-server-plugin-operation-registry"),e.qZA(),e._uU(69," package.\n"),e.qZA()())},dependencies:[a.U],encapsulation:2,changeDetection:0}),t})();var S=i(8568);let k=(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-quick-start"]],features:[e.qOj],decls:546,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/quick-start.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","harnessing-the-power-of-typescript--graphql"],["rel","nofollow","target","_blank","href","https://graphql.org/"],["rel","nofollow","target","_blank","href","https://dev-blog.apollodata.com/graphql-vs-rest-5d425123e34b"],["rel","nofollow","target","_blank","href","https://www.typescriptlang.org/"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/"],["rel","nofollow","target","_blank","href","https://github.com/mercurius-js/mercurius"],["href","/graphql/other-features#creating-a-custom-driver"],["appAnchor","","id","installation"],[1,"language-bash"],[1,"warning"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/migration/"],["appAnchor","","id","overview"],["appAnchor","","id","getting-started-with-graphql--typescript"],[1,"info"],["href","/graphql/quick-start#mercurius-integration"],[1,"filename"],["app801d5aa3b152bfd77dd606ab70f012eec8444550",""],[1,"language-typescript"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/v2/api/apollo-server.html#constructor-options-lt-ApolloServer-gt"],["rel","nofollow","target","_blank","href","https://github.com/mercurius-js/mercurius/blob/master/docs/api/options.md#plugin-options"],["appef55043a6f9776da2c02ef7d46b957820d7585e6",""],["appAnchor","","id","graphql-playground"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/tree/master/sample/23-graphql-code-first"],["routerLink","/graphql/resolvers-map"],["src","/assets/playground.png","alt",""],["rel","nofollow","target","_blank","href","https://github.com/graphql/graphiql"],["appAnchor","","id","multiple-endpoints"],["appAnchor","","id","code-first"],["appAnchor","","id","example"],["appAnchor","","id","schema-first"],["rel","nofollow","target","_blank","href","https://en.wikipedia.org/wiki/Abstract_syntax_tree"],["appAnchor","","id","apollo-sandbox"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/blog/announcement/platform/apollo-sandbox-an-open-graphql-ide-for-local-development/"],["appAnchor","","id","example-1"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/tree/master/sample/12-graphql-schema-first"],["appAnchor","","id","accessing-generated-schema"],["appAnchor","","id","async-configuration"],["href","https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory"],["appAnchor","","id","mercurius-integration"],["routerLink","/techniques/performance"],["appf8cc8ffbcb7ed5285669ca0df73e8648b0de42d7",""]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h2",5),e._uU(6,"Harnessing the power of TypeScript & GraphQL"),e.qZA(),e.TgZ(7,"p")(8,"a",6),e._uU(9,"GraphQL"),e.qZA(),e._uU(10," is a powerful query language for APIs and a runtime for fulfilling those queries with your existing data. It's an elegant approach that solves many problems typically found with REST APIs. For background, we suggest reading this "),e.TgZ(11,"a",7),e._uU(12,"comparison"),e.qZA(),e._uU(13," between GraphQL and REST. GraphQL combined with "),e.TgZ(14,"a",8),e._uU(15,"TypeScript"),e.qZA(),e._uU(16," helps you develop better type safety with your GraphQL queries, giving you end-to-end typing."),e.qZA(),e.TgZ(17,"p"),e._uU(18,"In this chapter, we assume a basic understanding of GraphQL, and focus on how to work with the built-in "),e.TgZ(19,"code"),e._uU(20,"@nestjs/graphql"),e.qZA(),e._uU(21," module. The "),e.TgZ(22,"code"),e._uU(23,"GraphQLModule"),e.qZA(),e._uU(24," can be configured to use "),e.TgZ(25,"a",9),e._uU(26,"Apollo"),e.qZA(),e._uU(27," server (with the "),e.TgZ(28,"code"),e._uU(29,"@nestjs/apollo"),e.qZA(),e._uU(30," driver) and "),e.TgZ(31,"a",10),e._uU(32,"Mercurius"),e.qZA(),e._uU(33," (with the "),e.TgZ(34,"code"),e._uU(35,"@nestjs/mercurius"),e.qZA(),e._uU(36,"). We provide official integrations for these proven GraphQL packages to provide a simple way to use GraphQL with Nest. You can also build your own dedicated driver (read more on that "),e.TgZ(37,"a",11),e._uU(38,"here"),e.qZA(),e._uU(39,")."),e.qZA(),e.TgZ(40,"h4",12)(41,"span"),e._uU(42,"Installation"),e.qZA()(),e.TgZ(43,"p"),e._uU(44,"Start by installing the required packages:"),e.qZA(),e.TgZ(45,"pre")(46,"code",13),e._uU(47,"\n# For Express and Apollo (default)\n$ npm i @nestjs/graphql @nestjs/apollo graphql apollo-server-express\n\n# For Fastify and Apollo\n# npm i @nestjs/graphql @nestjs/apollo graphql apollo-server-fastify\n\n# For Fastify and Mercurius\n# npm i @nestjs/graphql @nestjs/mercurius graphql mercurius@^9\n"),e.qZA()(),e.TgZ(48,"blockquote",14)(49,"strong"),e._uU(50,"Warning"),e.qZA(),e.TgZ(51,"code"),e._uU(52,"@nestjs/graphql@>=9"),e.qZA(),e._uU(53," and "),e.TgZ(54,"code"),e._uU(55,"@nestjs/apollo^10"),e.qZA(),e._uU(56," packages are compatible with "),e.TgZ(57,"strong"),e._uU(58,"Apollo v3"),e.qZA(),e._uU(59," (check out Apollo Server 3 "),e.TgZ(60,"a",15),e._uU(61,"migration guide"),e.qZA(),e._uU(62," for more details), while "),e.TgZ(63,"code"),e._uU(64,"@nestjs/graphql@^8"),e.qZA(),e._uU(65," only supports "),e.TgZ(66,"strong"),e._uU(67,"Apollo v2"),e.qZA(),e._uU(68," (e.g., "),e.TgZ(69,"code"),e._uU(70,"apollo-server-express@2.x.x"),e.qZA(),e._uU(71," package).\n"),e.qZA(),e.TgZ(72,"h4",16)(73,"span"),e._uU(74,"Overview"),e.qZA()(),e.TgZ(75,"p"),e._uU(76,"Nest offers two ways of building GraphQL applications, the "),e.TgZ(77,"strong"),e._uU(78,"code first"),e.qZA(),e._uU(79," and the "),e.TgZ(80,"strong"),e._uU(81,"schema first"),e.qZA(),e._uU(82," methods. You should choose the one that works best for you. Most of the chapters in this GraphQL section are divided into two main parts: one you should follow if you adopt "),e.TgZ(83,"strong"),e._uU(84,"code first"),e.qZA(),e._uU(85,", and the other to be used if you adopt "),e.TgZ(86,"strong"),e._uU(87,"schema first"),e.qZA(),e._uU(88,"."),e.qZA(),e.TgZ(89,"p"),e._uU(90,"In the "),e.TgZ(91,"strong"),e._uU(92,"code first"),e.qZA(),e._uU(93," approach, you use decorators and TypeScript classes to generate the corresponding GraphQL schema. This approach is useful if you prefer to work exclusively with TypeScript and avoid context switching between language syntaxes."),e.qZA(),e.TgZ(94,"p"),e._uU(95,"In the "),e.TgZ(96,"strong"),e._uU(97,"schema first"),e.qZA(),e._uU(98," approach, the source of truth is GraphQL SDL (Schema Definition Language) files. SDL is a language-agnostic way to share schema files between different platforms. Nest automatically generates your TypeScript definitions (using either classes or interfaces) based on the GraphQL schemas to reduce the need to write redundant boilerplate code."),e.qZA(),e.TgZ(99,"h4",17)(100,"span"),e._uU(101,"Getting started with GraphQL & TypeScript"),e.qZA()(),e.TgZ(102,"blockquote",18)(103,"strong"),e._uU(104,"Hint"),e.qZA(),e._uU(105," In the following chapters, we'll be integrating the "),e.TgZ(106,"code"),e._uU(107,"@nestjs/apollo"),e.qZA(),e._uU(108," package. If you want to use "),e.TgZ(109,"code"),e._uU(110,"mercurius"),e.qZA(),e._uU(111," package instead, navigate to "),e.TgZ(112,"a",19),e._uU(113,"this section"),e.qZA(),e._uU(114,".\n"),e.qZA(),e.TgZ(115,"p"),e._uU(116,"Once the packages are installed, we can import the "),e.TgZ(117,"code"),e._uU(118,"GraphQLModule"),e.qZA(),e._uU(119," and configure it with the "),e.TgZ(120,"code"),e._uU(121,"forRoot()"),e.qZA(),e._uU(122," static method."),e.qZA(),e.TgZ(123,"span",20),e._UZ(124,"app-tabs",null,21),e.qZA(),e.TgZ(126,"pre")(127,"code",22),e._uU(128,"\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<ApolloDriverConfig>({\n      driver: ApolloDriver,\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(129,"blockquote",18)(130,"strong"),e._uU(131,"Hint"),e.qZA(),e._uU(132," For "),e.TgZ(133,"code"),e._uU(134,"mercurius"),e.qZA(),e._uU(135," integration, you should be using the "),e.TgZ(136,"code"),e._uU(137,"MercuriusDriver"),e.qZA(),e._uU(138," and "),e.TgZ(139,"code"),e._uU(140,"MercuriusDriverConfig"),e.qZA(),e._uU(141," instead. Both are exported from the "),e.TgZ(142,"code"),e._uU(143,"@nestjs/mercurius"),e.qZA(),e._uU(144," package.\n"),e.qZA(),e.TgZ(145,"p"),e._uU(146,"The "),e.TgZ(147,"code"),e._uU(148,"forRoot()"),e.qZA(),e._uU(149," method takes an options object as an argument. These options are passed through to the underlying driver instance (read more about available settings here: "),e.TgZ(150,"a",23),e._uU(151,"Apollo"),e.qZA(),e._uU(152," and "),e.TgZ(153,"a",24),e._uU(154,"Mercurius"),e.qZA(),e._uU(155,"). For example, if you want to disable the "),e.TgZ(156,"code"),e._uU(157,"playground"),e.qZA(),e._uU(158," and turn off "),e.TgZ(159,"code"),e._uU(160,"debug"),e.qZA(),e._uU(161," mode (for Apollo), pass the following options:"),e.qZA(),e.TgZ(162,"span",20),e._UZ(163,"app-tabs",null,25),e.qZA(),e.TgZ(165,"pre")(166,"code",22),e._uU(167,"\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<ApolloDriverConfig>({\n      driver: ApolloDriver,\n      debug: false,\n      playground: false,\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(168,"p"),e._uU(169,"In this case, these options will be forwarded to the "),e.TgZ(170,"code"),e._uU(171,"ApolloServer"),e.qZA(),e._uU(172," constructor."),e.qZA(),e.TgZ(173,"p"),e._UZ(174,"app-banner-enterprise"),e.qZA(),e.TgZ(175,"h4",26)(176,"span"),e._uU(177,"GraphQL playground"),e.qZA()(),e.TgZ(178,"p"),e._uU(179,"The playground is a graphical, interactive, in-browser GraphQL IDE, available by default on the same URL as the GraphQL server itself. To access the playground, you need a basic GraphQL server configured and running. To see it now, you can install and build the "),e.TgZ(180,"a",27),e._uU(181,"working example here"),e.qZA(),e._uU(182,". Alternatively, if you're following along with these code samples, once you've completed the steps in the "),e.TgZ(183,"a",28),e._uU(184,"Resolvers chapter"),e.qZA(),e._uU(185,", you can access the playground."),e.qZA(),e.TgZ(186,"p"),e._uU(187,"With that in place, and with your application running in the background, you can then open your web browser and navigate to "),e.TgZ(188,"code"),e._uU(189,"http://localhost:3000/graphql"),e.qZA(),e._uU(190," (host and port may vary depending on your configuration). You will then see the GraphQL playground, as shown below."),e.qZA(),e.TgZ(191,"figure"),e._UZ(192,"img",29),e.qZA(),e.TgZ(193,"blockquote",14)(194,"strong"),e._uU(195,"Note"),e.qZA(),e.TgZ(196,"code"),e._uU(197,"@nestjs/mercurius"),e.qZA(),e._uU(198," integration does not ship with the built-in GraphQL Playground integration. Instead, you can use "),e.TgZ(199,"a",30),e._uU(200,"GraphiQL"),e.qZA(),e._uU(201," (set "),e.TgZ(202,"code"),e._uU(203,"graphiql: true"),e.qZA(),e._uU(204,").\n"),e.qZA(),e.TgZ(205,"h4",31)(206,"span"),e._uU(207,"Multiple endpoints"),e.qZA()(),e.TgZ(208,"p"),e._uU(209,"Another useful feature of the "),e.TgZ(210,"code"),e._uU(211,"@nestjs/graphql"),e.qZA(),e._uU(212," module is the ability to serve multiple endpoints at once. This lets you decide which modules should be included in which endpoint. By default, "),e.TgZ(213,"code"),e._uU(214,"GraphQL"),e.qZA(),e._uU(215," searches for resolvers throughout the whole app. To limit this scan to only a subset of modules, use the "),e.TgZ(216,"code"),e._uU(217,"include"),e.qZA(),e._uU(218," property."),e.qZA(),e.TgZ(219,"pre")(220,"code",22),e._uU(221,"\nGraphQLModule.forRoot({\n  include: [CatsModule],\n}),\n"),e.qZA()(),e.TgZ(222,"blockquote",14)(223,"strong"),e._uU(224,"Warning"),e.qZA(),e._uU(225," If you use the "),e.TgZ(226,"code"),e._uU(227,"apollo-server-fastify"),e.qZA(),e._uU(228," package with multiple GraphQL endpoints in a single application, make sure to enable the "),e.TgZ(229,"code"),e._uU(230,"disableHealthCheck"),e.qZA(),e._uU(231," setting in the "),e.TgZ(232,"code"),e._uU(233,"GraphQLModule"),e.qZA(),e._uU(234," configuration.\n"),e.qZA(),e.TgZ(235,"h4",32)(236,"span"),e._uU(237,"Code first"),e.qZA()(),e.TgZ(238,"p"),e._uU(239,"In the "),e.TgZ(240,"strong"),e._uU(241,"code first"),e.qZA(),e._uU(242," approach, you use decorators and TypeScript classes to generate the corresponding GraphQL schema."),e.qZA(),e.TgZ(243,"p"),e._uU(244,"To use the code first approach, start by adding the "),e.TgZ(245,"code"),e._uU(246,"autoSchemaFile"),e.qZA(),e._uU(247," property to the options object:"),e.qZA(),e.TgZ(248,"pre")(249,"code",22),e._uU(250,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  autoSchemaFile: join(process.cwd(), 'src/schema.gql'),\n}),\n"),e.qZA()(),e.TgZ(251,"p"),e._uU(252,"The "),e.TgZ(253,"code"),e._uU(254,"autoSchemaFile"),e.qZA(),e._uU(255," property value is the path where your automatically generated schema will be created. Alternatively, the schema can be generated on-the-fly in memory. To enable this, set the "),e.TgZ(256,"code"),e._uU(257,"autoSchemaFile"),e.qZA(),e._uU(258," property to "),e.TgZ(259,"code"),e._uU(260,"true"),e.qZA(),e._uU(261,":"),e.qZA(),e.TgZ(262,"pre")(263,"code",22),e._uU(264,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  autoSchemaFile: true,\n}),\n"),e.qZA()(),e.TgZ(265,"p"),e._uU(266,"By default, the types in the generated schema will be in the order they are defined in the included modules. To sort the schema lexicographically, set the "),e.TgZ(267,"code"),e._uU(268,"sortSchema"),e.qZA(),e._uU(269," property to "),e.TgZ(270,"code"),e._uU(271,"true"),e.qZA(),e._uU(272,":"),e.qZA(),e.TgZ(273,"pre")(274,"code",22),e._uU(275,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  autoSchemaFile: join(process.cwd(), 'src/schema.gql'),\n  sortSchema: true,\n}),\n"),e.qZA()(),e.TgZ(276,"h4",33)(277,"span"),e._uU(278,"Example"),e.qZA()(),e.TgZ(279,"p"),e._uU(280,"A fully working code first sample is available "),e.TgZ(281,"a",27),e._uU(282,"here"),e.qZA(),e._uU(283,"."),e.qZA(),e.TgZ(284,"h4",34)(285,"span"),e._uU(286,"Schema first"),e.qZA()(),e.TgZ(287,"p"),e._uU(288,"To use the schema first approach, start by adding a "),e.TgZ(289,"code"),e._uU(290,"typePaths"),e.qZA(),e._uU(291," property to the options object. The "),e.TgZ(292,"code"),e._uU(293,"typePaths"),e.qZA(),e._uU(294," property indicates where the "),e.TgZ(295,"code"),e._uU(296,"GraphQLModule"),e.qZA(),e._uU(297," should look for GraphQL SDL schema definition files you'll be writing. These files will be combined in memory; this allows you to split your schemas into several files and locate them near their resolvers."),e.qZA(),e.TgZ(298,"pre")(299,"code",22),e._uU(300,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  typePaths: ['./**/*.graphql'],\n}),\n"),e.qZA()(),e.TgZ(301,"p"),e._uU(302,"You will typically also need to have TypeScript definitions (classes and interfaces) that correspond to the GraphQL SDL types. Creating the corresponding TypeScript definitions by hand is redundant and tedious. It leaves us without a single source of truth -- each change made within SDL forces us to adjust TypeScript definitions as well. To address this, the "),e.TgZ(303,"code"),e._uU(304,"@nestjs/graphql"),e.qZA(),e._uU(305," package can "),e.TgZ(306,"strong"),e._uU(307,"automatically generate"),e.qZA(),e._uU(308," TypeScript definitions from the abstract syntax tree ("),e.TgZ(309,"a",35),e._uU(310,"AST"),e.qZA(),e._uU(311,"). To enable this feature, add the "),e.TgZ(312,"code"),e._uU(313,"definitions"),e.qZA(),e._uU(314," options property when configuring the "),e.TgZ(315,"code"),e._uU(316,"GraphQLModule"),e.qZA(),e._uU(317,"."),e.qZA(),e.TgZ(318,"pre")(319,"code",22),e._uU(320,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  typePaths: ['./**/*.graphql'],\n  definitions: {\n    path: join(process.cwd(), 'src/graphql.ts'),\n  },\n}),\n"),e.qZA()(),e.TgZ(321,"p"),e._uU(322,"The path property of the "),e.TgZ(323,"code"),e._uU(324,"definitions"),e.qZA(),e._uU(325," object indicates where to save generated TypeScript output. By default, all generated TypeScript types are created as interfaces. To generate classes instead, specify the "),e.TgZ(326,"code"),e._uU(327,"outputAs"),e.qZA(),e._uU(328," property with a value of "),e.TgZ(329,"code"),e._uU(330,"'class'"),e.qZA(),e._uU(331,"."),e.qZA(),e.TgZ(332,"pre")(333,"code",22),e._uU(334,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  typePaths: ['./**/*.graphql'],\n  definitions: {\n    path: join(process.cwd(), 'src/graphql.ts'),\n    outputAs: 'class',\n  },\n}),\n"),e.qZA()(),e.TgZ(335,"p"),e._uU(336,"The above approach dynamically generates TypeScript definitions each time the application starts. Alternatively, it may be preferable to build a simple script to generate these on demand. For example, assume we create the following script as "),e.TgZ(337,"code"),e._uU(338,"generate-typings.ts"),e.qZA(),e._uU(339,":"),e.qZA(),e.TgZ(340,"pre")(341,"code",22),e._uU(342,"\nimport { GraphQLDefinitionsFactory } from '@nestjs/graphql';\nimport { join } from 'path';\n\nconst definitionsFactory = new GraphQLDefinitionsFactory();\ndefinitionsFactory.generate({\n  typePaths: ['./src/**/*.graphql'],\n  path: join(process.cwd(), 'src/graphql.ts'),\n  outputAs: 'class',\n});\n"),e.qZA()(),e.TgZ(343,"p"),e._uU(344,"Now you can run this script on demand:"),e.qZA(),e.TgZ(345,"pre")(346,"code",13),e._uU(347,"\n$ ts-node generate-typings\n"),e.qZA()(),e.TgZ(348,"blockquote",18)(349,"strong"),e._uU(350,"Hint"),e.qZA(),e._uU(351," You can compile the script beforehand (e.g., with "),e.TgZ(352,"code"),e._uU(353,"tsc"),e.qZA(),e._uU(354,") and use "),e.TgZ(355,"code"),e._uU(356,"node"),e.qZA(),e._uU(357," to execute it.\n"),e.qZA(),e.TgZ(358,"p"),e._uU(359,"To enable watch mode for the script (to automatically generate typings whenever any "),e.TgZ(360,"code"),e._uU(361,".graphql"),e.qZA(),e._uU(362," file changes), pass the "),e.TgZ(363,"code"),e._uU(364,"watch"),e.qZA(),e._uU(365," option to the "),e.TgZ(366,"code"),e._uU(367,"generate()"),e.qZA(),e._uU(368," method."),e.qZA(),e.TgZ(369,"pre")(370,"code",22),e._uU(371,"\ndefinitionsFactory.generate({\n  typePaths: ['./src/**/*.graphql'],\n  path: join(process.cwd(), 'src/graphql.ts'),\n  outputAs: 'class',\n  watch: true,\n});\n"),e.qZA()(),e.TgZ(372,"p"),e._uU(373,"To automatically generate the additional "),e.TgZ(374,"code"),e._uU(375,"__typename"),e.qZA(),e._uU(376," field for every object type, enable the "),e.TgZ(377,"code"),e._uU(378,"emitTypenameField"),e.qZA(),e._uU(379," option."),e.qZA(),e.TgZ(380,"pre")(381,"code",22),e._uU(382,"\ndefinitionsFactory.generate({\n  // ...,\n  emitTypenameField: true,\n});\n"),e.qZA()(),e.TgZ(383,"p"),e._uU(384,"To generate resolvers (queries, mutations, subscriptions) as plain fields without arguments, enable the "),e.TgZ(385,"code"),e._uU(386,"skipResolverArgs"),e.qZA(),e._uU(387," option."),e.qZA(),e.TgZ(388,"pre")(389,"code",22),e._uU(390,"\ndefinitionsFactory.generate({\n  // ...,\n  skipResolverArgs: true,\n});\n"),e.qZA()(),e.TgZ(391,"h4",36)(392,"span"),e._uU(393,"Apollo Sandbox"),e.qZA()(),e.TgZ(394,"p"),e._uU(395,"To use "),e.TgZ(396,"a",37),e._uU(397,"Apollo Sandbox"),e.qZA(),e._uU(398," instead of the "),e.TgZ(399,"code"),e._uU(400,"graphql-playground"),e.qZA(),e._uU(401," as a GraphQL IDE for local development, use the following configuration:"),e.qZA(),e.TgZ(402,"pre")(403,"code",22),e._uU(404,"\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\nimport { ApolloServerPluginLandingPageLocalDefault } from 'apollo-server-core';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<ApolloDriverConfig>({\n      driver: ApolloDriver,\n      playground: false,\n      plugins: [ApolloServerPluginLandingPageLocalDefault()],\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(405,"h4",38)(406,"span"),e._uU(407,"Example"),e.qZA()(),e.TgZ(408,"p"),e._uU(409,"A fully working schema first sample is available "),e.TgZ(410,"a",39),e._uU(411,"here"),e.qZA(),e._uU(412,"."),e.qZA(),e.TgZ(413,"h4",40)(414,"span"),e._uU(415,"Accessing generated schema"),e.qZA()(),e.TgZ(416,"p"),e._uU(417,"In some circumstances (for example end-to-end tests), you may want to get a reference to the generated schema object. In end-to-end tests, you can then run queries using the "),e.TgZ(418,"code"),e._uU(419,"graphql"),e.qZA(),e._uU(420," object without using any HTTP listeners."),e.qZA(),e.TgZ(421,"p"),e._uU(422,"You can access the generated schema (in either the code first or schema first approach), using the "),e.TgZ(423,"code"),e._uU(424,"GraphQLSchemaHost"),e.qZA(),e._uU(425," class:"),e.qZA(),e.TgZ(426,"pre")(427,"code",22),e._uU(428,"\nconst { schema } = app.get(GraphQLSchemaHost);\n"),e.qZA()(),e.TgZ(429,"blockquote",18)(430,"strong"),e._uU(431,"Hint"),e.qZA(),e._uU(432," You must call the "),e.TgZ(433,"code"),e._uU(434,"GraphQLSchemaHost#schema"),e.qZA(),e._uU(435," getter after the application has been initialized (after the "),e.TgZ(436,"code"),e._uU(437,"onModuleInit"),e.qZA(),e._uU(438," hook has been triggered by either the "),e.TgZ(439,"code"),e._uU(440,"app.listen()"),e.qZA(),e._uU(441," or "),e.TgZ(442,"code"),e._uU(443,"app.init()"),e.qZA(),e._uU(444," method).\n"),e.qZA(),e.TgZ(445,"h4",41)(446,"span"),e._uU(447,"Async configuration"),e.qZA()(),e.TgZ(448,"p"),e._uU(449,"When you need to pass module options asynchronously instead of statically, use the "),e.TgZ(450,"code"),e._uU(451,"forRootAsync()"),e.qZA(),e._uU(452," method. As with most dynamic modules, Nest provides several techniques to deal with async configuration."),e.qZA(),e.TgZ(453,"p"),e._uU(454,"One technique is to use a factory function:"),e.qZA(),e.TgZ(455,"pre")(456,"code",22),e._uU(457,"\n GraphQLModule.forRootAsync<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  useFactory: () => ({\n    typePaths: ['./**/*.graphql'],\n  }),\n}),\n"),e.qZA()(),e.TgZ(458,"p"),e._uU(459,"Like other factory providers, our factory function can be "),e.TgZ(460,"a",42),e._uU(461,"async"),e.qZA(),e._uU(462," and can inject dependencies through "),e.TgZ(463,"code"),e._uU(464,"inject"),e.qZA(),e._uU(465,"."),e.qZA(),e.TgZ(466,"pre")(467,"code",22),e._uU(468,"\nGraphQLModule.forRootAsync<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  imports: [ConfigModule],\n  useFactory: async (configService: ConfigService) => ({\n    typePaths: configService.getString('GRAPHQL_TYPE_PATHS'),\n  }),\n  inject: [ConfigService],\n}),\n"),e.qZA()(),e.TgZ(469,"p"),e._uU(470,"Alternatively, you can configure the "),e.TgZ(471,"code"),e._uU(472,"GraphQLModule"),e.qZA(),e._uU(473," using a class instead of a factory, as shown below:"),e.qZA(),e.TgZ(474,"pre")(475,"code",22),e._uU(476,"\nGraphQLModule.forRootAsync<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  useClass: GqlConfigService,\n}),\n"),e.qZA()(),e.TgZ(477,"p"),e._uU(478,"The construction above instantiates "),e.TgZ(479,"code"),e._uU(480,"GqlConfigService"),e.qZA(),e._uU(481," inside "),e.TgZ(482,"code"),e._uU(483,"GraphQLModule"),e.qZA(),e._uU(484,", using it to create options object. Note that in this example, the "),e.TgZ(485,"code"),e._uU(486,"GqlConfigService"),e.qZA(),e._uU(487," has to implement the "),e.TgZ(488,"code"),e._uU(489,"GqlOptionsFactory"),e.qZA(),e._uU(490," interface, as shown below. The "),e.TgZ(491,"code"),e._uU(492,"GraphQLModule"),e.qZA(),e._uU(493," will call the "),e.TgZ(494,"code"),e._uU(495,"createGqlOptions()"),e.qZA(),e._uU(496," method on the instantiated object of the supplied class."),e.qZA(),e.TgZ(497,"pre")(498,"code",22),e._uU(499,"\n@Injectable()\nclass GqlConfigService implements GqlOptionsFactory {\n  createGqlOptions(): ApolloDriverConfig {\n    return {\n      typePaths: ['./**/*.graphql'],\n    };\n  }\n}\n"),e.qZA()(),e.TgZ(500,"p"),e._uU(501,"If you want to reuse an existing options provider instead of creating a private copy inside the "),e.TgZ(502,"code"),e._uU(503,"GraphQLModule"),e.qZA(),e._uU(504,", use the "),e.TgZ(505,"code"),e._uU(506,"useExisting"),e.qZA(),e._uU(507," syntax."),e.qZA(),e.TgZ(508,"pre")(509,"code",22),e._uU(510,"\nGraphQLModule.forRootAsync<ApolloDriverConfig>({\n  imports: [ConfigModule],\n  useExisting: ConfigService,\n}),\n"),e.qZA()(),e.TgZ(511,"h4",43)(512,"span"),e._uU(513,"Mercurius integration"),e.qZA()(),e.TgZ(514,"p"),e._uU(515,"Instead of using Apollo, Fastify users (read more "),e.TgZ(516,"a",44),e._uU(517,"here"),e.qZA(),e._uU(518,") can alternatively use the "),e.TgZ(519,"code"),e._uU(520,"@nestjs/mercurius"),e.qZA(),e._uU(521," driver."),e.qZA(),e.TgZ(522,"span",20),e._UZ(523,"app-tabs",null,45),e.qZA(),e.TgZ(525,"pre")(526,"code",22),e._uU(527,"\nimport { Module } from '@nestjs/common';\nimport { GraphQLModule } from '@nestjs/graphql';\nimport { MercuriusDriver, MercuriusDriverConfig } from '@nestjs/mercurius';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<MercuriusDriverConfig>({\n      driver: MercuriusDriver,\n      graphiql: true,\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(528,"blockquote",18)(529,"strong"),e._uU(530,"Hint"),e.qZA(),e._uU(531," Once the application is running, open your browser and navigate to "),e.TgZ(532,"code"),e._uU(533,"http://localhost:3000/graphiql"),e.qZA(),e._uU(534,". You should see the "),e.TgZ(535,"a",30),e._uU(536,"GraphQL IDE"),e.qZA(),e._uU(537,".\n"),e.qZA(),e.TgZ(538,"p"),e._uU(539,"The "),e.TgZ(540,"code"),e._uU(541,"forRoot()"),e.qZA(),e._uU(542," method takes an options object as an argument. These options are passed through to the underlying driver instance. Read more about available settings "),e.TgZ(543,"a",24),e._uU(544,"here"),e.qZA(),e._uU(545,"."),e.qZA()())},dependencies:[l.n,a.U,S.V,u.yS],encapsulation:2,changeDetection:0}),t})();var L=i(7710);const C=[{path:"quick-start",component:k,data:{title:"GraphQL + TypeScript"}},{path:"resolvers-map",redirectTo:"resolvers"},{path:"resolvers",component:(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-resolvers-map"]],features:[e.qOj],decls:1072,vars:40,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/resolvers-map.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","resolvers"],["rel","nofollow","target","_blank","href","https://graphql.org/"],["appAnchor","","id","code-first"],["appAnchor","","id","object-types"],[1,"language-graphql"],[1,"filename"],["app6eb1d56b54064fd170bfff8c03e4439059641c8f",""],[1,"language-typescript"],[1,"info"],["routerLink","/graphql/cli-plugin"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/"],["routerLink","/graphql/scalars"],["appa1a02f370170c8e91a09f6f31e2cddfc29b81853",""],["appAnchor","","id","code-first-resolver"],["appf2fe31724b4768f2513d41f2b6f10569dbc9ec34",""],["href","/graphql/resolvers#module"],[1,"warning"],["routerLink","/recipes/crud-generator"],["appAnchor","","id","query-type-names"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/queries/"],["appe2508f5861373dc58f00fb322faa59c319b2d9a2",""],["appAnchor","","id","query-decorator-options"],["appAnchor","","id","args-decorator-options"],["href","/controllers#route-parameters"],["appAnchor","","id","dedicated-arguments-class"],["app09eb075b845c7ed9340763fc02285de9cf1a4b1e",""],["routerLink","/techniques/validation"],["appAnchor","","id","class-inheritance"],["appAnchor","","id","generics"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/pagination/#pagination-and-edges"],["appAnchor","","id","schema-first"],["routerLink","/graphql/quick-start"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/#type-language"],["appAnchor","","id","schema-first-resolver"],["app2eefa229539d90551b0618044d9279c030989312",""],["appc36027d9f3d9e445461c5b147c520d8948cde403",""],["appAnchor","","id","generating-types"],["appd84b26874a8ac2c1bade6ff0c296f3e2a82f4fa6",""],["routerLink","/pipes"],["appAnchor","","id","graphql-argument-decorators"],["appAnchor","","id","module"],["appef0510fee8fd105026aed09979977a4a930fa73d",""],["routerLink","/cli/overview"]],template:function(o,r){if(1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Resolvers"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"Resolvers provide the instructions for turning a "),e.TgZ(9,"a",6),e._uU(10,"GraphQL"),e.qZA(),e._uU(11," operation (a query, mutation, or subscription) into data. They return the same shape of data we specify in our schema -- either synchronously or as a promise that resolves to a result of that shape. Typically, you create a "),e.TgZ(12,"strong"),e._uU(13,"resolver map"),e.qZA(),e._uU(14," manually. The "),e.TgZ(15,"code"),e._uU(16,"@nestjs/graphql"),e.qZA(),e._uU(17," package, on the other hand, generates a resolver map automatically using the metadata provided by decorators you use to annotate classes. To demonstrate the process of using the package features to create a GraphQL API, we'll create a simple authors API."),e.qZA(),e.TgZ(18,"h4",7)(19,"span"),e._uU(20,"Code first"),e.qZA()(),e.TgZ(21,"p"),e._uU(22,"In the code first approach, we don't follow the typical process of creating our GraphQL schema by writing GraphQL SDL by hand. Instead, we use TypeScript decorators to generate the SDL from TypeScript class definitions. The "),e.TgZ(23,"code"),e._uU(24,"@nestjs/graphql"),e.qZA(),e._uU(25," package reads the metadata defined through the decorators and automatically generates the schema for you."),e.qZA(),e.TgZ(26,"h4",8)(27,"span"),e._uU(28,"Object types"),e.qZA()(),e.TgZ(29,"p"),e._uU(30,"Most of the definitions in a GraphQL schema are "),e.TgZ(31,"strong"),e._uU(32,"object types"),e.qZA(),e._uU(33,". Each object type you define should represent a domain object that an application client might need to interact with. For example, our sample API needs to be able to fetch a list of authors and their posts, so we should define the "),e.TgZ(34,"code"),e._uU(35,"Author"),e.qZA(),e._uU(36," type and "),e.TgZ(37,"code"),e._uU(38,"Post"),e.qZA(),e._uU(39," type to support this functionality."),e.qZA(),e.TgZ(40,"p"),e._uU(41,"If we were using the schema first approach, we'd define such a schema with SDL like this:"),e.qZA(),e.TgZ(42,"pre")(43,"code",9),e._uU(44,"\ntype Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post!]!\n}\n"),e.qZA()(),e.TgZ(45,"p"),e._uU(46,"In this case, using the code first approach, we define schemas using TypeScript classes and using TypeScript decorators to annotate the fields of those classes. The equivalent of the above SDL in the code first approach is:"),e.qZA(),e.TgZ(47,"span",10),e._uU(48),e.ALo(49,"extension"),e._UZ(50,"app-tabs",null,11),e.qZA(),e.TgZ(52,"pre")(53,"code",12),e._uU(54,"\nimport { Field, Int, ObjectType } from '@nestjs/graphql';\nimport { Post } from './post';\n\n@ObjectType()\nexport class Author {\n  @Field(type => Int)\n  id: number;\n\n  @Field({ nullable: true })\n  firstName?: string;\n\n  @Field({ nullable: true })\n  lastName?: string;\n\n  @Field(type => [Post])\n  posts: Post[];\n}\n"),e.qZA()(),e.TgZ(55,"blockquote",13)(56,"strong"),e._uU(57,"Hint"),e.qZA(),e._uU(58," TypeScript's metadata reflection system has several limitations which make it impossible, for instance, to determine what properties a class consists of or recognize whether a given property is optional or required. Because of these limitations, we must either explicitly use the "),e.TgZ(59,"code"),e._uU(60,"@Field()"),e.qZA(),e._uU(61," decorator in our schema definition classes to provide metadata about each field's GraphQL type and optionality, or use a "),e.TgZ(62,"a",14),e._uU(63,"CLI plugin"),e.qZA(),e._uU(64," to generate these for us.\n"),e.qZA(),e.TgZ(65,"p"),e._uU(66,"The "),e.TgZ(67,"code"),e._uU(68,"Author"),e.qZA(),e._uU(69," object type, like any class, is made of a collection of fields, with each field declaring a type. A field's type corresponds to a "),e.TgZ(70,"a",15),e._uU(71,"GraphQL type"),e.qZA(),e._uU(72,". A field's GraphQL type can be either another object type or a scalar type. A GraphQL scalar type is a primitive (like "),e.TgZ(73,"code"),e._uU(74,"ID"),e.qZA(),e._uU(75,", "),e.TgZ(76,"code"),e._uU(77,"String"),e.qZA(),e._uU(78,", "),e.TgZ(79,"code"),e._uU(80,"Boolean"),e.qZA(),e._uU(81,", or "),e.TgZ(82,"code"),e._uU(83,"Int"),e.qZA(),e._uU(84,") that resolves to a single value."),e.qZA(),e.TgZ(85,"blockquote",13)(86,"strong"),e._uU(87,"Hint"),e.qZA(),e._uU(88," In addition to GraphQL's built-in scalar types, you can define custom scalar types (read "),e.TgZ(89,"a",16),e._uU(90,"more"),e.qZA(),e._uU(91,").\n"),e.qZA(),e.TgZ(92,"p"),e._uU(93,"The above "),e.TgZ(94,"code"),e._uU(95,"Author"),e.qZA(),e._uU(96," object type definition will cause Nest to "),e.TgZ(97,"strong"),e._uU(98,"generate"),e.qZA(),e._uU(99," the SDL we showed above:"),e.qZA(),e.TgZ(100,"pre")(101,"code",9),e._uU(102,"\ntype Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post!]!\n}\n"),e.qZA()(),e.TgZ(103,"p"),e._uU(104,"The "),e.TgZ(105,"code"),e._uU(106,"@Field()"),e.qZA(),e._uU(107," decorator accepts an optional type function (e.g., "),e.TgZ(108,"code"),e._uU(109,"type => Int"),e.qZA(),e._uU(110,"), and optionally an options object."),e.qZA(),e.TgZ(111,"p"),e._uU(112,"The type function is required when there's the potential for ambiguity between the TypeScript type system and the GraphQL type system. Specifically: it is "),e.TgZ(113,"strong"),e._uU(114,"not"),e.qZA(),e._uU(115," required for "),e.TgZ(116,"code"),e._uU(117,"string"),e.qZA(),e._uU(118," and "),e.TgZ(119,"code"),e._uU(120,"boolean"),e.qZA(),e._uU(121," types; it "),e.TgZ(122,"strong"),e._uU(123,"is"),e.qZA(),e._uU(124," required for "),e.TgZ(125,"code"),e._uU(126,"number"),e.qZA(),e._uU(127," (which must be mapped to either a GraphQL "),e.TgZ(128,"code"),e._uU(129,"Int"),e.qZA(),e._uU(130," or "),e.TgZ(131,"code"),e._uU(132,"Float"),e.qZA(),e._uU(133,"). The type function should simply return the desired GraphQL type (as shown in various examples in these chapters)."),e.qZA(),e.TgZ(134,"p"),e._uU(135,"The options object can have any of the following key/value pairs:"),e.qZA(),e.TgZ(136,"ul")(137,"li")(138,"code"),e._uU(139,"nullable"),e.qZA(),e._uU(140,": for specifying whether a field is nullable (in SDL, each field is non-nullable by default); "),e.TgZ(141,"code"),e._uU(142,"boolean"),e.qZA()(),e.TgZ(143,"li")(144,"code"),e._uU(145,"description"),e.qZA(),e._uU(146,": for setting a field description; "),e.TgZ(147,"code"),e._uU(148,"string"),e.qZA()(),e.TgZ(149,"li")(150,"code"),e._uU(151,"deprecationReason"),e.qZA(),e._uU(152,": for marking a field as deprecated; "),e.TgZ(153,"code"),e._uU(154,"string"),e.qZA()()(),e.TgZ(155,"p"),e._uU(156,"For example:"),e.qZA(),e.TgZ(157,"pre")(158,"code",12),e._uU(159,"\n@Field({ description: `Book title`, deprecationReason: 'Not useful in v2 schema' })\ntitle: string;\n"),e.qZA()(),e.TgZ(160,"blockquote",13)(161,"strong"),e._uU(162,"Hint"),e.qZA(),e._uU(163," You can also add a description to, or deprecate, the whole object type: "),e.TgZ(164,"code"),e._uU(165),e.qZA(),e._uU(166,".\n"),e.qZA(),e.TgZ(167,"p"),e._uU(168,"When the field is an array, we must manually indicate the array type in the "),e.TgZ(169,"code"),e._uU(170,"Field()"),e.qZA(),e._uU(171," decorator's type function, as shown below:"),e.qZA(),e.TgZ(172,"pre")(173,"code",12),e._uU(174,"\n@Field(type => [Post])\nposts: Post[];\n"),e.qZA()(),e.TgZ(175,"blockquote",13)(176,"strong"),e._uU(177,"Hint"),e.qZA(),e._uU(178," Using array bracket notation ("),e.TgZ(179,"code"),e._uU(180,"[ ]"),e.qZA(),e._uU(181,"), we can indicate the depth of the array. For example, using "),e.TgZ(182,"code"),e._uU(183,"[[Int]]"),e.qZA(),e._uU(184," would represent an integer matrix.\n"),e.qZA(),e.TgZ(185,"p"),e._uU(186,"To declare that an array's items (not the array itself) are nullable, set the "),e.TgZ(187,"code"),e._uU(188,"nullable"),e.qZA(),e._uU(189," property to "),e.TgZ(190,"code"),e._uU(191,"'items'"),e.qZA(),e._uU(192," as shown below:"),e.qZA(),e.TgZ(193,"pre")(194,"code",12),e._uU(195,"\n@Field(type => [Post], { nullable: 'items' })\nposts: Post[];\n"),e.qZA()(),e.TgZ(196,"blockquote",13)(197,"strong"),e._uU(198,"Hint"),e.qZA(),e._uU(199," If both the array and its items are nullable, set "),e.TgZ(200,"code"),e._uU(201,"nullable"),e.qZA(),e._uU(202," to "),e.TgZ(203,"code"),e._uU(204,"'itemsAndList'"),e.qZA(),e._uU(205," instead.\n"),e.qZA(),e.TgZ(206,"p"),e._uU(207,"Now that the "),e.TgZ(208,"code"),e._uU(209,"Author"),e.qZA(),e._uU(210," object type is created, let's define the "),e.TgZ(211,"code"),e._uU(212,"Post"),e.qZA(),e._uU(213," object type."),e.qZA(),e.TgZ(214,"span",10),e._uU(215),e.ALo(216,"extension"),e._UZ(217,"app-tabs",null,17),e.qZA(),e.TgZ(219,"pre")(220,"code",12),e._uU(221,"\nimport { Field, Int, ObjectType } from '@nestjs/graphql';\n\n@ObjectType()\nexport class Post {\n  @Field(type => Int)\n  id: number;\n\n  @Field()\n  title: string;\n\n  @Field(type => Int, { nullable: true })\n  votes?: number;\n}\n"),e.qZA()(),e.TgZ(222,"p"),e._uU(223,"The "),e.TgZ(224,"code"),e._uU(225,"Post"),e.qZA(),e._uU(226," object type will result in generating the following part of the GraphQL schema in SDL:"),e.qZA(),e.TgZ(227,"pre")(228,"code",9),e._uU(229,"\ntype Post {\n  id: Int!\n  title: String!\n  votes: Int\n}\n"),e.qZA()(),e.TgZ(230,"h4",18)(231,"span"),e._uU(232,"Code first resolver"),e.qZA()(),e.TgZ(233,"p"),e._uU(234,"At this point, we've defined the objects (type definitions) that can exist in our data graph, but clients don't yet have a way to interact with those objects. To address that, we need to create a resolver class. In the code first method, a resolver class both defines resolver functions "),e.TgZ(235,"strong"),e._uU(236,"and"),e.qZA(),e._uU(237," generates the "),e.TgZ(238,"strong"),e._uU(239,"Query type"),e.qZA(),e._uU(240,". This will be clear as we work through the example below:"),e.qZA(),e.TgZ(241,"span",10),e._uU(242),e.ALo(243,"extension"),e._UZ(244,"app-tabs",null,19),e.qZA(),e.TgZ(246,"pre")(247,"code",12),e._uU(248,"\n@Resolver(of => Author)\nexport class AuthorsResolver {\n  constructor(\n    private authorsService: AuthorsService,\n    private postsService: PostsService,\n  ) {}\n\n  @Query(returns => Author)\n  async author(@Args('id', { type: () => Int }) id: number) {\n    return this.authorsService.findOneById(id);\n  }\n\n  @ResolveField()\n  async posts(@Parent() author: Author) {\n    const { id } = author;\n    return this.postsService.findAll({ authorId: id });\n  }\n}\n"),e.qZA()(),e.TgZ(249,"blockquote",13)(250,"strong"),e._uU(251,"Hint"),e.qZA(),e._uU(252," All decorators (e.g., "),e.TgZ(253,"code"),e._uU(254,"@Resolver"),e.qZA(),e._uU(255,", "),e.TgZ(256,"code"),e._uU(257,"@ResolveField"),e.qZA(),e._uU(258,", "),e.TgZ(259,"code"),e._uU(260,"@Args"),e.qZA(),e._uU(261,", etc.) are exported from the "),e.TgZ(262,"code"),e._uU(263,"@nestjs/graphql"),e.qZA(),e._uU(264," package.\n"),e.qZA(),e.TgZ(265,"p"),e._uU(266,"You can define multiple resolver classes. Nest will combine these at run time. See the "),e.TgZ(267,"a",20),e._uU(268,"module"),e.qZA(),e._uU(269," section below for more on code organization."),e.qZA(),e.TgZ(270,"blockquote",21)(271,"strong"),e._uU(272,"Note"),e.qZA(),e._uU(273," The logic inside the "),e.TgZ(274,"code"),e._uU(275,"AuthorsService"),e.qZA(),e._uU(276," and "),e.TgZ(277,"code"),e._uU(278,"PostsService"),e.qZA(),e._uU(279," classes can be as simple or sophisticated as needed. The main point of this example is to show how to construct resolvers and how they can interact with other providers.\n"),e.qZA(),e.TgZ(280,"p"),e._uU(281,"In the example above, we created the "),e.TgZ(282,"code"),e._uU(283,"AuthorsResolver"),e.qZA(),e._uU(284," which defines one query resolver function and one field resolver function. To create a resolver, we create a class with resolver functions as methods, and annotate the class with the "),e.TgZ(285,"code"),e._uU(286,"@Resolver()"),e.qZA(),e._uU(287," decorator."),e.qZA(),e.TgZ(288,"p"),e._uU(289,"In this example, we defined a query handler to get the author object based on the "),e.TgZ(290,"code"),e._uU(291,"id"),e.qZA(),e._uU(292," sent in the request. To specify that the method is a query handler, use the "),e.TgZ(293,"code"),e._uU(294,"@Query()"),e.qZA(),e._uU(295," decorator."),e.qZA(),e.TgZ(296,"p"),e._uU(297,"The argument passed to the "),e.TgZ(298,"code"),e._uU(299,"@Resolver()"),e.qZA(),e._uU(300," decorator is optional, but comes into play when our graph becomes non-trivial. It's used to supply a parent object used by field resolver functions as they traverse down through an object graph."),e.qZA(),e.TgZ(301,"p"),e._uU(302,"In our example, since the class includes a "),e.TgZ(303,"strong"),e._uU(304,"field resolver"),e.qZA(),e._uU(305," function (for the "),e.TgZ(306,"code"),e._uU(307,"posts"),e.qZA(),e._uU(308," property of the "),e.TgZ(309,"code"),e._uU(310,"Author"),e.qZA(),e._uU(311," object type), we "),e.TgZ(312,"strong"),e._uU(313,"must"),e.qZA(),e._uU(314," supply the "),e.TgZ(315,"code"),e._uU(316,"@Resolver()"),e.qZA(),e._uU(317," decorator with a value to indicate which class is the parent type (i.e., the corresponding "),e.TgZ(318,"code"),e._uU(319,"ObjectType"),e.qZA(),e._uU(320," class name) for all field resolvers defined within this class. As should be clear from the example, when writing a field resolver function, it's necessary to access the parent object (the object the field being resolved is a member of). In this example, we populate an author's posts array with a field resolver that calls a service which takes the author's "),e.TgZ(321,"code"),e._uU(322,"id"),e.qZA(),e._uU(323," as an argument. Hence the need to identify the parent object in the "),e.TgZ(324,"code"),e._uU(325,"@Resolver()"),e.qZA(),e._uU(326," decorator. Note the corresponding use of the "),e.TgZ(327,"code"),e._uU(328,"@Parent()"),e.qZA(),e._uU(329," method parameter decorator to then extract a reference to that parent object in the field resolver."),e.qZA(),e.TgZ(330,"p"),e._uU(331,"We can define multiple "),e.TgZ(332,"code"),e._uU(333,"@Query()"),e.qZA(),e._uU(334," resolver functions (both within this class, and in any other resolver class), and they will be aggregated into a single "),e.TgZ(335,"strong"),e._uU(336,"Query type"),e.qZA(),e._uU(337," definition in the generated SDL along with the appropriate entries in the resolver map. This allows you to define queries close to the models and services that they use, and to keep them well organized in modules."),e.qZA(),e.TgZ(338,"blockquote",13)(339,"strong"),e._uU(340,"Hint"),e.qZA(),e._uU(341," Nest CLI provides a generator (schematic) that automatically generates "),e.TgZ(342,"strong"),e._uU(343,"all the boilerplate code"),e.qZA(),e._uU(344," to help us avoid doing all of this, and make the developer experience much simpler. Read more about this feature "),e.TgZ(345,"a",22),e._uU(346,"here"),e.qZA(),e._uU(347,".\n"),e.qZA(),e.TgZ(348,"h4",23)(349,"span"),e._uU(350,"Query type names"),e.qZA()(),e.TgZ(351,"p"),e._uU(352,"In the above examples, the "),e.TgZ(353,"code"),e._uU(354,"@Query()"),e.qZA(),e._uU(355," decorator generates a GraphQL schema query type name based on the method name. For example, consider the following construction from the example above:"),e.qZA(),e.TgZ(356,"pre")(357,"code",12),e._uU(358,"\n@Query(returns => Author)\nasync author(@Args('id', { type: () => Int }) id: number) {\n  return this.authorsService.findOneById(id);\n}\n"),e.qZA()(),e.TgZ(359,"p"),e._uU(360,"This generates the following entry for the author query in our schema (the query type uses the same name as the method name):"),e.qZA(),e.TgZ(361,"pre")(362,"code",9),e._uU(363,"\ntype Query {\n  author(id: Int!): Author\n}\n"),e.qZA()(),e.TgZ(364,"blockquote",13)(365,"strong"),e._uU(366,"Hint"),e.qZA(),e._uU(367," Learn more about GraphQL queries "),e.TgZ(368,"a",24),e._uU(369,"here"),e.qZA(),e._uU(370,".\n"),e.qZA(),e.TgZ(371,"p"),e._uU(372,"Conventionally, we prefer to decouple these names; for example, we prefer to use a name like "),e.TgZ(373,"code"),e._uU(374,"getAuthor()"),e.qZA(),e._uU(375," for our query handler method, but still use "),e.TgZ(376,"code"),e._uU(377,"author"),e.qZA(),e._uU(378," for our query type name. The same applies to our field resolvers. We can easily do this by passing the mapping names as arguments of the "),e.TgZ(379,"code"),e._uU(380,"@Query()"),e.qZA(),e._uU(381," and "),e.TgZ(382,"code"),e._uU(383,"@ResolveField()"),e.qZA(),e._uU(384," decorators, as shown below:"),e.qZA(),e.TgZ(385,"span",10),e._uU(386),e.ALo(387,"extension"),e._UZ(388,"app-tabs",null,25),e.qZA(),e.TgZ(390,"pre")(391,"code",12),e._uU(392,"\n@Resolver(of => Author)\nexport class AuthorsResolver {\n  constructor(\n    private authorsService: AuthorsService,\n    private postsService: PostsService,\n  ) {}\n\n  @Query(returns => Author, { name: 'author' })\n  async getAuthor(@Args('id', { type: () => Int }) id: number) {\n    return this.authorsService.findOneById(id);\n  }\n\n  @ResolveField('posts', returns => [Post])\n  async getPosts(@Parent() author: Author) {\n    const { id } = author;\n    return this.postsService.findAll({ authorId: id });\n  }\n}\n"),e.qZA()(),e.TgZ(393,"p"),e._uU(394,"The "),e.TgZ(395,"code"),e._uU(396,"getAuthor"),e.qZA(),e._uU(397," handler method above will result in generating the following part of the GraphQL schema in SDL:"),e.qZA(),e.TgZ(398,"pre")(399,"code",9),e._uU(400,"\ntype Query {\n  author(id: Int!): Author\n}\n"),e.qZA()(),e.TgZ(401,"h4",26)(402,"span"),e._uU(403,"Query decorator options"),e.qZA()(),e.TgZ(404,"p"),e._uU(405,"The "),e.TgZ(406,"code"),e._uU(407,"@Query()"),e.qZA(),e._uU(408," decorator's options object (where we pass "),e.TgZ(409,"code"),e._uU(410),e.qZA(),e._uU(411," above) accepts a number of key/value pairs:"),e.qZA(),e.TgZ(412,"ul")(413,"li")(414,"code"),e._uU(415,"name"),e.qZA(),e._uU(416,": name of the query; a "),e.TgZ(417,"code"),e._uU(418,"string"),e.qZA()(),e.TgZ(419,"li")(420,"code"),e._uU(421,"description"),e.qZA(),e._uU(422,": a description that will be used to generate GraphQL schema documentation (e.g., in GraphQL playground); a "),e.TgZ(423,"code"),e._uU(424,"string"),e.qZA()(),e.TgZ(425,"li")(426,"code"),e._uU(427,"deprecationReason"),e.qZA(),e._uU(428,": sets query metadata to show the query as deprecated (e.g., in GraphQL playground); a "),e.TgZ(429,"code"),e._uU(430,"string"),e.qZA()(),e.TgZ(431,"li")(432,"code"),e._uU(433,"nullable"),e.qZA(),e._uU(434,": whether the query can return a null data response; "),e.TgZ(435,"code"),e._uU(436,"boolean"),e.qZA(),e._uU(437," or "),e.TgZ(438,"code"),e._uU(439,"'items'"),e.qZA(),e._uU(440," or "),e.TgZ(441,"code"),e._uU(442,"'itemsAndList'"),e.qZA(),e._uU(443," (see above for details of "),e.TgZ(444,"code"),e._uU(445,"'items'"),e.qZA(),e._uU(446," and "),e.TgZ(447,"code"),e._uU(448,"'itemsAndList'"),e.qZA(),e._uU(449,")"),e.qZA()(),e.TgZ(450,"h4",27)(451,"span"),e._uU(452,"Args decorator options"),e.qZA()(),e.TgZ(453,"p"),e._uU(454,"Use the "),e.TgZ(455,"code"),e._uU(456,"@Args()"),e.qZA(),e._uU(457," decorator to extract arguments from a request for use in the method handler. This works in a very similar fashion to "),e.TgZ(458,"a",28),e._uU(459,"REST route parameter argument extraction"),e.qZA(),e._uU(460,"."),e.qZA(),e.TgZ(461,"p"),e._uU(462,"Usually your "),e.TgZ(463,"code"),e._uU(464,"@Args()"),e.qZA(),e._uU(465," decorator will be simple, and not require an object argument as seen with the "),e.TgZ(466,"code"),e._uU(467,"getAuthor()"),e.qZA(),e._uU(468," method above. For example, if the type of an identifier is string, the following construction is sufficient, and simply plucks the named field from the inbound GraphQL request for use as a method argument."),e.qZA(),e.TgZ(469,"pre")(470,"code",12),e._uU(471,"\n@Args('id') id: string\n"),e.qZA()(),e.TgZ(472,"p"),e._uU(473,"In the "),e.TgZ(474,"code"),e._uU(475,"getAuthor()"),e.qZA(),e._uU(476," case, the "),e.TgZ(477,"code"),e._uU(478,"number"),e.qZA(),e._uU(479," type is used, which presents a challenge. The "),e.TgZ(480,"code"),e._uU(481,"number"),e.qZA(),e._uU(482," TypeScript type doesn't give us enough information about the expected GraphQL representation (e.g., "),e.TgZ(483,"code"),e._uU(484,"Int"),e.qZA(),e._uU(485," vs. "),e.TgZ(486,"code"),e._uU(487,"Float"),e.qZA(),e._uU(488,"). Thus we have to "),e.TgZ(489,"strong"),e._uU(490,"explicitly"),e.qZA(),e._uU(491," pass the type reference. We do that by passing a second argument to the "),e.TgZ(492,"code"),e._uU(493,"Args()"),e.qZA(),e._uU(494," decorator, containing argument options, as shown below:"),e.qZA(),e.TgZ(495,"pre")(496,"code",12),e._uU(497,"\n@Query(returns => Author, { name: 'author' })\nasync getAuthor(@Args('id', { type: () => Int }) id: number) {\n  return this.authorsService.findOneById(id);\n}\n"),e.qZA()(),e.TgZ(498,"p"),e._uU(499,"The options object allows us to specify the following optional key value pairs:"),e.qZA(),e.TgZ(500,"ul")(501,"li")(502,"code"),e._uU(503,"type"),e.qZA(),e._uU(504,": a function returning the GraphQL type"),e.qZA(),e.TgZ(505,"li")(506,"code"),e._uU(507,"defaultValue"),e.qZA(),e._uU(508,": a default value; "),e.TgZ(509,"code"),e._uU(510,"any"),e.qZA()(),e.TgZ(511,"li")(512,"code"),e._uU(513,"description"),e.qZA(),e._uU(514,": description metadata; "),e.TgZ(515,"code"),e._uU(516,"string"),e.qZA()(),e.TgZ(517,"li")(518,"code"),e._uU(519,"deprecationReason"),e.qZA(),e._uU(520,": to deprecate a field and provide meta data describing why; "),e.TgZ(521,"code"),e._uU(522,"string"),e.qZA()(),e.TgZ(523,"li")(524,"code"),e._uU(525,"nullable"),e.qZA(),e._uU(526,": whether the field is nullable"),e.qZA()(),e.TgZ(527,"p"),e._uU(528,"Query handler methods can take multiple arguments. Let's imagine that we want to fetch an author based on its "),e.TgZ(529,"code"),e._uU(530,"firstName"),e.qZA(),e._uU(531," and "),e.TgZ(532,"code"),e._uU(533,"lastName"),e.qZA(),e._uU(534,". In this case, we can call "),e.TgZ(535,"code"),e._uU(536,"@Args"),e.qZA(),e._uU(537," twice:"),e.qZA(),e.TgZ(538,"pre")(539,"code",12),e._uU(540,"\ngetAuthor(\n  @Args('firstName', { nullable: true }) firstName?: string,\n  @Args('lastName', { defaultValue: '' }) lastName?: string,\n) {}\n"),e.qZA()(),e.TgZ(541,"h4",29)(542,"span"),e._uU(543,"Dedicated arguments class"),e.qZA()(),e.TgZ(544,"p"),e._uU(545,"With inline "),e.TgZ(546,"code"),e._uU(547,"@Args()"),e.qZA(),e._uU(548," calls, code like the example above becomes bloated. Instead, you can create a dedicated "),e.TgZ(549,"code"),e._uU(550,"GetAuthorArgs"),e.qZA(),e._uU(551," arguments class and access it in the handler method as follows:"),e.qZA(),e.TgZ(552,"pre")(553,"code",12),e._uU(554,"\n@Args() args: GetAuthorArgs\n"),e.qZA()(),e.TgZ(555,"p"),e._uU(556,"Create the "),e.TgZ(557,"code"),e._uU(558,"GetAuthorArgs"),e.qZA(),e._uU(559," class using "),e.TgZ(560,"code"),e._uU(561,"@ArgsType()"),e.qZA(),e._uU(562," as shown below:"),e.qZA(),e.TgZ(563,"span",10),e._uU(564),e.ALo(565,"extension"),e._UZ(566,"app-tabs",null,30),e.qZA(),e.TgZ(568,"pre")(569,"code",12),e._uU(570,"\nimport { MinLength } from 'class-validator';\nimport { Field, ArgsType } from '@nestjs/graphql';\n\n@ArgsType()\nclass GetAuthorArgs {\n  @Field({ nullable: true })\n  firstName?: string;\n\n  @Field({ defaultValue: '' })\n  @MinLength(3)\n  lastName: string;\n}\n"),e.qZA()(),e.TgZ(571,"blockquote",13)(572,"strong"),e._uU(573,"Hint"),e.qZA(),e._uU(574," Again, due to TypeScript's metadata reflection system limitations, it's required to either use the "),e.TgZ(575,"code"),e._uU(576,"@Field"),e.qZA(),e._uU(577," decorator to manually indicate type and optionality, or use a "),e.TgZ(578,"a",14),e._uU(579,"CLI plugin"),e.qZA(),e._uU(580,".\n"),e.qZA(),e.TgZ(581,"p"),e._uU(582,"This will result in generating the following part of the GraphQL schema in SDL:"),e.qZA(),e.TgZ(583,"pre")(584,"code",9),e._uU(585,"\ntype Query {\n  author(firstName: String, lastName: String = ''): Author\n}\n"),e.qZA()(),e.TgZ(586,"blockquote",13)(587,"strong"),e._uU(588,"Hint"),e.qZA(),e._uU(589," Note that arguments classes like "),e.TgZ(590,"code"),e._uU(591,"GetAuthorArgs"),e.qZA(),e._uU(592," play very well with the "),e.TgZ(593,"code"),e._uU(594,"ValidationPipe"),e.qZA(),e._uU(595," (read "),e.TgZ(596,"a",31),e._uU(597,"more"),e.qZA(),e._uU(598,").\n"),e.qZA(),e.TgZ(599,"h4",32)(600,"span"),e._uU(601,"Class inheritance"),e.qZA()(),e.TgZ(602,"p"),e._uU(603,"You can use standard TypeScript class inheritance to create base classes with generic utility type features (fields and field properties, validations, etc.) that can be extended. For example, you may have a set of pagination related arguments that always include the standard "),e.TgZ(604,"code"),e._uU(605,"offset"),e.qZA(),e._uU(606," and "),e.TgZ(607,"code"),e._uU(608,"limit"),e.qZA(),e._uU(609," fields, but also other index fields that are type-specific. You can set up a class hierarchy as shown below."),e.qZA(),e.TgZ(610,"p"),e._uU(611,"Base "),e.TgZ(612,"code"),e._uU(613,"@ArgsType()"),e.qZA(),e._uU(614," class:"),e.qZA(),e.TgZ(615,"pre")(616,"code",12),e._uU(617,"\n@ArgsType()\nclass PaginationArgs {\n  @Field((type) => Int)\n  offset: number = 0;\n\n  @Field((type) => Int)\n  limit: number = 10;\n}\n"),e.qZA()(),e.TgZ(618,"p"),e._uU(619,"Type specific sub-class of the base "),e.TgZ(620,"code"),e._uU(621,"@ArgsType()"),e.qZA(),e._uU(622," class:"),e.qZA(),e.TgZ(623,"pre")(624,"code",12),e._uU(625,"\n@ArgsType()\nclass GetAuthorArgs extends PaginationArgs {\n  @Field({ nullable: true })\n  firstName?: string;\n\n  @Field({ defaultValue: '' })\n  @MinLength(3)\n  lastName: string;\n}\n"),e.qZA()(),e.TgZ(626,"p"),e._uU(627,"The same approach can be taken with "),e.TgZ(628,"code"),e._uU(629,"@ObjectType()"),e.qZA(),e._uU(630," objects. Define generic properties on the base class:"),e.qZA(),e.TgZ(631,"pre")(632,"code",12),e._uU(633,"\n@ObjectType()\nclass Character {\n  @Field((type) => Int)\n  id: number;\n\n  @Field()\n  name: string;\n}\n"),e.qZA()(),e.TgZ(634,"p"),e._uU(635,"Add type-specific properties on sub-classes:"),e.qZA(),e.TgZ(636,"pre")(637,"code",12),e._uU(638,"\n@ObjectType()\nclass Warrior extends Character {\n  @Field()\n  level: number;\n}\n"),e.qZA()(),e.TgZ(639,"p"),e._uU(640,"You can use inheritance with a resolver as well. You can ensure type safety by combining inheritance and TypeScript generics. For example, to create a base class with a generic "),e.TgZ(641,"code"),e._uU(642,"findAll"),e.qZA(),e._uU(643," query, use a construction like this:"),e.qZA(),e.TgZ(644,"pre")(645,"code",12),e._uU(646,"\nfunction BaseResolver<T extends Type<unknown>>(classRef: T): any {\n  @Resolver({ isAbstract: true })\n  abstract class BaseResolverHost {\n    @Query((type) => [classRef], { name: `findAll${classRef.name}` })\n    async findAll(): Promise<T[]> {\n      return [];\n    }\n  }\n  return BaseResolverHost;\n}\n"),e.qZA()(),e.TgZ(647,"p"),e._uU(648,"Note the following:"),e.qZA(),e.TgZ(649,"ul")(650,"li"),e._uU(651,"an explicit return type ("),e.TgZ(652,"code"),e._uU(653,"any"),e.qZA(),e._uU(654," above) is required: otherwise TypeScript complains about the usage of a private class definition. Recommended: define an interface instead of using "),e.TgZ(655,"code"),e._uU(656,"any"),e.qZA(),e._uU(657,"."),e.qZA(),e.TgZ(658,"li")(659,"code"),e._uU(660,"Type"),e.qZA(),e._uU(661," is imported from the "),e.TgZ(662,"code"),e._uU(663,"@nestjs/common"),e.qZA(),e._uU(664," package"),e.qZA(),e.TgZ(665,"li"),e._uU(666,"The "),e.TgZ(667,"code"),e._uU(668,"isAbstract: true"),e.qZA(),e._uU(669," property indicates that SDL (Schema Definition Language statements) shouldn't be generated for this class. Note, you can set this property for other types as well to suppress SDL generation."),e.qZA()(),e.TgZ(670,"p"),e._uU(671,"Here's how you could generate a concrete sub-class of the "),e.TgZ(672,"code"),e._uU(673,"BaseResolver"),e.qZA(),e._uU(674,":"),e.qZA(),e.TgZ(675,"pre")(676,"code",12),e._uU(677,"\n@Resolver((of) => Recipe)\nexport class RecipesResolver extends BaseResolver(Recipe) {\n  constructor(private recipesService: RecipesService) {\n    super();\n  }\n}\n"),e.qZA()(),e.TgZ(678,"p"),e._uU(679,"This construct would generated the following SDL:"),e.qZA(),e.TgZ(680,"pre")(681,"code",9),e._uU(682,"\ntype Query {\n  findAllRecipe: [Recipe!]!\n}\n"),e.qZA()(),e.TgZ(683,"h4",33)(684,"span"),e._uU(685,"Generics"),e.qZA()(),e.TgZ(686,"p"),e._uU(687,"We saw one use of generics above. This powerful TypeScript feature can be used to create useful abstractions. For example, here's a sample cursor-based pagination implementation based on "),e.TgZ(688,"a",34),e._uU(689,"this documentation"),e.qZA(),e._uU(690,":"),e.qZA(),e.TgZ(691,"pre")(692,"code",12),e._uU(693,"\nimport { Field, ObjectType, Int } from '@nestjs/graphql';\nimport { Type } from '@nestjs/common';\n\ninterface IEdgeType<T> {\n  cursor: string;\n  node: T;\n}\n\nexport interface IPaginatedType<T> {\n  edges: IEdgeType<T>[];\n  nodes: T[];\n  totalCount: number;\n  hasNextPage: boolean;\n}\n\nexport function Paginated<T>(classRef: Type<T>): Type<IPaginatedType<T>> {\n  @ObjectType(`${classRef.name}Edge`)\n  abstract class EdgeType {\n    @Field((type) => String)\n    cursor: string;\n\n    @Field((type) => classRef)\n    node: T;\n  }\n\n  @ObjectType({ isAbstract: true })\n  abstract class PaginatedType implements IPaginatedType<T> {\n    @Field((type) => [EdgeType], { nullable: true })\n    edges: EdgeType[];\n\n    @Field((type) => [classRef], { nullable: true })\n    nodes: T[];\n\n    @Field((type) => Int)\n    totalCount: number;\n\n    @Field()\n    hasNextPage: boolean;\n  }\n  return PaginatedType as Type<IPaginatedType<T>>;\n}\n"),e.qZA()(),e.TgZ(694,"p"),e._uU(695,"With the above base class defined, we can now easily create specialized types that inherit this behavior. For example:"),e.qZA(),e.TgZ(696,"pre")(697,"code",12),e._uU(698,"\n@ObjectType()\nclass PaginatedAuthor extends Paginated(Author) {}\n"),e.qZA()(),e.TgZ(699,"h4",35)(700,"span"),e._uU(701,"Schema first"),e.qZA()(),e.TgZ(702,"p"),e._uU(703,"As mentioned in the "),e.TgZ(704,"a",36),e._uU(705,"previous"),e.qZA(),e._uU(706," chapter, in the schema first approach we start by manually defining schema types in SDL (read "),e.TgZ(707,"a",37),e._uU(708,"more"),e.qZA(),e._uU(709,"). Consider the following SDL type definitions."),e.qZA(),e.TgZ(710,"blockquote",13)(711,"strong"),e._uU(712,"Hint"),e.qZA(),e._uU(713," For convenience in this chapter, we've aggregated all of the SDL in one location (e.g., one "),e.TgZ(714,"code"),e._uU(715,".graphql"),e.qZA(),e._uU(716," file, as shown below). In practice, you may find it appropriate to organize your code in a modular fashion. For example, it can be helpful to create individual SDL files with type definitions representing each domain entity, along with related services, resolver code, and the Nest module definition class, in a dedicated directory for that entity. Nest will aggregate all the individual schema type definitions at run time.\n"),e.qZA(),e.TgZ(717,"pre")(718,"code",9),e._uU(719,"\ntype Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post]\n}\n\ntype Post {\n  id: Int!\n  title: String!\n  votes: Int\n}\n\ntype Query {\n  author(id: Int!): Author\n}\n"),e.qZA()(),e.TgZ(720,"h4",38)(721,"span"),e._uU(722,"Schema first resolver"),e.qZA()(),e.TgZ(723,"p"),e._uU(724,"The schema above exposes a single query - "),e.TgZ(725,"code"),e._uU(726,"author(id: Int!): Author"),e.qZA(),e._uU(727,"."),e.qZA(),e.TgZ(728,"blockquote",13)(729,"strong"),e._uU(730,"Hint"),e.qZA(),e._uU(731," Learn more about GraphQL queries "),e.TgZ(732,"a",24),e._uU(733,"here"),e.qZA(),e._uU(734,".\n"),e.qZA(),e.TgZ(735,"p"),e._uU(736,"Let's now create an "),e.TgZ(737,"code"),e._uU(738,"AuthorsResolver"),e.qZA(),e._uU(739," class that resolves author queries:"),e.qZA(),e.TgZ(740,"span",10),e._uU(741),e.ALo(742,"extension"),e._UZ(743,"app-tabs",null,39),e.qZA(),e.TgZ(745,"pre")(746,"code",12),e._uU(747,"\n@Resolver('Author')\nexport class AuthorsResolver {\n  constructor(\n    private authorsService: AuthorsService,\n    private postsService: PostsService,\n  ) {}\n\n  @Query()\n  async author(@Args('id') id: number) {\n    return this.authorsService.findOneById(id);\n  }\n\n  @ResolveField()\n  async posts(@Parent() author) {\n    const { id } = author;\n    return this.postsService.findAll({ authorId: id });\n  }\n}\n"),e.qZA()(),e.TgZ(748,"blockquote",13)(749,"strong"),e._uU(750,"Hint"),e.qZA(),e._uU(751," All decorators (e.g., "),e.TgZ(752,"code"),e._uU(753,"@Resolver"),e.qZA(),e._uU(754,", "),e.TgZ(755,"code"),e._uU(756,"@ResolveField"),e.qZA(),e._uU(757,", "),e.TgZ(758,"code"),e._uU(759,"@Args"),e.qZA(),e._uU(760,", etc.) are exported from the "),e.TgZ(761,"code"),e._uU(762,"@nestjs/graphql"),e.qZA(),e._uU(763," package.\n"),e.qZA(),e.TgZ(764,"blockquote",21)(765,"strong"),e._uU(766,"Note"),e.qZA(),e._uU(767," The logic inside the "),e.TgZ(768,"code"),e._uU(769,"AuthorsService"),e.qZA(),e._uU(770," and "),e.TgZ(771,"code"),e._uU(772,"PostsService"),e.qZA(),e._uU(773," classes can be as simple or sophisticated as needed. The main point of this example is to show how to construct resolvers and how they can interact with other providers.\n"),e.qZA(),e.TgZ(774,"p"),e._uU(775,"The "),e.TgZ(776,"code"),e._uU(777,"@Resolver()"),e.qZA(),e._uU(778," decorator is required. It takes an optional string argument with the name of a class. This class name is required whenever the class includes "),e.TgZ(779,"code"),e._uU(780,"@ResolveField()"),e.qZA(),e._uU(781," decorators to inform Nest that the decorated method is associated with a parent type (the "),e.TgZ(782,"code"),e._uU(783,"Author"),e.qZA(),e._uU(784," type in our current example). Alternatively, instead of setting "),e.TgZ(785,"code"),e._uU(786,"@Resolver()"),e.qZA(),e._uU(787," at the top of the class, this can be done for each method:"),e.qZA(),e.TgZ(788,"pre")(789,"code",12),e._uU(790,"\n@Resolver('Author')\n@ResolveField()\nasync posts(@Parent() author) {\n  const { id } = author;\n  return this.postsService.findAll({ authorId: id });\n}\n"),e.qZA()(),e.TgZ(791,"p"),e._uU(792,"In this case ("),e.TgZ(793,"code"),e._uU(794,"@Resolver()"),e.qZA(),e._uU(795," decorator at the method level), if you have multiple "),e.TgZ(796,"code"),e._uU(797,"@ResolveField()"),e.qZA(),e._uU(798," decorators inside a class, you must add "),e.TgZ(799,"code"),e._uU(800,"@Resolver()"),e.qZA(),e._uU(801," to all of them. This is not considered the best practice (as it creates extra overhead)."),e.qZA(),e.TgZ(802,"blockquote",13)(803,"strong"),e._uU(804,"Hint"),e.qZA(),e._uU(805," Any class name argument passed to "),e.TgZ(806,"code"),e._uU(807,"@Resolver()"),e.qZA(),e.TgZ(808,"strong"),e._uU(809,"does not"),e.qZA(),e._uU(810," affect queries ("),e.TgZ(811,"code"),e._uU(812,"@Query()"),e.qZA(),e._uU(813," decorator) or mutations ("),e.TgZ(814,"code"),e._uU(815,"@Mutation()"),e.qZA(),e._uU(816," decorator).\n"),e.qZA(),e.TgZ(817,"blockquote",21)(818,"strong"),e._uU(819,"Warning"),e.qZA(),e._uU(820," Using the "),e.TgZ(821,"code"),e._uU(822,"@Resolver"),e.qZA(),e._uU(823," decorator at the method level is not supported with the "),e.TgZ(824,"strong"),e._uU(825,"code first"),e.qZA(),e._uU(826," approach.\n"),e.qZA(),e.TgZ(827,"p"),e._uU(828,"In the above examples, the "),e.TgZ(829,"code"),e._uU(830,"@Query()"),e.qZA(),e._uU(831," and "),e.TgZ(832,"code"),e._uU(833,"@ResolveField()"),e.qZA(),e._uU(834," decorators are associated with GraphQL schema types based on the method name. For example, consider the following construction from the example above:"),e.qZA(),e.TgZ(835,"pre")(836,"code",12),e._uU(837,"\n@Query()\nasync author(@Args('id') id: number) {\n  return this.authorsService.findOneById(id);\n}\n"),e.qZA()(),e.TgZ(838,"p"),e._uU(839,"This generates the following entry for the author query in our schema (the query type uses the same name as the method name):"),e.qZA(),e.TgZ(840,"pre")(841,"code",9),e._uU(842,"\ntype Query {\n  author(id: Int!): Author\n}\n"),e.qZA()(),e.TgZ(843,"p"),e._uU(844,"Conventionally, we would prefer to decouple these, using names like "),e.TgZ(845,"code"),e._uU(846,"getAuthor()"),e.qZA(),e._uU(847," or "),e.TgZ(848,"code"),e._uU(849,"getPosts()"),e.qZA(),e._uU(850," for our resolver methods. We can easily do this by passing the mapping name as an argument to the decorator, as shown below:"),e.qZA(),e.TgZ(851,"span",10),e._uU(852),e.ALo(853,"extension"),e._UZ(854,"app-tabs",null,40),e.qZA(),e.TgZ(856,"pre")(857,"code",12),e._uU(858,"\n@Resolver('Author')\nexport class AuthorsResolver {\n  constructor(\n    private authorsService: AuthorsService,\n    private postsService: PostsService,\n  ) {}\n\n  @Query('author')\n  async getAuthor(@Args('id') id: number) {\n    return this.authorsService.findOneById(id);\n  }\n\n  @ResolveField('posts')\n  async getPosts(@Parent() author) {\n    const { id } = author;\n    return this.postsService.findAll({ authorId: id });\n  }\n}\n"),e.qZA()(),e.TgZ(859,"blockquote",13)(860,"strong"),e._uU(861,"Hint"),e.qZA(),e._uU(862," Nest CLI provides a generator (schematic) that automatically generates "),e.TgZ(863,"strong"),e._uU(864,"all the boilerplate code"),e.qZA(),e._uU(865," to help us avoid doing all of this, and make the developer experience much simpler. Read more about this feature "),e.TgZ(866,"a",22),e._uU(867,"here"),e.qZA(),e._uU(868,".\n"),e.qZA(),e.TgZ(869,"h4",41)(870,"span"),e._uU(871,"Generating types"),e.qZA()(),e.TgZ(872,"p"),e._uU(873,"Assuming that we use the schema first approach and have enabled the typings generation feature (with "),e.TgZ(874,"code"),e._uU(875,"outputAs: 'class'"),e.qZA(),e._uU(876," as shown in the "),e.TgZ(877,"a",36),e._uU(878,"previous"),e.qZA(),e._uU(879," chapter), once you run the application it will generate the following file (in the location you specified in the "),e.TgZ(880,"code"),e._uU(881,"GraphQLModule.forRoot()"),e.qZA(),e._uU(882," method). For example, in "),e.TgZ(883,"code"),e._uU(884,"src/graphql.ts"),e.qZA(),e._uU(885,":"),e.qZA(),e.TgZ(886,"span",10),e._uU(887),e.ALo(888,"extension"),e._UZ(889,"app-tabs",null,42),e.qZA(),e.TgZ(891,"pre")(892,"code",12),e._uU(893,"\nexport class Author {\n  id: number;\n  firstName?: string;\n  lastName?: string;\n  posts?: Post[];\n}\n\nexport class Post {\n  id: number;\n  title: string;\n  votes?: number;\n}\n\nexport abstract class IQuery {\n  abstract author(id: number): Author | Promise<Author>;\n}\n"),e.qZA()(),e.TgZ(894,"p"),e._uU(895,"By generating classes (instead of the default technique of generating interfaces), you can use declarative validation "),e.TgZ(896,"strong"),e._uU(897,"decorators"),e.qZA(),e._uU(898," in combination with the schema first approach, which is an extremely useful technique (read "),e.TgZ(899,"a",31),e._uU(900,"more"),e.qZA(),e._uU(901,"). For example, you could add "),e.TgZ(902,"code"),e._uU(903,"class-validator"),e.qZA(),e._uU(904," decorators to the generated "),e.TgZ(905,"code"),e._uU(906,"CreatePostInput"),e.qZA(),e._uU(907," class as shown below to enforce minimum and maximum string lengths on the "),e.TgZ(908,"code"),e._uU(909,"title"),e.qZA(),e._uU(910," field:"),e.qZA(),e.TgZ(911,"pre")(912,"code",12),e._uU(913,"\nimport { MinLength, MaxLength } from 'class-validator';\n\nexport class CreatePostInput {\n  @MinLength(3)\n  @MaxLength(50)\n  title: string;\n}\n"),e.qZA()(),e.TgZ(914,"blockquote",21)(915,"strong"),e._uU(916,"Notice"),e.qZA(),e._uU(917," To enable auto-validation of your inputs (and parameters), use "),e.TgZ(918,"code"),e._uU(919,"ValidationPipe"),e.qZA(),e._uU(920,". Read more about validation "),e.TgZ(921,"a",31),e._uU(922,"here"),e.qZA(),e._uU(923," and more specifically about pipes "),e.TgZ(924,"a",43),e._uU(925,"here"),e.qZA(),e._uU(926,".\n"),e.qZA(),e.TgZ(927,"p"),e._uU(928,"However, if you add decorators directly to the automatically generated file, they will be "),e.TgZ(929,"strong"),e._uU(930,"overwritten"),e.qZA(),e._uU(931," each time the file is generated. Instead, create a separate file and simply extend the generated class."),e.qZA(),e.TgZ(932,"pre")(933,"code",12),e._uU(934,"\nimport { MinLength, MaxLength } from 'class-validator';\nimport { Post } from '../../graphql.ts';\n\nexport class CreatePostInput extends Post {\n  @MinLength(3)\n  @MaxLength(50)\n  title: string;\n}\n"),e.qZA()(),e.TgZ(935,"h4",44)(936,"span"),e._uU(937,"GraphQL argument decorators"),e.qZA()(),e.TgZ(938,"p"),e._uU(939,"We can access the standard GraphQL resolver arguments using dedicated decorators. Below is a comparison of the Nest decorators and the plain Apollo parameters they represent."),e.qZA(),e.TgZ(940,"table")(941,"tbody")(942,"tr")(943,"td")(944,"code"),e._uU(945,"@Root()"),e.qZA(),e._uU(946," and "),e.TgZ(947,"code"),e._uU(948,"@Parent()"),e.qZA()(),e.TgZ(949,"td")(950,"code"),e._uU(951,"root"),e.qZA(),e._uU(952,"/"),e.TgZ(953,"code"),e._uU(954,"parent"),e.qZA()()(),e.TgZ(955,"tr")(956,"td")(957,"code"),e._uU(958,"@Context(param?: string)"),e.qZA()(),e.TgZ(959,"td")(960,"code"),e._uU(961,"context"),e.qZA(),e._uU(962," / "),e.TgZ(963,"code"),e._uU(964,"context[param]"),e.qZA()()(),e.TgZ(965,"tr")(966,"td")(967,"code"),e._uU(968,"@Info(param?: string)"),e.qZA()(),e.TgZ(969,"td")(970,"code"),e._uU(971,"info"),e.qZA(),e._uU(972," / "),e.TgZ(973,"code"),e._uU(974,"info[param]"),e.qZA()()(),e.TgZ(975,"tr")(976,"td")(977,"code"),e._uU(978,"@Args(param?: string)"),e.qZA()(),e.TgZ(979,"td")(980,"code"),e._uU(981,"args"),e.qZA(),e._uU(982," / "),e.TgZ(983,"code"),e._uU(984,"args[param]"),e.qZA()()()()(),e.TgZ(985,"p"),e._uU(986,"These arguments have the following meanings:"),e.qZA(),e.TgZ(987,"ul")(988,"li")(989,"code"),e._uU(990,"root"),e.qZA(),e._uU(991,": an object that contains the result returned from the resolver on the parent field, or, in the case of a top-level "),e.TgZ(992,"code"),e._uU(993,"Query"),e.qZA(),e._uU(994," field, the "),e.TgZ(995,"code"),e._uU(996,"rootValue"),e.qZA(),e._uU(997," passed from the server configuration."),e.qZA(),e.TgZ(998,"li")(999,"code"),e._uU(1e3,"context"),e.qZA(),e._uU(1001,": an object shared by all resolvers in a particular query; typically used to contain per-request state."),e.qZA(),e.TgZ(1002,"li")(1003,"code"),e._uU(1004,"info"),e.qZA(),e._uU(1005,": an object that contains information about the execution state of the query."),e.qZA(),e.TgZ(1006,"li")(1007,"code"),e._uU(1008,"args"),e.qZA(),e._uU(1009,": an object with the arguments passed into the field in the query."),e.qZA()(),e.TgZ(1010,"p"),e._UZ(1011,"app-banner-shop"),e.qZA(),e.TgZ(1012,"h4",45)(1013,"span"),e._uU(1014,"Module"),e.qZA()(),e.TgZ(1015,"p"),e._uU(1016,"Once we're done with the above steps, we have declaratively specified all the information needed by the "),e.TgZ(1017,"code"),e._uU(1018,"GraphQLModule"),e.qZA(),e._uU(1019," to generate a resolver map. The "),e.TgZ(1020,"code"),e._uU(1021,"GraphQLModule"),e.qZA(),e._uU(1022," uses reflection to introspect the meta data provided via the decorators, and transforms classes into the correct resolver map automatically."),e.qZA(),e.TgZ(1023,"p"),e._uU(1024,"The only other thing you need to take care of is to "),e.TgZ(1025,"strong"),e._uU(1026,"provide"),e.qZA(),e._uU(1027," (i.e., list as a "),e.TgZ(1028,"code"),e._uU(1029,"provider"),e.qZA(),e._uU(1030," in some module) the resolver class(es) ("),e.TgZ(1031,"code"),e._uU(1032,"AuthorsResolver"),e.qZA(),e._uU(1033,"), and importing the module ("),e.TgZ(1034,"code"),e._uU(1035,"AuthorsModule"),e.qZA(),e._uU(1036,") somewhere, so Nest will be able to utilize it."),e.qZA(),e.TgZ(1037,"p"),e._uU(1038,"For example, we can do this in an "),e.TgZ(1039,"code"),e._uU(1040,"AuthorsModule"),e.qZA(),e._uU(1041,", which can also provide other services needed in this context. Be sure to import "),e.TgZ(1042,"code"),e._uU(1043,"AuthorsModule"),e.qZA(),e._uU(1044," somewhere (e.g., in the root module, or some other module imported by the root module)."),e.qZA(),e.TgZ(1045,"span",10),e._uU(1046),e.ALo(1047,"extension"),e._UZ(1048,"app-tabs",null,46),e.qZA(),e.TgZ(1050,"pre")(1051,"code",12),e._uU(1052,"\n@Module({\n  imports: [PostsModule],\n  providers: [AuthorsService, AuthorsResolver],\n})\nexport class AuthorsModule {}\n"),e.qZA()(),e.TgZ(1053,"blockquote",13)(1054,"strong"),e._uU(1055,"Hint"),e.qZA(),e._uU(1056," It is helpful to organize your code by your so-called "),e.TgZ(1057,"strong"),e._uU(1058,"domain model"),e.qZA(),e._uU(1059," (similar to the way you would organize entry points in a REST API). In this approach, keep your models ("),e.TgZ(1060,"code"),e._uU(1061,"ObjectType"),e.qZA(),e._uU(1062," classes), resolvers and services together within a Nest module representing the domain model. Keep all of these components in a single folder per module. When you do this, and use the "),e.TgZ(1063,"a",47),e._uU(1064,"Nest CLI"),e.qZA(),e._uU(1065," to generate each element, Nest will wire all of these parts together (locating files in appropriate folders, generating entries in "),e.TgZ(1066,"code"),e._uU(1067,"provider"),e.qZA(),e._uU(1068," and "),e.TgZ(1069,"code"),e._uU(1070,"imports"),e.qZA(),e._uU(1071," arrays, etc.) automatically for you.\n"),e.qZA()()),2&o){const p=e.MAs(51),c=e.MAs(218),I=e.MAs(245),R=e.MAs(389),F=e.MAs(567),G=e.MAs(744),P=e.MAs(855),D=e.MAs(890),Q=e.MAs(1049);e.xp6(48),e.hij(" ",e.xi3(49,13,"authors/models/author.model",p.isJsActive),"\n"),e.xp6(117),e.AsE("@ObjectType(","{"," description: 'Author model' ","}",")"),e.xp6(50),e.hij(" ",e.xi3(216,16,"posts/models/post.model",c.isJsActive),"\n"),e.xp6(27),e.hij(" ",e.xi3(243,19,"authors/authors.resolver",I.isJsActive),"\n"),e.xp6(144),e.hij(" ",e.xi3(387,22,"authors/authors.resolver",R.isJsActive),"\n"),e.xp6(24),e.AsE("","{","name: 'author'","}",""),e.xp6(154),e.hij(" ",e.xi3(565,25,"authors/dto/get-author.args",F.isJsActive),"\n"),e.xp6(177),e.hij(" ",e.xi3(742,28,"authors/authors.resolver",G.isJsActive),"\n"),e.xp6(111),e.hij(" ",e.xi3(853,31,"authors/authors.resolver",P.isJsActive),"\n"),e.xp6(35),e.hij(" ",e.xi3(888,34,"graphql",D.isJsActive),"\n"),e.xp6(159),e.hij(" ",e.xi3(1047,37,"authors/authors.module",Q.isJsActive),"\n")}},dependencies:[l.n,a.U,L.f,u.yS,d.F],encapsulation:2,changeDetection:0}),t})(),data:{title:"GraphQL + TypeScript - Resolvers"}},{path:"mutations",component:w,data:{title:"GraphQL + TypeScript - Mutations"}},{path:"scalars",component:(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-scalars"]],features:[e.qOj],decls:345,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/scalars.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","scalars"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/#scalar-types"],["appAnchor","","id","code-first"],[1,"language-typescript"],["appAnchor","","id","override-a-default-scalar"],["appAnchor","","id","import-a-custom-scalar"],[1,"language-bash"],["rel","nofollow","target","_blank","href","https://www.npmjs.com/package/graphql-scalars"],["appAnchor","","id","create-a-custom-scalar"],["appAnchor","","id","schema-first"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/graphql-tools/scalars.html"],[1,"language-graphql"],[1,"info"],["rel","nofollow","target","_blank","href","https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type"],["rel","nofollow","target","_blank","href","https://github.com/Microsoft/TypeScript/issues/12525#issuecomment-263166239"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Scalars"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"A GraphQL object type has a name and fields, but at some point those fields have to resolve to some concrete data. That's where the scalar types come in: they represent the leaves of the query (read more "),e.TgZ(9,"a",6),e._uU(10,"here"),e.qZA(),e._uU(11,"). GraphQL includes the following default types: "),e.TgZ(12,"code"),e._uU(13,"Int"),e.qZA(),e._uU(14,", "),e.TgZ(15,"code"),e._uU(16,"Float"),e.qZA(),e._uU(17,", "),e.TgZ(18,"code"),e._uU(19,"String"),e.qZA(),e._uU(20,", "),e.TgZ(21,"code"),e._uU(22,"Boolean"),e.qZA(),e._uU(23," and "),e.TgZ(24,"code"),e._uU(25,"ID"),e.qZA(),e._uU(26,". In addition to these built-in types, you may need to support custom atomic data types (e.g., "),e.TgZ(27,"code"),e._uU(28,"Date"),e.qZA(),e._uU(29,")."),e.qZA(),e.TgZ(30,"h4",7)(31,"span"),e._uU(32,"Code first"),e.qZA()(),e.TgZ(33,"p"),e._uU(34,"The code-first approach ships with five scalars in which three of them are simple aliases for the existing GraphQL types."),e.qZA(),e.TgZ(35,"ul")(36,"li")(37,"code"),e._uU(38,"ID"),e.qZA(),e._uU(39," (alias for "),e.TgZ(40,"code"),e._uU(41,"GraphQLID"),e.qZA(),e._uU(42,") - represents a unique identifier, often used to refetch an object or as the key for a cache"),e.qZA(),e.TgZ(43,"li")(44,"code"),e._uU(45,"Int"),e.qZA(),e._uU(46," (alias for "),e.TgZ(47,"code"),e._uU(48,"GraphQLInt"),e.qZA(),e._uU(49,") - a signed 32\u2010bit integer"),e.qZA(),e.TgZ(50,"li")(51,"code"),e._uU(52,"Float"),e.qZA(),e._uU(53," (alias for "),e.TgZ(54,"code"),e._uU(55,"GraphQLFloat"),e.qZA(),e._uU(56,") - a signed double-precision floating-point value"),e.qZA(),e.TgZ(57,"li")(58,"code"),e._uU(59,"GraphQLISODateTime"),e.qZA(),e._uU(60," - a date-time string at UTC (used by default to represent "),e.TgZ(61,"code"),e._uU(62,"Date"),e.qZA(),e._uU(63," type)"),e.qZA(),e.TgZ(64,"li")(65,"code"),e._uU(66,"GraphQLTimestamp"),e.qZA(),e._uU(67," - a signed integer which represents date and time as number of milliseconds from start of UNIX epoch"),e.qZA()(),e.TgZ(68,"p"),e._uU(69,"The "),e.TgZ(70,"code"),e._uU(71,"GraphQLISODateTime"),e.qZA(),e._uU(72," (e.g. "),e.TgZ(73,"code"),e._uU(74,"2019-12-03T09:54:33Z"),e.qZA(),e._uU(75,") is used by default to represent the "),e.TgZ(76,"code"),e._uU(77,"Date"),e.qZA(),e._uU(78," type. To use the "),e.TgZ(79,"code"),e._uU(80,"GraphQLTimestamp"),e.qZA(),e._uU(81," instead, set the "),e.TgZ(82,"code"),e._uU(83,"dateScalarMode"),e.qZA(),e._uU(84," of the "),e.TgZ(85,"code"),e._uU(86,"buildSchemaOptions"),e.qZA(),e._uU(87," object to "),e.TgZ(88,"code"),e._uU(89,"'timestamp'"),e.qZA(),e._uU(90," as follows:"),e.qZA(),e.TgZ(91,"pre")(92,"code",8),e._uU(93,"\nGraphQLModule.forRoot({\n  buildSchemaOptions: {\n    dateScalarMode: 'timestamp',\n  }\n}),\n"),e.qZA()(),e.TgZ(94,"p"),e._uU(95,"Likewise, the "),e.TgZ(96,"code"),e._uU(97,"GraphQLFloat"),e.qZA(),e._uU(98," is used by default to represent the "),e.TgZ(99,"code"),e._uU(100,"number"),e.qZA(),e._uU(101," type. To use the "),e.TgZ(102,"code"),e._uU(103,"GraphQLInt"),e.qZA(),e._uU(104," instead, set the "),e.TgZ(105,"code"),e._uU(106,"numberScalarMode"),e.qZA(),e._uU(107," of the "),e.TgZ(108,"code"),e._uU(109,"buildSchemaOptions"),e.qZA(),e._uU(110," object to "),e.TgZ(111,"code"),e._uU(112,"'integer'"),e.qZA(),e._uU(113," as follows:"),e.qZA(),e.TgZ(114,"pre")(115,"code",8),e._uU(116,"\nGraphQLModule.forRoot({\n  buildSchemaOptions: {\n    numberScalarMode: 'integer',\n  }\n}),\n"),e.qZA()(),e.TgZ(117,"p"),e._uU(118,"In addition, you can create custom scalars."),e.qZA(),e.TgZ(119,"h4",9)(120,"span"),e._uU(121,"Override a default scalar"),e.qZA()(),e.TgZ(122,"p"),e._uU(123,"To create a custom implementation for the "),e.TgZ(124,"code"),e._uU(125,"Date"),e.qZA(),e._uU(126," scalar, simply create a new class."),e.qZA(),e.TgZ(127,"pre")(128,"code",8),e._uU(129,"\nimport { Scalar, CustomScalar } from '@nestjs/graphql';\nimport { Kind, ValueNode } from 'graphql';\n\n@Scalar('Date', (type) => Date)\nexport class DateScalar implements CustomScalar<number, Date> {\n  description = 'Date custom scalar type';\n\n  parseValue(value: number): Date {\n    return new Date(value); // value from the client\n  }\n\n  serialize(value: Date): number {\n    return value.getTime(); // value sent to the client\n  }\n\n  parseLiteral(ast: ValueNode): Date {\n    if (ast.kind === Kind.INT) {\n      return new Date(ast.value);\n    }\n    return null;\n  }\n}\n"),e.qZA()(),e.TgZ(130,"p"),e._uU(131,"With this in place, register "),e.TgZ(132,"code"),e._uU(133,"DateScalar"),e.qZA(),e._uU(134," as a provider."),e.qZA(),e.TgZ(135,"pre")(136,"code",8),e._uU(137,"\n@Module({\n  providers: [DateScalar],\n})\nexport class CommonModule {}\n"),e.qZA()(),e.TgZ(138,"p"),e._uU(139,"Now we can use the "),e.TgZ(140,"code"),e._uU(141,"Date"),e.qZA(),e._uU(142," type in our classes."),e.qZA(),e.TgZ(143,"pre")(144,"code",8),e._uU(145,"\n@Field()\ncreationDate: Date;\n"),e.qZA()(),e.TgZ(146,"h4",10)(147,"span"),e._uU(148,"Import a custom scalar"),e.qZA()(),e.TgZ(149,"p"),e._uU(150,"To use a custom scalar, import and register it as a resolver. We\u2019ll use the "),e.TgZ(151,"code"),e._uU(152,"graphql-type-json"),e.qZA(),e._uU(153," package for demonstration purposes. This npm package defines a "),e.TgZ(154,"code"),e._uU(155,"JSON"),e.qZA(),e._uU(156," GraphQL scalar type."),e.qZA(),e.TgZ(157,"p"),e._uU(158,"Start by installing the package:"),e.qZA(),e.TgZ(159,"pre")(160,"code",11),e._uU(161,"\n$ npm i --save graphql-type-json\n"),e.qZA()(),e.TgZ(162,"p"),e._uU(163,"Once the package is installed, we pass a custom resolver to the "),e.TgZ(164,"code"),e._uU(165,"forRoot()"),e.qZA(),e._uU(166," method:"),e.qZA(),e.TgZ(167,"pre")(168,"code",8),e._uU(169,"\nimport GraphQLJSON from 'graphql-type-json';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot({\n      resolvers: { JSON: GraphQLJSON },\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(170,"p"),e._uU(171,"Now we can use the "),e.TgZ(172,"code"),e._uU(173,"JSON"),e.qZA(),e._uU(174," type in our classes."),e.qZA(),e.TgZ(175,"pre")(176,"code",8),e._uU(177,"\n@Field((type) => GraphQLJSON)\ninfo: JSON;\n"),e.qZA()(),e.TgZ(178,"p"),e._uU(179,"For a suite of useful scalars, take a look at the "),e.TgZ(180,"a",12),e._uU(181,"graphql-scalars"),e.qZA(),e._uU(182," package."),e.qZA(),e.TgZ(183,"h4",13)(184,"span"),e._uU(185,"Create a custom scalar"),e.qZA()(),e.TgZ(186,"p"),e._uU(187,"To define a custom scalar, create a new "),e.TgZ(188,"code"),e._uU(189,"GraphQLScalarType"),e.qZA(),e._uU(190," instance. We'll create a custom "),e.TgZ(191,"code"),e._uU(192,"UUID"),e.qZA(),e._uU(193," scalar."),e.qZA(),e.TgZ(194,"pre")(195,"code",8),e._uU(196,"\nconst regex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n\nfunction validate(uuid: unknown): string | never {\n  if (typeof uuid !== \"string\" || !regex.test(uuid)) {\n    throw new Error(\"invalid uuid\");\n  }\n  return uuid;\n}\n\nexport const CustomUuidScalar = new GraphQLScalarType({\n  name: 'UUID',\n  description: 'A simple UUID parser',\n  serialize: (value) => validate(value),\n  parseValue: (value) => validate(value),\n  parseLiteral: (ast) => validate(ast.value)\n})\n"),e.qZA()(),e.TgZ(197,"p"),e._uU(198,"We pass a custom resolver to the "),e.TgZ(199,"code"),e._uU(200,"forRoot()"),e.qZA(),e._uU(201," method:"),e.qZA(),e.TgZ(202,"pre")(203,"code",8),e._uU(204,"\n@Module({\n  imports: [\n    GraphQLModule.forRoot({\n      resolvers: { UUID: CustomUuidScalar },\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(205,"p"),e._uU(206,"Now we can use the "),e.TgZ(207,"code"),e._uU(208,"UUID"),e.qZA(),e._uU(209," type in our classes."),e.qZA(),e.TgZ(210,"pre")(211,"code",8),e._uU(212,"\n@Field((type) => CustomUuidScalar)\nuuid: string;\n"),e.qZA()(),e.TgZ(213,"h4",14)(214,"span"),e._uU(215,"Schema first"),e.qZA()(),e.TgZ(216,"p"),e._uU(217,"To define a custom scalar (read more about scalars "),e.TgZ(218,"a",15),e._uU(219,"here"),e.qZA(),e._uU(220,"), create a type definition and a dedicated resolver. Here (as in the official documentation), we\u2019ll use the "),e.TgZ(221,"code"),e._uU(222,"graphql-type-json"),e.qZA(),e._uU(223," package for demonstration purposes. This npm package defines a "),e.TgZ(224,"code"),e._uU(225,"JSON"),e.qZA(),e._uU(226," GraphQL scalar type."),e.qZA(),e.TgZ(227,"p"),e._uU(228,"Start by installing the package:"),e.qZA(),e.TgZ(229,"pre")(230,"code",11),e._uU(231,"\n$ npm i --save graphql-type-json\n"),e.qZA()(),e.TgZ(232,"p"),e._uU(233,"Once the package is installed, we pass a custom resolver to the "),e.TgZ(234,"code"),e._uU(235,"forRoot()"),e.qZA(),e._uU(236," method:"),e.qZA(),e.TgZ(237,"pre")(238,"code",8),e._uU(239,"\nimport GraphQLJSON from 'graphql-type-json';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot({\n      typePaths: ['./**/*.graphql'],\n      resolvers: { JSON: GraphQLJSON },\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(240,"p"),e._uU(241,"Now we can use the "),e.TgZ(242,"code"),e._uU(243,"JSON"),e.qZA(),e._uU(244," scalar in our type definitions:"),e.qZA(),e.TgZ(245,"pre")(246,"code",16),e._uU(247,"\nscalar JSON\n\ntype Foo {\n  field: JSON\n}\n"),e.qZA()(),e.TgZ(248,"p"),e._uU(249,"Another method to define a scalar type is to create a simple class. Assume we want to enhance our schema with the "),e.TgZ(250,"code"),e._uU(251,"Date"),e.qZA(),e._uU(252," type."),e.qZA(),e.TgZ(253,"pre")(254,"code",8),e._uU(255,"\nimport { Scalar, CustomScalar } from '@nestjs/graphql';\nimport { Kind, ValueNode } from 'graphql';\n\n@Scalar('Date')\nexport class DateScalar implements CustomScalar<number, Date> {\n  description = 'Date custom scalar type';\n\n  parseValue(value: number): Date {\n    return new Date(value); // value from the client\n  }\n\n  serialize(value: Date): number {\n    return value.getTime(); // value sent to the client\n  }\n\n  parseLiteral(ast: ValueNode): Date {\n    if (ast.kind === Kind.INT) {\n      return new Date(ast.value);\n    }\n    return null;\n  }\n}\n"),e.qZA()(),e.TgZ(256,"p"),e._uU(257,"With this in place, register "),e.TgZ(258,"code"),e._uU(259,"DateScalar"),e.qZA(),e._uU(260," as a provider."),e.qZA(),e.TgZ(261,"pre")(262,"code",8),e._uU(263,"\n@Module({\n  providers: [DateScalar],\n})\nexport class CommonModule {}\n"),e.qZA()(),e.TgZ(264,"p"),e._uU(265,"Now we can use the "),e.TgZ(266,"code"),e._uU(267,"Date"),e.qZA(),e._uU(268," scalar in type definitions."),e.qZA(),e.TgZ(269,"pre")(270,"code",16),e._uU(271,"\nscalar Date\n"),e.qZA()(),e.TgZ(272,"p"),e._uU(273,"By default, the generated TypeScript definition for all scalars is "),e.TgZ(274,"code"),e._uU(275,"any"),e.qZA(),e._uU(276," - which isn't particularly typesafe.\nBut, you can configure how Nest generates typings for your custom scalars when you specify how to generate types:"),e.qZA(),e.TgZ(277,"pre")(278,"code",8),e._uU(279,"\nimport { GraphQLDefinitionsFactory } from '@nestjs/graphql';\nimport { join } from 'path';\n\nconst definitionsFactory = new GraphQLDefinitionsFactory();\n\ndefinitionsFactory.generate({\n  typePaths: ['./src/**/*.graphql'],\n  path: join(process.cwd(), 'src/graphql.ts'),\n  outputAs: 'class',\n  defaultScalarType: 'unknown',\n  customScalarTypeMapping: {\n    DateTime: 'Date',\n    BigNumber: '_BigNumber',\n  },\n  additionalHeader: \"import _BigNumber from 'bignumber.js'\",\n});\n"),e.qZA()(),e.TgZ(280,"blockquote",17)(281,"strong"),e._uU(282,"Hint"),e.qZA(),e._uU(283," Alternatively, you can use a type reference instead, for example: "),e.TgZ(284,"code"),e._uU(285,"DateTime: Date"),e.qZA(),e._uU(286,". In this case, "),e.TgZ(287,"code"),e._uU(288,"GraphQLDefinitionsFactory"),e.qZA(),e._uU(289," will extract the name property of the specified type ("),e.TgZ(290,"code"),e._uU(291,"Date.name"),e.qZA(),e._uU(292,") to generate TS definitions. Note: adding an import statement for non-built-in types (custom types) is required.\n"),e.qZA(),e.TgZ(293,"p"),e._uU(294,"Now, given the following GraphQL custom scalar types:"),e.qZA(),e.TgZ(295,"pre")(296,"code",16),e._uU(297,"\nscalar DateTime\nscalar BigNumber\nscalar Payload\n"),e.qZA()(),e.TgZ(298,"p"),e._uU(299,"We will now see the following generated TypeScript definitions in "),e.TgZ(300,"code"),e._uU(301,"src/graphql.ts"),e.qZA(),e._uU(302,":"),e.qZA(),e.TgZ(303,"pre")(304,"code",8),e._uU(305,"\nimport _BigNumber from 'bignumber.js';\n\nexport type DateTime = Date;\nexport type BigNumber = _BigNumber;\nexport type Payload = unknown;\n"),e.qZA()(),e.TgZ(306,"p"),e._uU(307,"Here, we've used the "),e.TgZ(308,"code"),e._uU(309,"customScalarTypeMapping"),e.qZA(),e._uU(310," property to supply a map of the types we wish to declare for our custom scalars. We've\nalso provided an "),e.TgZ(311,"code"),e._uU(312,"additionalHeader"),e.qZA(),e._uU(313," property so that we can add any imports required for these type definitions. Lastly, we've added\na "),e.TgZ(314,"code"),e._uU(315,"defaultScalarType"),e.qZA(),e._uU(316," of "),e.TgZ(317,"code"),e._uU(318,"'unknown'"),e.qZA(),e._uU(319,", so that any custom scalars not specified in "),e.TgZ(320,"code"),e._uU(321,"customScalarTypeMapping"),e.qZA(),e._uU(322," will be aliased to\n"),e.TgZ(323,"code"),e._uU(324,"unknown"),e.qZA(),e._uU(325," instead of "),e.TgZ(326,"code"),e._uU(327,"any"),e.qZA(),e._uU(328," (which "),e.TgZ(329,"a",18),e._uU(330,"TypeScript recommends"),e.qZA(),e._uU(331," using since 3.0 for added type safety)."),e.qZA(),e.TgZ(332,"blockquote",17)(333,"strong"),e._uU(334,"Hint"),e.qZA(),e._uU(335," Note that we've imported "),e.TgZ(336,"code"),e._uU(337,"_BigNumber"),e.qZA(),e._uU(338," from "),e.TgZ(339,"code"),e._uU(340,"bignumber.js"),e.qZA(),e._uU(341,"; this is to avoid "),e.TgZ(342,"a",19),e._uU(343,"circular type references"),e.qZA(),e._uU(344,".\n"),e.qZA()())},dependencies:[a.U],encapsulation:2,changeDetection:0}),t})(),data:{title:"GraphQL + TypeScript - Scalars"}},{path:"subscriptions",component:(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-subscriptions"]],features:[e.qOj],decls:683,vars:16,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/subscriptions.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","subscriptions"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/react/data/subscriptions"],["appAnchor","","id","enable-subscriptions-with-apollo-driver"],[1,"language-typescript"],[1,"warning"],["rel","nofollow","target","_blank","href","https://github.com/apollographql/subscriptions-transport-ws"],["rel","nofollow","target","_blank","href","https://github.com/enisdenjo/graphql-ws"],[1,"info"],["appAnchor","","id","code-first"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/graphql-subscriptions/setup.html"],["rel","nofollow","target","_blank","href","https://github.com/apollographql/graphql-subscriptions#getting-started-with-your-first-subscription"],["rel","nofollow","target","_blank","href","https://github.com/apollographql/graphql-subscriptions#pubsub-implementations"],[1,"language-graphql"],["appAnchor","","id","publishing"],[1,"filename"],["app55cba784bc195a1b7f4fab0b4d5d0901a74165a2",""],["appAnchor","","id","filtering-subscriptions"],["appAnchor","","id","mutating-subscription-payloads"],["appAnchor","","id","schema-first"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/blob/master/sample/12-graphql-schema-first"],["appAnchor","","id","pubsub"],["routerLink","/fundamentals/custom-providers"],["appAnchor","","id","customize-subscriptions-server"],["appAnchor","","id","authentication-over-websockets"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/react/data/subscriptions/#5-authenticate-over-websocket-optional"],["rel","nofollow","target","_blank","href","https://github.com/apollographql/subscriptions-transport-ws/issues/349"],["appAnchor","","id","enable-subscriptions-with-mercurius-driver"],["rel","nofollow","target","_blank","href","https://github.com/mercurius-js/mercurius/blob/master/docs/api/options.md#plugin-options"],["appAnchor","","id","code-first-1"],["rel","nofollow","target","_blank","href","https://github.com/mercurius-js/mercurius/blob/master/docs/subscriptions.md#subscriptions-with-custom-pubsub"],["appAnchor","","id","publishing-1"],["app089081fc18f39a94b0f9da94315fbce6d0a736f0",""],["appAnchor","","id","filtering-subscriptions-1"],["appAnchor","","id","schema-first-1"],["appAnchor","","id","pubsub-1"],["rel","nofollow","target","_blank","href","https://github.com/mcollina/mqemitter"],["rel","nofollow","target","_blank","href","https://github.com/mercurius-js/mercurius/blob/master/docs/subscriptions.md"],["appAnchor","","id","authentication-over-websockets-1"]],template:function(o,r){if(1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Subscriptions"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"In addition to fetching data using queries and modifying data using mutations, the GraphQL spec supports a third operation type, called "),e.TgZ(9,"code"),e._uU(10,"subscription"),e.qZA(),e._uU(11,". GraphQL subscriptions are a way to push data from the server to the clients that choose to listen to real time messages from the server. Subscriptions are similar to queries in that they specify a set of fields to be delivered to the client, but instead of immediately returning a single answer, a channel is opened and a result is sent to the client every time a particular event happens on the server."),e.qZA(),e.TgZ(12,"p"),e._uU(13,"A common use case for subscriptions is notifying the client side about particular events, for example the creation of a new object, updated fields and so on (read more "),e.TgZ(14,"a",6),e._uU(15,"here"),e.qZA(),e._uU(16,")."),e.qZA(),e.TgZ(17,"h4",7)(18,"span"),e._uU(19,"Enable subscriptions with Apollo driver"),e.qZA()(),e.TgZ(20,"p"),e._uU(21,"To enable subscriptions, set the "),e.TgZ(22,"code"),e._uU(23,"installSubscriptionHandlers"),e.qZA(),e._uU(24," property to "),e.TgZ(25,"code"),e._uU(26,"true"),e.qZA(),e._uU(27,"."),e.qZA(),e.TgZ(28,"pre")(29,"code",8),e._uU(30,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  installSubscriptionHandlers: true,\n}),\n"),e.qZA()(),e.TgZ(31,"blockquote",9)(32,"strong"),e._uU(33,"Warning"),e.qZA(),e._uU(34," The "),e.TgZ(35,"code"),e._uU(36,"installSubscriptionHandlers"),e.qZA(),e._uU(37," configuration option has been removed from the latest version of Apollo server and will be soon deprecated in this package as well. By default, "),e.TgZ(38,"code"),e._uU(39,"installSubscriptionHandlers"),e.qZA(),e._uU(40," will fallback to use the "),e.TgZ(41,"code"),e._uU(42,"subscriptions-transport-ws"),e.qZA(),e._uU(43," ("),e.TgZ(44,"a",10),e._uU(45,"read more"),e.qZA(),e._uU(46,") but we strongly recommend using the "),e.TgZ(47,"code"),e._uU(48,"graphql-ws"),e.qZA(),e._uU(49,"("),e.TgZ(50,"a",11),e._uU(51,"read more"),e.qZA(),e._uU(52,") library instead.\n"),e.qZA(),e.TgZ(53,"p"),e._uU(54,"To switch to use the "),e.TgZ(55,"code"),e._uU(56,"graphql-ws"),e.qZA(),e._uU(57," package instead, use the following configuration:"),e.qZA(),e.TgZ(58,"pre")(59,"code",8),e._uU(60,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  subscriptions: {\n    'graphql-ws': true\n  },\n}),\n"),e.qZA()(),e.TgZ(61,"blockquote",12)(62,"strong"),e._uU(63,"Hint"),e.qZA(),e._uU(64," You can also use both packages ("),e.TgZ(65,"code"),e._uU(66,"subscriptions-transport-ws"),e.qZA(),e._uU(67," and "),e.TgZ(68,"code"),e._uU(69,"graphql-ws"),e.qZA(),e._uU(70,") at the same time, for example, for backward compatibility.\n"),e.qZA(),e.TgZ(71,"h4",13)(72,"span"),e._uU(73,"Code first"),e.qZA()(),e.TgZ(74,"p"),e._uU(75,"To create a subscription using the code first approach, we use the "),e.TgZ(76,"code"),e._uU(77,"@Subscription()"),e.qZA(),e._uU(78," decorator (exported from the "),e.TgZ(79,"code"),e._uU(80,"@nestjs/graphql"),e.qZA(),e._uU(81," package) and the "),e.TgZ(82,"code"),e._uU(83,"PubSub"),e.qZA(),e._uU(84," class from the "),e.TgZ(85,"code"),e._uU(86,"graphql-subscriptions"),e.qZA(),e._uU(87," package, which provides a simple "),e.TgZ(88,"strong"),e._uU(89,"publish/subscribe API"),e.qZA(),e._uU(90,"."),e.qZA(),e.TgZ(91,"p"),e._uU(92,"The following subscription handler takes care of "),e.TgZ(93,"strong"),e._uU(94,"subscribing"),e.qZA(),e._uU(95," to an event by calling "),e.TgZ(96,"code"),e._uU(97,"PubSub#asyncIterator"),e.qZA(),e._uU(98,". This method takes a single argument, the "),e.TgZ(99,"code"),e._uU(100,"triggerName"),e.qZA(),e._uU(101,", which corresponds to an event topic name."),e.qZA(),e.TgZ(102,"pre")(103,"code",8),e._uU(104,"\nconst pubSub = new PubSub();\n\n@Resolver((of) => Author)\nexport class AuthorResolver {\n  // ...\n  @Subscription((returns) => Comment)\n  commentAdded() {\n    return pubSub.asyncIterator('commentAdded');\n  }\n}\n"),e.qZA()(),e.TgZ(105,"blockquote",12)(106,"strong"),e._uU(107,"Hint"),e.qZA(),e._uU(108," All decorators are exported from the "),e.TgZ(109,"code"),e._uU(110,"@nestjs/graphql"),e.qZA(),e._uU(111," package, while the "),e.TgZ(112,"code"),e._uU(113,"PubSub"),e.qZA(),e._uU(114," class is exported from the "),e.TgZ(115,"code"),e._uU(116,"graphql-subscriptions"),e.qZA(),e._uU(117," package.\n"),e.qZA(),e.TgZ(118,"blockquote",9)(119,"strong"),e._uU(120,"Note"),e.qZA(),e.TgZ(121,"code"),e._uU(122,"PubSub"),e.qZA(),e._uU(123," is a class that exposes a simple "),e.TgZ(124,"code"),e._uU(125,"publish"),e.qZA(),e._uU(126," and "),e.TgZ(127,"code"),e._uU(128,"subscribe API"),e.qZA(),e._uU(129,". Read more about it "),e.TgZ(130,"a",14),e._uU(131,"here"),e.qZA(),e._uU(132,". Note that the Apollo docs warn that the default implementation is not suitable for production (read more "),e.TgZ(133,"a",15),e._uU(134,"here"),e.qZA(),e._uU(135,"). Production apps should use a "),e.TgZ(136,"code"),e._uU(137,"PubSub"),e.qZA(),e._uU(138," implementation backed by an external store (read more "),e.TgZ(139,"a",16),e._uU(140,"here"),e.qZA(),e._uU(141,").\n"),e.qZA(),e.TgZ(142,"p"),e._uU(143,"This will result in generating the following part of the GraphQL schema in SDL:"),e.qZA(),e.TgZ(144,"pre")(145,"code",17),e._uU(146,"\ntype Subscription {\n  commentAdded(): Comment!\n}\n"),e.qZA()(),e.TgZ(147,"p"),e._uU(148,"Note that subscriptions, by definition, return an object with a single top level property whose key is the name of the subscription. This name is either inherited from the name of the subscription handler method (i.e., "),e.TgZ(149,"code"),e._uU(150,"commentAdded"),e.qZA(),e._uU(151," above), or is provided explicitly by passing an option with the key "),e.TgZ(152,"code"),e._uU(153,"name"),e.qZA(),e._uU(154," as the second argument to the "),e.TgZ(155,"code"),e._uU(156,"@Subscription()"),e.qZA(),e._uU(157," decorator, as shown below."),e.qZA(),e.TgZ(158,"pre")(159,"code",8),e._uU(160,"\n@Subscription(returns => Comment, {\n  name: 'commentAdded',\n})\nsubscribeToCommentAdded() {\n  return pubSub.asyncIterator('commentAdded');\n}\n"),e.qZA()(),e.TgZ(161,"p"),e._uU(162,"This construct produces the same SDL as the previous code sample, but allows us to decouple the method name from the subscription."),e.qZA(),e.TgZ(163,"h4",18)(164,"span"),e._uU(165,"Publishing"),e.qZA()(),e.TgZ(166,"p"),e._uU(167,"Now, to publish the event, we use the "),e.TgZ(168,"code"),e._uU(169,"PubSub#publish"),e.qZA(),e._uU(170," method. This is often used within a mutation to trigger a client-side update when a part of the object graph has changed. For example:"),e.qZA(),e.TgZ(171,"span",19),e._uU(172),e.ALo(173,"extension"),e._UZ(174,"app-tabs",null,20),e.qZA(),e.TgZ(176,"pre")(177,"code",8),e._uU(178,"\n@Mutation(returns => Post)\nasync addComment(\n  @Args('postId', { type: () => Int }) postId: number,\n  @Args('comment', { type: () => Comment }) comment: CommentInput,\n) {\n  const newComment = this.commentsService.addComment({ id: postId, comment });\n  pubSub.publish('commentAdded', { commentAdded: newComment });\n  return newComment;\n}\n"),e.qZA()(),e.TgZ(179,"p"),e._uU(180,"The "),e.TgZ(181,"code"),e._uU(182,"PubSub#publish"),e.qZA(),e._uU(183," method takes a "),e.TgZ(184,"code"),e._uU(185,"triggerName"),e.qZA(),e._uU(186," (again, think of this as an event topic name) as the first parameter, and an event payload as the second parameter. As mentioned, the subscription, by definition, returns a value and that value has a shape. Look again at the generated SDL for our "),e.TgZ(187,"code"),e._uU(188,"commentAdded"),e.qZA(),e._uU(189," subscription:"),e.qZA(),e.TgZ(190,"pre")(191,"code",17),e._uU(192,"\ntype Subscription {\n  commentAdded(): Comment!\n}\n"),e.qZA()(),e.TgZ(193,"p"),e._uU(194,"This tells us that the subscription must return an object with a top-level property name of "),e.TgZ(195,"code"),e._uU(196,"commentAdded"),e.qZA(),e._uU(197," that has a value which is a "),e.TgZ(198,"code"),e._uU(199,"Comment"),e.qZA(),e._uU(200," object. The important point to note is that the shape of the event payload emitted by the "),e.TgZ(201,"code"),e._uU(202,"PubSub#publish"),e.qZA(),e._uU(203," method must correspond to the shape of the value expected to return from the subscription. So, in our example above, the "),e.TgZ(204,"code"),e._uU(205),e.qZA(),e._uU(206," statement publishes a "),e.TgZ(207,"code"),e._uU(208,"commentAdded"),e.qZA(),e._uU(209," event with the appropriately shaped payload. If these shapes don't match, your subscription will fail during the GraphQL validation phase."),e.qZA(),e.TgZ(210,"h4",21)(211,"span"),e._uU(212,"Filtering subscriptions"),e.qZA()(),e.TgZ(213,"p"),e._uU(214,"To filter out specific events, set the "),e.TgZ(215,"code"),e._uU(216,"filter"),e.qZA(),e._uU(217," property to a filter function. This function acts similar to the function passed to an array "),e.TgZ(218,"code"),e._uU(219,"filter"),e.qZA(),e._uU(220,". It takes two arguments: "),e.TgZ(221,"code"),e._uU(222,"payload"),e.qZA(),e._uU(223," containing the event payload (as sent by the event publisher), and "),e.TgZ(224,"code"),e._uU(225,"variables"),e.qZA(),e._uU(226," taking any arguments passed in during the subscription request. It returns a boolean determining whether this event should be published to client listeners."),e.qZA(),e.TgZ(227,"pre")(228,"code",8),e._uU(229,"\n@Subscription(returns => Comment, {\n  filter: (payload, variables) =>\n    payload.commentAdded.title === variables.title,\n})\ncommentAdded(@Args('title') title: string) {\n  return pubSub.asyncIterator('commentAdded');\n}\n"),e.qZA()(),e.TgZ(230,"h4",22)(231,"span"),e._uU(232,"Mutating subscription payloads"),e.qZA()(),e.TgZ(233,"p"),e._uU(234,"To mutate the published event payload, set the "),e.TgZ(235,"code"),e._uU(236,"resolve"),e.qZA(),e._uU(237," property to a function. The function receives the event payload (as sent by the event publisher) and returns the appropriate value."),e.qZA(),e.TgZ(238,"pre")(239,"code",8),e._uU(240,"\n@Subscription(returns => Comment, {\n  resolve: value => value,\n})\ncommentAdded() {\n  return pubSub.asyncIterator('commentAdded');\n}\n"),e.qZA()(),e.TgZ(241,"blockquote",9)(242,"strong"),e._uU(243,"Note"),e.qZA(),e._uU(244," If you use the "),e.TgZ(245,"code"),e._uU(246,"resolve"),e.qZA(),e._uU(247," option, you should return the unwrapped payload (e.g., with our example, return a "),e.TgZ(248,"code"),e._uU(249,"newComment"),e.qZA(),e._uU(250," object directly, not a "),e.TgZ(251,"code"),e._uU(252),e.qZA(),e._uU(253," object).\n"),e.qZA(),e.TgZ(254,"p"),e._uU(255,"If you need to access injected providers (e.g., use an external service to validate the data), use the following construction."),e.qZA(),e.TgZ(256,"pre")(257,"code",8),e._uU(258,'\n@Subscription(returns => Comment, {\n  resolve(this: AuthorResolver, value) {\n    // "this" refers to an instance of "AuthorResolver"\n    return value;\n  }\n})\ncommentAdded() {\n  return pubSub.asyncIterator(\'commentAdded\');\n}\n'),e.qZA()(),e.TgZ(259,"p"),e._uU(260,"The same construction works with filters:"),e.qZA(),e.TgZ(261,"pre")(262,"code",8),e._uU(263,'\n@Subscription(returns => Comment, {\n  filter(this: AuthorResolver, payload, variables) {\n    // "this" refers to an instance of "AuthorResolver"\n    return payload.commentAdded.title === variables.title;\n  }\n})\ncommentAdded() {\n  return pubSub.asyncIterator(\'commentAdded\');\n}\n'),e.qZA()(),e.TgZ(264,"h4",23)(265,"span"),e._uU(266,"Schema first"),e.qZA()(),e.TgZ(267,"p"),e._uU(268,"To create an equivalent subscription in Nest, we'll make use of the "),e.TgZ(269,"code"),e._uU(270,"@Subscription()"),e.qZA(),e._uU(271," decorator."),e.qZA(),e.TgZ(272,"pre")(273,"code",8),e._uU(274,"\nconst pubSub = new PubSub();\n\n@Resolver('Author')\nexport class AuthorResolver {\n  // ...\n  @Subscription()\n  commentAdded() {\n    return pubSub.asyncIterator('commentAdded');\n  }\n}\n"),e.qZA()(),e.TgZ(275,"p"),e._uU(276,"To filter out specific events based on context and arguments, set the "),e.TgZ(277,"code"),e._uU(278,"filter"),e.qZA(),e._uU(279," property."),e.qZA(),e.TgZ(280,"pre")(281,"code",8),e._uU(282,"\n@Subscription('commentAdded', {\n  filter: (payload, variables) =>\n    payload.commentAdded.title === variables.title,\n})\ncommentAdded() {\n  return pubSub.asyncIterator('commentAdded');\n}\n"),e.qZA()(),e.TgZ(283,"p"),e._uU(284,"To mutate the published payload, we can use a "),e.TgZ(285,"code"),e._uU(286,"resolve"),e.qZA(),e._uU(287," function."),e.qZA(),e.TgZ(288,"pre")(289,"code",8),e._uU(290,"\n@Subscription('commentAdded', {\n  resolve: value => value,\n})\ncommentAdded() {\n  return pubSub.asyncIterator('commentAdded');\n}\n"),e.qZA()(),e.TgZ(291,"p"),e._uU(292,"If you need to access injected providers (e.g., use an external service to validate the data), use the following construction:"),e.qZA(),e.TgZ(293,"pre")(294,"code",8),e._uU(295,"\n@Subscription('commentAdded', {\n  resolve(this: AuthorResolver, value) {\n    // \"this\" refers to an instance of \"AuthorResolver\"\n    return value;\n  }\n})\ncommentAdded() {\n  return pubSub.asyncIterator('commentAdded');\n}\n"),e.qZA()(),e.TgZ(296,"p"),e._uU(297,"The same construction works with filters:"),e.qZA(),e.TgZ(298,"pre")(299,"code",8),e._uU(300,"\n@Subscription('commentAdded', {\n  filter(this: AuthorResolver, payload, variables) {\n    // \"this\" refers to an instance of \"AuthorResolver\"\n    return payload.commentAdded.title === variables.title;\n  }\n})\ncommentAdded() {\n  return pubSub.asyncIterator('commentAdded');\n}\n"),e.qZA()(),e.TgZ(301,"p"),e._uU(302,"The last step is to update the type definitions file."),e.qZA(),e.TgZ(303,"pre")(304,"code",17),e._uU(305,"\ntype Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post]\n}\n\ntype Post {\n  id: Int!\n  title: String\n  votes: Int\n}\n\ntype Query {\n  author(id: Int!): Author\n}\n\ntype Comment {\n  id: String\n  content: String\n}\n\ntype Subscription {\n  commentAdded(title: String!): Comment\n}\n"),e.qZA()(),e.TgZ(306,"p"),e._uU(307,"With this, we've created a single "),e.TgZ(308,"code"),e._uU(309,"commentAdded(title: String!): Comment"),e.qZA(),e._uU(310," subscription. You can find a full sample implementation "),e.TgZ(311,"a",24),e._uU(312,"here"),e.qZA(),e._uU(313,"."),e.qZA(),e.TgZ(314,"h4",25)(315,"span"),e._uU(316,"PubSub"),e.qZA()(),e.TgZ(317,"p"),e._uU(318,"We instantiated a local "),e.TgZ(319,"code"),e._uU(320,"PubSub"),e.qZA(),e._uU(321," instance above. The preferred approach is to define "),e.TgZ(322,"code"),e._uU(323,"PubSub"),e.qZA(),e._uU(324," as a "),e.TgZ(325,"a",26),e._uU(326,"provider"),e.qZA(),e._uU(327," and inject it through the constructor (using the "),e.TgZ(328,"code"),e._uU(329,"@Inject()"),e.qZA(),e._uU(330," decorator). This allows us to re-use the instance across the whole application. For example, define a provider as follows, then inject "),e.TgZ(331,"code"),e._uU(332,"'PUB_SUB'"),e.qZA(),e._uU(333," where needed."),e.qZA(),e.TgZ(334,"pre")(335,"code",8),e._uU(336,"\n{\n  provide: 'PUB_SUB',\n  useValue: new PubSub(),\n}\n"),e.qZA()(),e.TgZ(337,"h4",27)(338,"span"),e._uU(339,"Customize subscriptions server"),e.qZA()(),e.TgZ(340,"p"),e._uU(341,"To customize the subscriptions server (e.g., change the path), use the "),e.TgZ(342,"code"),e._uU(343,"subscriptions"),e.qZA(),e._uU(344," options property."),e.qZA(),e.TgZ(345,"pre")(346,"code",8),e._uU(347,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  subscriptions: {\n    'subscriptions-transport-ws': {\n      path: '/graphql'\n    },\n  }\n}),\n"),e.qZA()(),e.TgZ(348,"p"),e._uU(349,"If you're using the "),e.TgZ(350,"code"),e._uU(351,"graphql-ws"),e.qZA(),e._uU(352," package for subscriptions, replace the "),e.TgZ(353,"code"),e._uU(354,"subscriptions-transport-ws"),e.qZA(),e._uU(355," key with "),e.TgZ(356,"code"),e._uU(357,"graphql-ws"),e.qZA(),e._uU(358,", as follows:"),e.qZA(),e.TgZ(359,"pre")(360,"code",8),e._uU(361,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  subscriptions: {\n    'graphql-ws': {\n      path: '/graphql'\n    },\n  }\n}),\n"),e.qZA()(),e.TgZ(362,"h4",28)(363,"span"),e._uU(364,"Authentication over WebSockets"),e.qZA()(),e.TgZ(365,"p"),e._uU(366,"Checking whether the user is authenticated can be done inside the "),e.TgZ(367,"code"),e._uU(368,"onConnect"),e.qZA(),e._uU(369," callback function that you can specify in the "),e.TgZ(370,"code"),e._uU(371,"subscriptions"),e.qZA(),e._uU(372," options."),e.qZA(),e.TgZ(373,"p"),e._uU(374,"The "),e.TgZ(375,"code"),e._uU(376,"onConnect"),e.qZA(),e._uU(377," will receive as a first argument the "),e.TgZ(378,"code"),e._uU(379,"connectionParams"),e.qZA(),e._uU(380," passed to the "),e.TgZ(381,"code"),e._uU(382,"SubscriptionClient"),e.qZA(),e._uU(383," (read "),e.TgZ(384,"a",29),e._uU(385,"more"),e.qZA(),e._uU(386,")."),e.qZA(),e.TgZ(387,"pre")(388,"code",8),e._uU(389,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  subscriptions: {\n    'subscriptions-transport-ws': {\n      onConnect: (connectionParams) => {\n        const authToken = connectionParams.authToken;\n        if (!isValid(authToken)) {\n          throw new Error('Token is not valid');\n        }\n        // extract user information from token\n        const user = parseToken(authToken);\n        // return user info to add them to the context later\n        return { user };\n      },\n    }\n  },\n  context: ({ connection }) => {\n    // connection.context will be equal to what was returned by the \"onConnect\" callback\n  },\n}),\n"),e.qZA()(),e.TgZ(390,"p"),e._uU(391,"The "),e.TgZ(392,"code"),e._uU(393,"authToken"),e.qZA(),e._uU(394," in this example is only sent once by the client, when the connection is first established.\nAll subscriptions made with this connection will have the same "),e.TgZ(395,"code"),e._uU(396,"authToken"),e.qZA(),e._uU(397,", and thus the same user info."),e.qZA(),e.TgZ(398,"blockquote",9)(399,"strong"),e._uU(400,"Note"),e.qZA(),e._uU(401," There is a bug in "),e.TgZ(402,"code"),e._uU(403,"subscriptions-transport-ws"),e.qZA(),e._uU(404," that allows connections to skip the "),e.TgZ(405,"code"),e._uU(406,"onConnect"),e.qZA(),e._uU(407," phase (read "),e.TgZ(408,"a",30),e._uU(409,"more"),e.qZA(),e._uU(410,"). You should not assume that "),e.TgZ(411,"code"),e._uU(412,"onConnect"),e.qZA(),e._uU(413," was called when the user starts a subscription, and always check that the "),e.TgZ(414,"code"),e._uU(415,"context"),e.qZA(),e._uU(416," is populated.\n"),e.qZA(),e.TgZ(417,"p"),e._uU(418,"If you're using the "),e.TgZ(419,"code"),e._uU(420,"graphql-ws"),e.qZA(),e._uU(421," package, the signature of the "),e.TgZ(422,"code"),e._uU(423,"onConnect"),e.qZA(),e._uU(424," callback will be slightly different:"),e.qZA(),e.TgZ(425,"pre")(426,"code",8),e._uU(427,"\nGraphQLModule.forRoot<ApolloDriverConfig>({\n  driver: ApolloDriver,\n  subscriptions: {\n    'graphql-ws': {\n      onConnect: (context: Context<any>) => {\n        const { connectionParams, extra } = context;\n        // user validation will remain the same as in the example above\n        // when using with graphql-ws, additional context value should be stored in the extra field\n        extra.user = { user: {} };\n      },\n    },\n  },\n  context: ({ extra }) => {\n    // you can now access your additional context value through the extra field\n  },\n});\n"),e.qZA()(),e.TgZ(428,"h4",31)(429,"span"),e._uU(430,"Enable subscriptions with Mercurius driver"),e.qZA()(),e.TgZ(431,"p"),e._uU(432,"To enable subscriptions, set the "),e.TgZ(433,"code"),e._uU(434,"subscription"),e.qZA(),e._uU(435," property to "),e.TgZ(436,"code"),e._uU(437,"true"),e.qZA(),e._uU(438,"."),e.qZA(),e.TgZ(439,"pre")(440,"code",8),e._uU(441,"\nGraphQLModule.forRoot<MercuriusDriverConfig>({\n  driver: MercuriusDriver,\n  subscription: true,\n}),\n"),e.qZA()(),e.TgZ(442,"blockquote",12)(443,"strong"),e._uU(444,"Hint"),e.qZA(),e._uU(445," You can also pass the options object to set up a custom emitter, validate incoming connections, etc. Read more "),e.TgZ(446,"a",32),e._uU(447,"here"),e.qZA(),e._uU(448," (see "),e.TgZ(449,"code"),e._uU(450,"subscription"),e.qZA(),e._uU(451,").\n"),e.qZA(),e.TgZ(452,"h4",33)(453,"span"),e._uU(454,"Code first"),e.qZA()(),e.TgZ(455,"p"),e._uU(456,"To create a subscription using the code first approach, we use the "),e.TgZ(457,"code"),e._uU(458,"@Subscription()"),e.qZA(),e._uU(459," decorator (exported from the "),e.TgZ(460,"code"),e._uU(461,"@nestjs/graphql"),e.qZA(),e._uU(462," package) and the "),e.TgZ(463,"code"),e._uU(464,"PubSub"),e.qZA(),e._uU(465," class from the "),e.TgZ(466,"code"),e._uU(467,"mercurius"),e.qZA(),e._uU(468," package, which provides a simple "),e.TgZ(469,"strong"),e._uU(470,"publish/subscribe API"),e.qZA(),e._uU(471,"."),e.qZA(),e.TgZ(472,"p"),e._uU(473,"The following subscription handler takes care of "),e.TgZ(474,"strong"),e._uU(475,"subscribing"),e.qZA(),e._uU(476," to an event by calling "),e.TgZ(477,"code"),e._uU(478,"PubSub#asyncIterator"),e.qZA(),e._uU(479,". This method takes a single argument, the "),e.TgZ(480,"code"),e._uU(481,"triggerName"),e.qZA(),e._uU(482,", which corresponds to an event topic name."),e.qZA(),e.TgZ(483,"pre")(484,"code",8),e._uU(485,"\n@Resolver((of) => Author)\nexport class AuthorResolver {\n  // ...\n  @Subscription((returns) => Comment)\n  commentAdded(@Context('pubsub') pubSub: PubSub) {\n    return pubSub.subscribe('commentAdded');\n  }\n}\n"),e.qZA()(),e.TgZ(486,"blockquote",12)(487,"strong"),e._uU(488,"Hint"),e.qZA(),e._uU(489," All decorators used in the example above are exported from the "),e.TgZ(490,"code"),e._uU(491,"@nestjs/graphql"),e.qZA(),e._uU(492," package, while the "),e.TgZ(493,"code"),e._uU(494,"PubSub"),e.qZA(),e._uU(495," class is exported from the "),e.TgZ(496,"code"),e._uU(497,"mercurius"),e.qZA(),e._uU(498," package.\n"),e.qZA(),e.TgZ(499,"blockquote",9)(500,"strong"),e._uU(501,"Note"),e.qZA(),e.TgZ(502,"code"),e._uU(503,"PubSub"),e.qZA(),e._uU(504," is a class that exposes a simple "),e.TgZ(505,"code"),e._uU(506,"publish"),e.qZA(),e._uU(507," and "),e.TgZ(508,"code"),e._uU(509,"subscribe"),e.qZA(),e._uU(510," API. Check out "),e.TgZ(511,"a",34),e._uU(512,"this section"),e.qZA(),e._uU(513," on how to register a custom "),e.TgZ(514,"code"),e._uU(515,"PubSub"),e.qZA(),e._uU(516," class.\n"),e.qZA(),e.TgZ(517,"p"),e._uU(518,"This will result in generating the following part of the GraphQL schema in SDL:"),e.qZA(),e.TgZ(519,"pre")(520,"code",17),e._uU(521,"\ntype Subscription {\n  commentAdded(): Comment!\n}\n"),e.qZA()(),e.TgZ(522,"p"),e._uU(523,"Note that subscriptions, by definition, return an object with a single top level property whose key is the name of the subscription. This name is either inherited from the name of the subscription handler method (i.e., "),e.TgZ(524,"code"),e._uU(525,"commentAdded"),e.qZA(),e._uU(526," above), or is provided explicitly by passing an option with the key "),e.TgZ(527,"code"),e._uU(528,"name"),e.qZA(),e._uU(529," as the second argument to the "),e.TgZ(530,"code"),e._uU(531,"@Subscription()"),e.qZA(),e._uU(532," decorator, as shown below."),e.qZA(),e.TgZ(533,"pre")(534,"code",8),e._uU(535,"\n@Subscription(returns => Comment, {\n  name: 'commentAdded',\n})\nsubscribeToCommentAdded(@Context('pubsub') pubSub: PubSub) {\n  return pubSub.subscribe('commentAdded');\n}\n"),e.qZA()(),e.TgZ(536,"p"),e._uU(537,"This construct produces the same SDL as the previous code sample, but allows us to decouple the method name from the subscription."),e.qZA(),e.TgZ(538,"h4",35)(539,"span"),e._uU(540,"Publishing"),e.qZA()(),e.TgZ(541,"p"),e._uU(542,"Now, to publish the event, we use the "),e.TgZ(543,"code"),e._uU(544,"PubSub#publish"),e.qZA(),e._uU(545," method. This is often used within a mutation to trigger a client-side update when a part of the object graph has changed. For example:"),e.qZA(),e.TgZ(546,"span",19),e._uU(547),e.ALo(548,"extension"),e._UZ(549,"app-tabs",null,36),e.qZA(),e.TgZ(551,"pre")(552,"code",8),e._uU(553,"\n@Mutation(returns => Post)\nasync addComment(\n  @Args('postId', { type: () => Int }) postId: number,\n  @Args('comment', { type: () => Comment }) comment: CommentInput,\n  @Context('pubsub') pubSub: PubSub,\n) {\n  const newComment = this.commentsService.addComment({ id: postId, comment });\n  await pubSub.publish({\n    topic: 'commentAdded',\n    payload: {\n      commentAdded: newComment\n    }\n  });\n  return newComment;\n}\n"),e.qZA()(),e.TgZ(554,"p"),e._uU(555,"As mentioned, the subscription, by definition, returns a value and that value has a shape. Look again at the generated SDL for our "),e.TgZ(556,"code"),e._uU(557,"commentAdded"),e.qZA(),e._uU(558," subscription:"),e.qZA(),e.TgZ(559,"pre")(560,"code",17),e._uU(561,"\ntype Subscription {\n  commentAdded(): Comment!\n}\n"),e.qZA()(),e.TgZ(562,"p"),e._uU(563,"This tells us that the subscription must return an object with a top-level property name of "),e.TgZ(564,"code"),e._uU(565,"commentAdded"),e.qZA(),e._uU(566," that has a value which is a "),e.TgZ(567,"code"),e._uU(568,"Comment"),e.qZA(),e._uU(569," object. The important point to note is that the shape of the event payload emitted by the "),e.TgZ(570,"code"),e._uU(571,"PubSub#publish"),e.qZA(),e._uU(572," method must correspond to the shape of the value expected to return from the subscription. So, in our example above, the "),e.TgZ(573,"code"),e._uU(574),e.qZA(),e._uU(575," statement publishes a "),e.TgZ(576,"code"),e._uU(577,"commentAdded"),e.qZA(),e._uU(578," event with the appropriately shaped payload. If these shapes don't match, your subscription will fail during the GraphQL validation phase."),e.qZA(),e.TgZ(579,"h4",37)(580,"span"),e._uU(581,"Filtering subscriptions"),e.qZA()(),e.TgZ(582,"p"),e._uU(583,"To filter out specific events, set the "),e.TgZ(584,"code"),e._uU(585,"filter"),e.qZA(),e._uU(586," property to a filter function. This function acts similar to the function passed to an array "),e.TgZ(587,"code"),e._uU(588,"filter"),e.qZA(),e._uU(589,". It takes two arguments: "),e.TgZ(590,"code"),e._uU(591,"payload"),e.qZA(),e._uU(592," containing the event payload (as sent by the event publisher), and "),e.TgZ(593,"code"),e._uU(594,"variables"),e.qZA(),e._uU(595," taking any arguments passed in during the subscription request. It returns a boolean determining whether this event should be published to client listeners."),e.qZA(),e.TgZ(596,"pre")(597,"code",8),e._uU(598,"\n@Subscription(returns => Comment, {\n  filter: (payload, variables) =>\n    payload.commentAdded.title === variables.title,\n})\ncommentAdded(@Args('title') title: string, @Context('pubsub') pubSub: PubSub) {\n  return pubSub.subscribe('commentAdded');\n}\n"),e.qZA()(),e.TgZ(599,"p"),e._uU(600,"If you need to access injected providers (e.g., use an external service to validate the data), use the following construction."),e.qZA(),e.TgZ(601,"pre")(602,"code",8),e._uU(603,"\n@Subscription(returns => Comment, {\n  filter(this: AuthorResolver, payload, variables) {\n    // \"this\" refers to an instance of \"AuthorResolver\"\n    return payload.commentAdded.title === variables.title;\n  }\n})\ncommentAdded(@Args('title') title: string, @Context('pubsub') pubSub: PubSub) {\n  return pubSub.subscribe('commentAdded');\n}\n"),e.qZA()(),e.TgZ(604,"h4",38)(605,"span"),e._uU(606,"Schema first"),e.qZA()(),e.TgZ(607,"p"),e._uU(608,"To create an equivalent subscription in Nest, we'll make use of the "),e.TgZ(609,"code"),e._uU(610,"@Subscription()"),e.qZA(),e._uU(611," decorator."),e.qZA(),e.TgZ(612,"pre")(613,"code",8),e._uU(614,"\nconst pubSub = new PubSub();\n\n@Resolver('Author')\nexport class AuthorResolver {\n  // ...\n  @Subscription()\n  commentAdded(@Context('pubsub') pubSub: PubSub) {\n    return pubSub.subscribe('commentAdded');\n  }\n}\n"),e.qZA()(),e.TgZ(615,"p"),e._uU(616,"To filter out specific events based on context and arguments, set the "),e.TgZ(617,"code"),e._uU(618,"filter"),e.qZA(),e._uU(619," property."),e.qZA(),e.TgZ(620,"pre")(621,"code",8),e._uU(622,"\n@Subscription('commentAdded', {\n  filter: (payload, variables) =>\n    payload.commentAdded.title === variables.title,\n})\ncommentAdded(@Context('pubsub') pubSub: PubSub) {\n  return pubSub.subscribe('commentAdded');\n}\n"),e.qZA()(),e.TgZ(623,"p"),e._uU(624,"If you need to access injected providers (e.g., use an external service to validate the data), use the following construction:"),e.qZA(),e.TgZ(625,"pre")(626,"code",8),e._uU(627,"\n@Subscription('commentAdded', {\n  filter(this: AuthorResolver, payload, variables) {\n    // \"this\" refers to an instance of \"AuthorResolver\"\n    return payload.commentAdded.title === variables.title;\n  }\n})\ncommentAdded(@Context('pubsub') pubSub: PubSub) {\n  return pubSub.subscribe('commentAdded');\n}\n"),e.qZA()(),e.TgZ(628,"p"),e._uU(629,"The last step is to update the type definitions file."),e.qZA(),e.TgZ(630,"pre")(631,"code",17),e._uU(632,"\ntype Author {\n  id: Int!\n  firstName: String\n  lastName: String\n  posts: [Post]\n}\n\ntype Post {\n  id: Int!\n  title: String\n  votes: Int\n}\n\ntype Query {\n  author(id: Int!): Author\n}\n\ntype Comment {\n  id: String\n  content: String\n}\n\ntype Subscription {\n  commentAdded(title: String!): Comment\n}\n"),e.qZA()(),e.TgZ(633,"p"),e._uU(634,"With this, we've created a single "),e.TgZ(635,"code"),e._uU(636,"commentAdded(title: String!): Comment"),e.qZA(),e._uU(637," subscription."),e.qZA(),e.TgZ(638,"h4",39)(639,"span"),e._uU(640,"PubSub"),e.qZA()(),e.TgZ(641,"p"),e._uU(642,"In the examples above, we used the default "),e.TgZ(643,"code"),e._uU(644,"PubSub"),e.qZA(),e._uU(645," emitter ("),e.TgZ(646,"a",40),e._uU(647,"mqemitter"),e.qZA(),e._uU(648,")\nThe preferred approach (for production) is to use "),e.TgZ(649,"code"),e._uU(650,"mqemitter-redis"),e.qZA(),e._uU(651,". Alternatively, a custom "),e.TgZ(652,"code"),e._uU(653,"PubSub"),e.qZA(),e._uU(654," implementation can be provided (read more "),e.TgZ(655,"a",41),e._uU(656,"here"),e.qZA(),e._uU(657,")"),e.qZA(),e.TgZ(658,"pre")(659,"code",8),e._uU(660,"\nGraphQLModule.forRoot<MercuriusDriverConfig>({\n  driver: MercuriusDriver,\n  subscription: {\n    emitter: require('mqemitter-redis')({\n      port: 6579,\n      host: '127.0.0.1',\n    }),\n  },\n});\n"),e.qZA()(),e.TgZ(661,"h4",42)(662,"span"),e._uU(663,"Authentication over WebSockets"),e.qZA()(),e.TgZ(664,"p"),e._uU(665,"Checking whether the user is authenticated can be done inside the "),e.TgZ(666,"code"),e._uU(667,"verifyClient"),e.qZA(),e._uU(668," callback function that you can specify in the "),e.TgZ(669,"code"),e._uU(670,"subscription"),e.qZA(),e._uU(671," options."),e.qZA(),e.TgZ(672,"p"),e._uU(673,"The "),e.TgZ(674,"code"),e._uU(675,"verifyClient"),e.qZA(),e._uU(676," will receive the "),e.TgZ(677,"code"),e._uU(678,"info"),e.qZA(),e._uU(679," object as a first argument which you can use to retrive the request's headers."),e.qZA(),e.TgZ(680,"pre")(681,"code",8),e._uU(682,"\nGraphQLModule.forRoot<MercuriusDriverConfig>({\n  driver: MercuriusDriver,\n  subscription: {\n    verifyClient: (info, next) => {\n      const authorization = info.req.headers?.authorization as string;\n      if (!authorization?.startsWith('Bearer ')) {\n        return next(false);\n      }\n      next(true);\n    },\n  }\n}),\n"),e.qZA()()()),2&o){const p=e.MAs(175),c=e.MAs(550);e.xp6(172),e.hij(" ",e.xi3(173,10,"posts/posts.resolver",p.isJsActive),"\n"),e.xp6(33),e.AsE("pubSub.publish('commentAdded', ","{"," commentAdded: newComment ","}",")"),e.xp6(47),e.AsE("","{"," commentAdded: newComment ","}",""),e.xp6(295),e.hij(" ",e.xi3(548,13,"posts/posts.resolver",c.isJsActive),"\n"),e.xp6(27),e.HOy("pubSub.publish(","{"," topic: 'commentAdded', payload: ","{"," commentAdded: newComment ","}"," ","}",")")}},dependencies:[l.n,a.U,u.yS,d.F],encapsulation:2,changeDetection:0}),t})(),data:{title:"GraphQL + TypeScript - Subscriptions"}},{path:"guards-interceptors",redirectTo:"other-features"},{path:"tooling",redirectTo:"other-features"},{path:"other-features",component:y,data:{title:"GraphQL + TypeScript - Other features"}},{path:"federation",component:q,data:{title:"GraphQL + TypeScript - Federation"}},{path:"directives",component:A,data:{title:"GraphQL + TypeScript - Directives"}},{path:"migration-guide",component:U,data:{title:"GraphQL + TypeScript - Migration guide"}},{path:"field-middleware",component:T,data:{title:"GraphQL + TypeScript - Field middleware"}},{path:"complexity",component:_,data:{title:"GraphQL + TypeScript - Complexity"}},{path:"extensions",component:f,data:{title:"GraphQL + TypeScript - Extensions"}},{path:"enums",redirectTo:"unions-and-enums"},{path:"unions",redirectTo:"unions-and-enums"},{path:"unions-and-enums",component:(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-unions-enums"]],features:[e.qOj],decls:252,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/unions-and-enums.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","unions"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/#union-types"],["appAnchor","","id","code-first"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/schema/unions-interfaces/#union-type"],[1,"language-typescript"],[1,"warning"],[1,"language-graphql"],["appAnchor","","id","schema-first"],["routerLink","/graphql/quick-start"],[1,"info"],["id","enums"],["rel","nofollow","target","_blank","href","https://graphql.org/learn/schema/#enumeration-types"],["appAnchor","","id","code-first-1"],["appAnchor","","id","schema-first-1"],["rel","nofollow","target","_blank","href","https://www.apollographql.com/docs/apollo-server/schema/scalars-enums/#internal-values"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Unions"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"Union types are very similar to interfaces, but they don't get to specify any common fields between the types (read more "),e.TgZ(9,"a",6),e._uU(10,"here"),e.qZA(),e._uU(11,"). Unions are useful for returning disjoint data types from a single field."),e.qZA(),e.TgZ(12,"h4",7)(13,"span"),e._uU(14,"Code first"),e.qZA()(),e.TgZ(15,"p"),e._uU(16,"To define a GraphQL union type, we must define classes that this union will be composed of. Following the "),e.TgZ(17,"a",8),e._uU(18,"example"),e.qZA(),e._uU(19," from the Apollo documentation, we'll create two classes. First, "),e.TgZ(20,"code"),e._uU(21,"Book"),e.qZA(),e._uU(22,":"),e.qZA(),e.TgZ(23,"pre")(24,"code",9),e._uU(25,"\nimport { Field, ObjectType } from '@nestjs/graphql';\n\n@ObjectType()\nexport class Book {\n  @Field()\n  title: string;\n}\n"),e.qZA()(),e.TgZ(26,"p"),e._uU(27,"And then "),e.TgZ(28,"code"),e._uU(29,"Author"),e.qZA(),e._uU(30,":"),e.qZA(),e.TgZ(31,"pre")(32,"code",9),e._uU(33,"\nimport { Field, ObjectType } from '@nestjs/graphql';\n\n@ObjectType()\nexport class Author {\n  @Field()\n  name: string;\n}\n"),e.qZA()(),e.TgZ(34,"p"),e._uU(35,"With this in place, register the "),e.TgZ(36,"code"),e._uU(37,"ResultUnion"),e.qZA(),e._uU(38," union using the "),e.TgZ(39,"code"),e._uU(40,"createUnionType"),e.qZA(),e._uU(41," function exported from the "),e.TgZ(42,"code"),e._uU(43,"@nestjs/graphql"),e.qZA(),e._uU(44," package:"),e.qZA(),e.TgZ(45,"pre")(46,"code",9),e._uU(47,"\nexport const ResultUnion = createUnionType({\n  name: 'ResultUnion',\n  types: () => [Author, Book] as const,\n});\n"),e.qZA()(),e.TgZ(48,"blockquote",10)(49,"strong"),e._uU(50,"Warning"),e.qZA(),e._uU(51," The array returned by the "),e.TgZ(52,"code"),e._uU(53,"types"),e.qZA(),e._uU(54," property of the "),e.TgZ(55,"code"),e._uU(56,"createUnionType"),e.qZA(),e._uU(57," function should be given a const assertion. If the const assertion is not given, a wrong declaration file will be generated at compile time, and an error will occur when using it from another project.\n"),e.qZA(),e.TgZ(58,"p"),e._uU(59,"Now, we can reference the "),e.TgZ(60,"code"),e._uU(61,"ResultUnion"),e.qZA(),e._uU(62," in our query:"),e.qZA(),e.TgZ(63,"pre")(64,"code",9),e._uU(65,"\n@Query(returns => [ResultUnion])\nsearch(): Array<typeof ResultUnion> {\n  return [new Author(), new Book()];\n}\n"),e.qZA()(),e.TgZ(66,"p"),e._uU(67,"This will result in generating the following part of the GraphQL schema in SDL:"),e.qZA(),e.TgZ(68,"pre")(69,"code",11),e._uU(70,"\ntype Author {\n  name: String!\n}\n\ntype Book {\n  title: String!\n}\n\nunion ResultUnion = Author | Book\n\ntype Query {\n  search: [ResultUnion!]!\n}\n"),e.qZA()(),e.TgZ(71,"p"),e._uU(72,"The default "),e.TgZ(73,"code"),e._uU(74,"resolveType()"),e.qZA(),e._uU(75," function generated by the library will extract the type based on the value returned from the resolver method. That means returning class instances instead of literal JavaScript object is obligatory."),e.qZA(),e.TgZ(76,"p"),e._uU(77,"To provide a customized "),e.TgZ(78,"code"),e._uU(79,"resolveType()"),e.qZA(),e._uU(80," function, pass the "),e.TgZ(81,"code"),e._uU(82,"resolveType"),e.qZA(),e._uU(83," property to the options object passed into the "),e.TgZ(84,"code"),e._uU(85,"createUnionType()"),e.qZA(),e._uU(86," function, as follows:"),e.qZA(),e.TgZ(87,"pre")(88,"code",9),e._uU(89,"\nexport const ResultUnion = createUnionType({\n  name: 'ResultUnion',\n  types: () => [Author, Book] as const,\n  resolveType(value) {\n    if (value.name) {\n      return Author;\n    }\n    if (value.title) {\n      return Book;\n    }\n    return null;\n  },\n});\n"),e.qZA()(),e.TgZ(90,"h4",12)(91,"span"),e._uU(92,"Schema first"),e.qZA()(),e.TgZ(93,"p"),e._uU(94,"To define a union in the schema first approach, simply create a GraphQL union with SDL."),e.qZA(),e.TgZ(95,"pre")(96,"code",11),e._uU(97,"\ntype Author {\n  name: String!\n}\n\ntype Book {\n  title: String!\n}\n\nunion ResultUnion = Author | Book\n"),e.qZA()(),e.TgZ(98,"p"),e._uU(99,"Then, you can use the typings generation feature (as shown in the "),e.TgZ(100,"a",13),e._uU(101,"quick start"),e.qZA(),e._uU(102," chapter) to generate corresponding TypeScript definitions:"),e.qZA(),e.TgZ(103,"pre")(104,"code",9),e._uU(105,"\nexport class Author {\n  name: string;\n}\n\nexport class Book {\n  title: string;\n}\n\nexport type ResultUnion = Author | Book;\n"),e.qZA()(),e.TgZ(106,"p"),e._uU(107,"Unions require an extra "),e.TgZ(108,"code"),e._uU(109,"__resolveType"),e.qZA(),e._uU(110," field in the resolver map to determine which type the union should resolve to. Also, note that the "),e.TgZ(111,"code"),e._uU(112,"ResultUnionResolver"),e.qZA(),e._uU(113," class has to be registered as a provider in any module. Let's create a "),e.TgZ(114,"code"),e._uU(115,"ResultUnionResolver"),e.qZA(),e._uU(116," class and define the "),e.TgZ(117,"code"),e._uU(118,"__resolveType"),e.qZA(),e._uU(119," method."),e.qZA(),e.TgZ(120,"pre")(121,"code",9),e._uU(122,"\n@Resolver('ResultUnion')\nexport class ResultUnionResolver {\n  @ResolveField()\n  __resolveType(value) {\n    if (value.name) {\n      return 'Author';\n    }\n    if (value.title) {\n      return 'Book';\n    }\n    return null;\n  }\n}\n"),e.qZA()(),e.TgZ(123,"blockquote",14)(124,"strong"),e._uU(125,"Hint"),e.qZA(),e._uU(126," All decorators are exported from the "),e.TgZ(127,"code"),e._uU(128,"@nestjs/graphql"),e.qZA(),e._uU(129," package.\n"),e.qZA(),e.TgZ(130,"h3",15),e._uU(131,"Enums"),e.qZA(),e.TgZ(132,"p"),e._uU(133,"Enumeration types are a special kind of scalar that is restricted to a particular set of allowed values (read more "),e.TgZ(134,"a",16),e._uU(135,"here"),e.qZA(),e._uU(136,"). This allows you to:"),e.qZA(),e.TgZ(137,"ul")(138,"li"),e._uU(139,"validate that any arguments of this type are one of the allowed values"),e.qZA(),e.TgZ(140,"li"),e._uU(141,"communicate through the type system that a field will always be one of a finite set of values"),e.qZA()(),e.TgZ(142,"h4",17)(143,"span"),e._uU(144,"Code first"),e.qZA()(),e.TgZ(145,"p"),e._uU(146,"When using the code first approach, you define a GraphQL enum type by simply creating a TypeScript enum."),e.qZA(),e.TgZ(147,"pre")(148,"code",9),e._uU(149,"\nexport enum AllowedColor {\n  RED,\n  GREEN,\n  BLUE,\n}\n"),e.qZA()(),e.TgZ(150,"p"),e._uU(151,"With this in place, register the "),e.TgZ(152,"code"),e._uU(153,"AllowedColor"),e.qZA(),e._uU(154," enum using the "),e.TgZ(155,"code"),e._uU(156,"registerEnumType"),e.qZA(),e._uU(157," function exported from the "),e.TgZ(158,"code"),e._uU(159,"@nestjs/graphql"),e.qZA(),e._uU(160," package:"),e.qZA(),e.TgZ(161,"pre")(162,"code",9),e._uU(163,"\nregisterEnumType(AllowedColor, {\n  name: 'AllowedColor',\n});\n"),e.qZA()(),e.TgZ(164,"p"),e._uU(165,"Now you can reference the "),e.TgZ(166,"code"),e._uU(167,"AllowedColor"),e.qZA(),e._uU(168," in our types:"),e.qZA(),e.TgZ(169,"pre")(170,"code",9),e._uU(171,"\n@Field(type => AllowedColor)\nfavoriteColor: AllowedColor;\n"),e.qZA()(),e.TgZ(172,"p"),e._uU(173,"This will result in generating the following part of the GraphQL schema in SDL:"),e.qZA(),e.TgZ(174,"pre")(175,"code",11),e._uU(176,"\nenum AllowedColor {\n  RED\n  GREEN\n  BLUE\n}\n"),e.qZA()(),e.TgZ(177,"p"),e._uU(178,"To provide a description for the enum, pass the "),e.TgZ(179,"code"),e._uU(180,"description"),e.qZA(),e._uU(181," property into the "),e.TgZ(182,"code"),e._uU(183,"registerEnumType()"),e.qZA(),e._uU(184," function."),e.qZA(),e.TgZ(185,"pre")(186,"code",9),e._uU(187,"\nregisterEnumType(AllowedColor, {\n  name: 'AllowedColor',\n  description: 'The supported colors.',\n});\n"),e.qZA()(),e.TgZ(188,"p"),e._uU(189,"To provide a description for the enum values, or to mark a value as deprecated, pass the "),e.TgZ(190,"code"),e._uU(191,"valuesMap"),e.qZA(),e._uU(192," property, as follows:"),e.qZA(),e.TgZ(193,"pre")(194,"code",9),e._uU(195,"\nregisterEnumType(AllowedColor, {\n  name: 'AllowedColor',\n  description: 'The supported colors.',\n  valuesMap: {\n    RED: {\n      description: 'The default color.',\n    },\n    BLUE: {\n      deprecationReason: 'Too blue.',\n    },\n  },\n});\n"),e.qZA()(),e.TgZ(196,"p"),e._uU(197,"This will generate the following GraphQL schema in SDL:"),e.qZA(),e.TgZ(198,"pre")(199,"code",11),e._uU(200,'\n"""\nThe supported colors.\n"""\nenum AllowedColor {\n  """\n  The default color.\n  """\n  RED\n  GREEN\n  BLUE @deprecated(reason: "Too blue.")\n}\n'),e.qZA()(),e.TgZ(201,"h4",18)(202,"span"),e._uU(203,"Schema first"),e.qZA()(),e.TgZ(204,"p"),e._uU(205,"To define an enumerator in the schema first approach, simply create a GraphQL enum with SDL."),e.qZA(),e.TgZ(206,"pre")(207,"code",11),e._uU(208,"\nenum AllowedColor {\n  RED\n  GREEN\n  BLUE\n}\n"),e.qZA()(),e.TgZ(209,"p"),e._uU(210,"Then you can use the typings generation feature (as shown in the "),e.TgZ(211,"a",13),e._uU(212,"quick start"),e.qZA(),e._uU(213," chapter) to generate corresponding TypeScript definitions:"),e.qZA(),e.TgZ(214,"pre")(215,"code",9),e._uU(216,"\nexport enum AllowedColor {\n  RED\n  GREEN\n  BLUE\n}\n"),e.qZA()(),e.TgZ(217,"p"),e._uU(218,"Sometimes a backend forces a different value for an enum internally than in the public API. In this example the API contains "),e.TgZ(219,"code"),e._uU(220,"RED"),e.qZA(),e._uU(221,", however in resolvers we may use "),e.TgZ(222,"code"),e._uU(223,"#f00"),e.qZA(),e._uU(224," instead (read more "),e.TgZ(225,"a",19),e._uU(226,"here"),e.qZA(),e._uU(227,"). To accomplish this, declare a resolver object for the "),e.TgZ(228,"code"),e._uU(229,"AllowedColor"),e.qZA(),e._uU(230," enum:"),e.qZA(),e.TgZ(231,"pre")(232,"code",9),e._uU(233,"\nexport const allowedColorResolver: Record<keyof typeof AllowedColor, any> = {\n  RED: '#f00',\n};\n"),e.qZA()(),e.TgZ(234,"blockquote",14)(235,"strong"),e._uU(236,"Hint"),e.qZA(),e._uU(237," All decorators are exported from the "),e.TgZ(238,"code"),e._uU(239,"@nestjs/graphql"),e.qZA(),e._uU(240," package.\n"),e.qZA(),e.TgZ(241,"p"),e._uU(242,"Then use this resolver object together with the "),e.TgZ(243,"code"),e._uU(244,"resolvers"),e.qZA(),e._uU(245," property of the "),e.TgZ(246,"code"),e._uU(247,"GraphQLModule#forRoot()"),e.qZA(),e._uU(248," method, as follows:"),e.qZA(),e.TgZ(249,"pre")(250,"code",9),e._uU(251,"\nGraphQLModule.forRoot({\n  resolvers: {\n    AllowedColor: allowedColorResolver,\n  },\n});\n"),e.qZA()()())},dependencies:[a.U,u.yS],encapsulation:2,changeDetection:0}),t})(),data:{title:"GraphQL + TypeScript - Unions and Enums"}},{path:"plugins",component:x,data:{title:"GraphQL + TypeScript - Plugins"}},{path:"interfaces",component:v,data:{title:"GraphQL + TypeScript - Interfaces"}},{path:"mapped-types",component:b,data:{title:"GraphQL + TypeScript - Mapped types"}},{path:"cli-plugin",component:m,data:{title:"GraphQL + TypeScript - CLI Plugin"}},{path:"generating-sdl",component:(()=>{class t extends s.y{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=e.n5z(t)))(r||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-schema-generator"]],features:[e.qOj],decls:70,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/schema-generator.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","generating-sdl"],[1,"warning"],[1,"language-typescript"],[1,"info"],["appAnchor","","id","usage"]],template:function(o,r){1&o&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Generating SDL"),e.qZA(),e.TgZ(7,"blockquote",6)(8,"strong"),e._uU(9,"Warning"),e.qZA(),e._uU(10," This chapter applies only to the code first approach.\n"),e.qZA(),e.TgZ(11,"p"),e._uU(12,"To manually generate a GraphQL SDL schema (i.e., without running an application, connecting to the database, hooking up resolvers, etc.), use the "),e.TgZ(13,"code"),e._uU(14,"GraphQLSchemaBuilderModule"),e.qZA(),e._uU(15,"."),e.qZA(),e.TgZ(16,"pre")(17,"code",7),e._uU(18,"\nasync function generateSchema() {\n  const app = await NestFactory.create(GraphQLSchemaBuilderModule);\n  await app.init();\n\n  const gqlSchemaFactory = app.get(GraphQLSchemaFactory);\n  const schema = await gqlSchemaFactory.create([RecipesResolver]);\n  console.log(printSchema(schema));\n}\n"),e.qZA()(),e.TgZ(19,"blockquote",8)(20,"strong"),e._uU(21,"Hint"),e.qZA(),e._uU(22," The "),e.TgZ(23,"code"),e._uU(24,"GraphQLSchemaBuilderModule"),e.qZA(),e._uU(25," and "),e.TgZ(26,"code"),e._uU(27,"GraphQLSchemaFactory"),e.qZA(),e._uU(28," are imported from the "),e.TgZ(29,"code"),e._uU(30,"@nestjs/graphql"),e.qZA(),e._uU(31," package. The "),e.TgZ(32,"code"),e._uU(33,"printSchema"),e.qZA(),e._uU(34," function is imported from the "),e.TgZ(35,"code"),e._uU(36,"graphql"),e.qZA(),e._uU(37," package.\n"),e.qZA(),e.TgZ(38,"h4",9)(39,"span"),e._uU(40,"Usage"),e.qZA()(),e.TgZ(41,"p"),e._uU(42,"The "),e.TgZ(43,"code"),e._uU(44,"gqlSchemaFactory.create()"),e.qZA(),e._uU(45," method takes an array of resolver class references. For example:"),e.qZA(),e.TgZ(46,"pre")(47,"code",7),e._uU(48,"\nconst schema = await gqlSchemaFactory.create([\n  RecipesResolver,\n  AuthorsResolver,\n  PostsResolvers,\n]);\n"),e.qZA()(),e.TgZ(49,"p"),e._uU(50,"It also takes a second optional argument with an array of scalar classes:"),e.qZA(),e.TgZ(51,"pre")(52,"code",7),e._uU(53,"\nconst schema = await gqlSchemaFactory.create(\n  [RecipesResolver, AuthorsResolver, PostsResolvers],\n  [DurationScalar, DateScalar],\n);\n"),e.qZA()(),e.TgZ(54,"p"),e._uU(55,"Lastly, you can pass an options object:"),e.qZA(),e.TgZ(56,"pre")(57,"code",7),e._uU(58,"\nconst schema = await gqlSchemaFactory.create([RecipesResolver], {\n  skipCheck: true,\n  orphanedTypes: [],\n});\n"),e.qZA()(),e.TgZ(59,"ul")(60,"li")(61,"code"),e._uU(62,"skipCheck"),e.qZA(),e._uU(63,": ignore schema validation; boolean, defaults to "),e.TgZ(64,"code"),e._uU(65,"false"),e.qZA()(),e.TgZ(66,"li")(67,"code"),e._uU(68,"orphanedTypes"),e.qZA(),e._uU(69,": list of classes that are not explicitly referenced (not part of the object graph) to be generated. Normally, if a class is declared but isn't otherwise referenced in the graph, it's omitted. The property value is an array of class references."),e.qZA()()())},dependencies:[a.U],encapsulation:2,changeDetection:0}),t})(),data:{title:"GraphQL + TypeScript - Generating SDL"}}];let j=(()=>{class t{}return t.\u0275fac=function(o){return new(o||t)},t.\u0275mod=e.oAB({type:t}),t.\u0275inj=e.cJS({imports:[g.ez,Z.m,u.Bz.forChild(C)]}),t})()}}]);