"use strict";(self.webpackChunkdocs_nestjs_com=self.webpackChunkdocs_nestjs_com||[]).push([[823],{823:(I,y,r)=>{r.r(y),r.d(y,{SecurityModule:()=>S});var v=r(9808),h=r(215),x=r(4466),a=r(4834),e=r(4893),b=r(4336),i=r(4521),j=r(8857),w=r(7297);const k=[{path:"authentication",component:(()=>{class t extends a.y{}return t.\u0275fac=function(){let o;return function(s){return(o||(o=e.n5z(t)))(s||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-authentication"]],features:[e.qOj],decls:1188,vars:122,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/security/authentication.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","authentication"],["rel","nofollow","target","_blank","href","https://github.com/jaredhanson/passport"],["rel","nofollow","target","_blank","href","https://jwt.io/"],["rel","nofollow","target","_blank","href","https://github.com/expressjs/session"],["rel","nofollow","target","_blank","href","http://www.passportjs.org/"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/nest/tree/master/sample/19-auth-jwt"],["appAnchor","","id","authentication-requirements"],["rel","nofollow","target","_blank","href","https://tools.ietf.org/html/rfc6750"],["rel","nofollow","target","_blank","href","https://github.com/jaredhanson/passport-local"],[1,"language-bash"],[1,"warning"],["appAnchor","","id","implementing-passport-strategies"],[1,"filename"],["app0f7526eec0967414f3585ffd9fa1cd8f9e3e119c",""],[1,"language-typescript"],["app1345a23a86d67fffc485c8b684968853eb16f68a",""],["app13fa5aa8d5da4fcf3bf01ab8304efe70460c2e52",""],[1,"Warning"],["rel","nofollow","target","_blank","href","https://github.com/kelektiv/node.bcrypt.js#readme"],["app5126b562e3d0760413126840ec6bf79b8c1cad80",""],["appAnchor","","id","implementing-passport-local"],["appd82f60c20a093a89fe46447324ae5d52246a7052",""],[1,"info"],["rel","nofollow","target","_blank","href","http://www.passportjs.org/docs/configure/"],["href","exception-filters"],["appe9e4e08fb629448f2e2c78de41fa93a7cdceee62",""],["appAnchor","","id","built-in-passport-guards"],["href","guards"],["appAnchor","","id","login-route"],["appaae9bed2939ab7d89e7ea666856b8290165c6ff9",""],["rel","nofollow","target","_blank","href","https://curl.haxx.se/"],["appb22c3e655e39411ba899a7abbca288de23081879",""],["appAnchor","","id","jwt-functionality"],["rel","nofollow","target","_blank","href","https://github.com/nestjs/jwt"],["app0b454f3a94b54eb8065e1b31acf5cf80e8e24402",""],["app5d7fa71755a298799e862111cfb19fa49d83a769",""],["app275f1133396f0aaadd29d117563f7631911ef2dd",""],["rel","nofollow","target","_blank","href","https://github.com/nestjs/jwt/blob/master/README.md"],["rel","nofollow","target","_blank","href","https://github.com/auth0/node-jsonwebtoken#usage"],["app6603161dfb2860c4b281d6d001fde8fd3994ddd0",""],["appAnchor","","id","implementing-passport-jwt"],["rel","nofollow","target","_blank","href","https://github.com/mikenicholson/passport-jwt"],["app688beeaa83537b1acd0b9ec2e64d16f6051935cc",""],["rel","nofollow","target","_blank","href","https://github.com/mikenicholson/passport-jwt#configure-strategy"],["rel","nofollow","target","_blank","href","https://github.com/mikenicholson/passport-jwt#extracting-the-jwt-from-the-request"],["app20a0da40fb8281c68f393d9994cf6f5ce66882f9",""],["app3ce80ae47bb047648a5ac63869a7276046de7374",""],["appAnchor","","id","implement-protected-route-and-jwt-strategy-guards"],["appdd0bbe510c5a40ef5dd4e2620c869ae0f3204edf",""],["appAnchor","","id","example"],["appAnchor","","id","extending-guards"],["appAnchor","","id","enable-authentication-globally"],["href","/guards#binding-guards"],["href","/guards#putting-it-all-together"],["appAnchor","","id","request-scoped-strategies"],["routerLink","/fundamentals/injection-scopes"],["routerLink","/fundamentals/module-ref"],["href","/fundamentals/module-ref#getting-current-sub-tree"],["appAnchor","","id","customize-passport"],["rel","nofollow","target","_blank","href","http://www.passportjs.org/docs/oauth/"],["appAnchor","","id","named-strategies"],["appAnchor","","id","graphql"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/graphql/quick-start"]],template:function(n,s){if(1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Authentication"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"Authentication is an "),e.TgZ(9,"strong"),e._uU(10,"essential"),e.qZA(),e._uU(11," part of most applications. There are many different approaches and strategies to handle authentication. The approach taken for any project depends on its particular application requirements. This chapter presents several approaches to authentication that can be adapted to a variety of different requirements."),e.qZA(),e.TgZ(12,"p")(13,"a",6),e._uU(14,"Passport"),e.qZA(),e._uU(15," is the most popular node.js authentication library, well-known by the community and successfully used in many production applications. It's straightforward to integrate this library with a "),e.TgZ(16,"strong"),e._uU(17,"Nest"),e.qZA(),e._uU(18," application using the "),e.TgZ(19,"code"),e._uU(20,"@nestjs/passport"),e.qZA(),e._uU(21," module. At a high level, Passport executes a series of steps to:"),e.qZA(),e.TgZ(22,"ul")(23,"li"),e._uU(24,'Authenticate a user by verifying their "credentials" (such as username/password, JSON Web Token ('),e.TgZ(25,"a",7),e._uU(26,"JWT"),e.qZA(),e._uU(27,"), or identity token from an Identity Provider)"),e.qZA(),e.TgZ(28,"li"),e._uU(29,"Manage authenticated state (by issuing a portable token, such as a JWT, or creating an "),e.TgZ(30,"a",8),e._uU(31,"Express session"),e.qZA(),e._uU(32,")"),e.qZA(),e.TgZ(33,"li"),e._uU(34,"Attach information about the authenticated user to the "),e.TgZ(35,"code"),e._uU(36,"Request"),e.qZA(),e._uU(37," object for further use in route handlers"),e.qZA()(),e.TgZ(38,"p"),e._uU(39,"Passport has a rich ecosystem of "),e.TgZ(40,"a",9),e._uU(41,"strategies"),e.qZA(),e._uU(42," that implement various authentication mechanisms. While simple in concept, the set of Passport strategies you can choose from is large and presents a lot of variety. Passport abstracts these varied steps into a standard pattern, and the "),e.TgZ(43,"code"),e._uU(44,"@nestjs/passport"),e.qZA(),e._uU(45," module wraps and standardizes this pattern into familiar Nest constructs."),e.qZA(),e.TgZ(46,"p"),e._uU(47,"In this chapter, we'll implement a complete end-to-end authentication solution for a RESTful API server using these powerful and flexible modules. You can use the concepts described here to implement any Passport strategy to customize your authentication scheme. You can follow the steps in this chapter to build this complete example. You can find a repository with a completed sample app "),e.TgZ(48,"a",10),e._uU(49,"here"),e.qZA(),e._uU(50,"."),e.qZA(),e.TgZ(51,"h4",11)(52,"span"),e._uU(53,"Authentication requirements"),e.qZA()(),e.TgZ(54,"p"),e._uU(55,"Let's flesh out our requirements. For this use case, clients will start by authenticating with a username and password. Once authenticated, the server will issue a JWT that can be sent as a "),e.TgZ(56,"a",12),e._uU(57,"bearer token in an authorization header"),e.qZA(),e._uU(58," on subsequent requests to prove authentication. We'll also create a protected route that is accessible only to requests that contain a valid JWT."),e.qZA(),e.TgZ(59,"p"),e._uU(60,"We'll start with the first requirement: authenticating a user. We'll then extend that by issuing a JWT. Finally, we'll create a protected route that checks for a valid JWT on the request."),e.qZA(),e.TgZ(61,"p"),e._uU(62,"First we need to install the required packages. Passport provides a strategy called "),e.TgZ(63,"a",13),e._uU(64,"passport-local"),e.qZA(),e._uU(65," that implements a username/password authentication mechanism, which suits our needs for this portion of our use case."),e.qZA(),e.TgZ(66,"pre")(67,"code",14),e._uU(68,"\n$ npm install --save @nestjs/passport passport passport-local\n$ npm install --save-dev @types/passport-local\n"),e.qZA()(),e.TgZ(69,"blockquote",15)(70,"strong"),e._uU(71,"Notice"),e.qZA(),e._uU(72," For "),e.TgZ(73,"strong"),e._uU(74,"any"),e.qZA(),e._uU(75," Passport strategy you choose, you'll always need the "),e.TgZ(76,"code"),e._uU(77,"@nestjs/passport"),e.qZA(),e._uU(78," and "),e.TgZ(79,"code"),e._uU(80,"passport"),e.qZA(),e._uU(81," packages. Then, you'll need to install the strategy-specific package (e.g., "),e.TgZ(82,"code"),e._uU(83,"passport-jwt"),e.qZA(),e._uU(84," or "),e.TgZ(85,"code"),e._uU(86,"passport-local"),e.qZA(),e._uU(87,") that implements the particular authentication strategy you are building. In addition, you can also install the type definitions for any Passport strategy, as shown above with "),e.TgZ(88,"code"),e._uU(89,"@types/passport-local"),e.qZA(),e._uU(90,", which provides assistance while writing TypeScript code.\n"),e.qZA(),e.TgZ(91,"h4",16)(92,"span"),e._uU(93,"Implementing Passport strategies"),e.qZA()(),e.TgZ(94,"p"),e._uU(95,"We're now ready to implement the authentication feature. We'll start with an overview of the process used for "),e.TgZ(96,"strong"),e._uU(97,"any"),e.qZA(),e._uU(98," Passport strategy. It's helpful to think of Passport as a mini framework in itself. The elegance of the framework is that it abstracts the authentication process into a few basic steps that you customize based on the strategy you're implementing. It's like a framework because you configure it by supplying customization parameters (as plain JSON objects) and custom code in the form of callback functions, which Passport calls at the appropriate time. The "),e.TgZ(99,"code"),e._uU(100,"@nestjs/passport"),e.qZA(),e._uU(101," module wraps this framework in a Nest style package, making it easy to integrate into a Nest application. We'll use "),e.TgZ(102,"code"),e._uU(103,"@nestjs/passport"),e.qZA(),e._uU(104," below, but first let's consider how "),e.TgZ(105,"strong"),e._uU(106,"vanilla Passport"),e.qZA(),e._uU(107," works."),e.qZA(),e.TgZ(108,"p"),e._uU(109,"In vanilla Passport, you configure a strategy by providing two things:"),e.qZA(),e.TgZ(110,"ol")(111,"li"),e._uU(112,"A set of options that are specific to that strategy. For example, in a JWT strategy, you might provide a secret to sign tokens."),e.qZA(),e.TgZ(113,"li"),e._uU(114,'A "verify callback", which is where you tell Passport how to interact with your user store (where you manage user accounts). Here, you verify whether a user exists (and/or create a new user), and whether their credentials are valid. The Passport library expects this callback to return a full user if the validation succeeds, or a null if it fails (failure is defined as either the user is not found, or, in the case of passport-local, the password does not match).'),e.qZA()(),e.TgZ(115,"p"),e._uU(116,"With "),e.TgZ(117,"code"),e._uU(118,"@nestjs/passport"),e.qZA(),e._uU(119,", you configure a Passport strategy by extending the "),e.TgZ(120,"code"),e._uU(121,"PassportStrategy"),e.qZA(),e._uU(122," class. You pass the strategy options (item 1 above) by calling the "),e.TgZ(123,"code"),e._uU(124,"super()"),e.qZA(),e._uU(125," method in your subclass, optionally passing in an options object. You provide the verify callback (item 2 above) by implementing a "),e.TgZ(126,"code"),e._uU(127,"validate()"),e.qZA(),e._uU(128," method in your subclass."),e.qZA(),e.TgZ(129,"p"),e._uU(130,"We'll start by generating an "),e.TgZ(131,"code"),e._uU(132,"AuthModule"),e.qZA(),e._uU(133," and in it, an "),e.TgZ(134,"code"),e._uU(135,"AuthService"),e.qZA(),e._uU(136,":"),e.qZA(),e.TgZ(137,"pre")(138,"code",14),e._uU(139,"\n$ nest g module auth\n$ nest g service auth\n"),e.qZA()(),e.TgZ(140,"p"),e._uU(141,"As we implement the "),e.TgZ(142,"code"),e._uU(143,"AuthService"),e.qZA(),e._uU(144,", we'll find it useful to encapsulate user operations in a "),e.TgZ(145,"code"),e._uU(146,"UsersService"),e.qZA(),e._uU(147,", so let's generate that module and service now:"),e.qZA(),e.TgZ(148,"pre")(149,"code",14),e._uU(150,"\n$ nest g module users\n$ nest g service users\n"),e.qZA()(),e.TgZ(151,"p"),e._uU(152,"Replace the default contents of these generated files as shown below. For our sample app, the "),e.TgZ(153,"code"),e._uU(154,"UsersService"),e.qZA(),e._uU(155," simply maintains a hard-coded in-memory list of users, and a find method to retrieve one by username. In a real app, this is where you'd build your user model and persistence layer, using your library of choice (e.g., TypeORM, Sequelize, Mongoose, etc.)."),e.qZA(),e.TgZ(156,"span",17),e._uU(157),e.ALo(158,"extension"),e._UZ(159,"app-tabs",null,18),e.qZA(),e.TgZ(161,"pre")(162,"code",19),e._uU(163,"\nimport { Injectable } from '@nestjs/common';\n\n// This should be a real class/interface representing a user entity\nexport type User = any;\n\n@Injectable()\nexport class UsersService {\n  private readonly users = [\n    {\n      userId: 1,\n      username: 'john',\n      password: 'changeme',\n    },\n    {\n      userId: 2,\n      username: 'maria',\n      password: 'guess',\n    },\n  ];\n\n  async findOne(username: string): Promise<User | undefined> {\n    return this.users.find(user => user.username === username);\n  }\n}\n"),e.qZA()(),e.TgZ(164,"pre")(165,"code",19),e._uU(166,"\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class UsersService {\n  constructor() {\n    this.users = [\n      {\n        userId: 1,\n        username: 'john',\n        password: 'changeme',\n      },\n      {\n        userId: 2,\n        username: 'maria',\n        password: 'guess',\n      },\n    ];\n  }\n\n  async findOne(username) {\n    return this.users.find(user => user.username === username);\n  }\n}\n"),e.qZA()(),e.TgZ(167,"p"),e._uU(168,"In the "),e.TgZ(169,"code"),e._uU(170,"UsersModule"),e.qZA(),e._uU(171,", the only change needed is to add the "),e.TgZ(172,"code"),e._uU(173,"UsersService"),e.qZA(),e._uU(174," to the exports array of the "),e.TgZ(175,"code"),e._uU(176,"@Module"),e.qZA(),e._uU(177," decorator so that it is visible outside this module (we'll soon use it in our "),e.TgZ(178,"code"),e._uU(179,"AuthService"),e.qZA(),e._uU(180,")."),e.qZA(),e.TgZ(181,"span",17),e._uU(182),e.ALo(183,"extension"),e._UZ(184,"app-tabs",null,20),e.qZA(),e.TgZ(186,"pre")(187,"code",19),e._uU(188,"\nimport { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\n\n@Module({\n  providers: [UsersService],\n  exports: [UsersService],\n})\nexport class UsersModule {}\n"),e.qZA()(),e.TgZ(189,"pre")(190,"code",19),e._uU(191,"\nimport { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\n\n@Module({\n  providers: [UsersService],\n  exports: [UsersService],\n})\nexport class UsersModule {}\n"),e.qZA()(),e.TgZ(192,"p"),e._uU(193,"Our "),e.TgZ(194,"code"),e._uU(195,"AuthService"),e.qZA(),e._uU(196," has the job of retrieving a user and verifying the password. We create a "),e.TgZ(197,"code"),e._uU(198,"validateUser()"),e.qZA(),e._uU(199," method for this purpose. In the code below, we use a convenient ES6 spread operator to strip the password property from the user object before returning it. We'll be calling into the "),e.TgZ(200,"code"),e._uU(201,"validateUser()"),e.qZA(),e._uU(202," method from our Passport local strategy in a moment."),e.qZA(),e.TgZ(203,"span",17),e._uU(204),e.ALo(205,"extension"),e._UZ(206,"app-tabs",null,21),e.qZA(),e.TgZ(208,"pre")(209,"code",19),e._uU(210,"\nimport { Injectable } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\n\n@Injectable()\nexport class AuthService {\n  constructor(private usersService: UsersService) {}\n\n  async validateUser(username: string, pass: string): Promise<any> {\n    const user = await this.usersService.findOne(username);\n    if (user && user.password === pass) {\n      const { password, ...result } = user;\n      return result;\n    }\n    return null;\n  }\n}\n"),e.qZA()(),e.TgZ(211,"pre")(212,"code",19),e._uU(213,"\nimport { Injectable, Dependencies } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\n\n@Injectable()\n@Dependencies(UsersService)\nexport class AuthService {\n  constructor(usersService) {\n    this.usersService = usersService;\n  }\n\n  async validateUser(username, pass) {\n    const user = await this.usersService.findOne(username);\n    if (user && user.password === pass) {\n      const { password, ...result } = user;\n      return result;\n    }\n    return null;\n  }\n}\n"),e.qZA()(),e.TgZ(214,"blockquote",22)(215,"strong"),e._uU(216,"Warning"),e.qZA(),e._uU(217," Of course in a real application, you wouldn't store a password in plain text. You'd instead use a library like "),e.TgZ(218,"a",23),e._uU(219,"bcrypt"),e.qZA(),e._uU(220,", with a salted one-way hash algorithm. With that approach, you'd only store hashed passwords, and then compare the stored password to a hashed version of the "),e.TgZ(221,"strong"),e._uU(222,"incoming"),e.qZA(),e._uU(223," password, thus never storing or exposing user passwords in plain text. To keep our sample app simple, we violate that absolute mandate and use plain text. "),e.TgZ(224,"strong"),e._uU(225,"Don't do this in your real app!"),e.qZA()(),e.TgZ(226,"p"),e._uU(227,"Now, we update our "),e.TgZ(228,"code"),e._uU(229,"AuthModule"),e.qZA(),e._uU(230," to import the "),e.TgZ(231,"code"),e._uU(232,"UsersModule"),e.qZA(),e._uU(233,"."),e.qZA(),e.TgZ(234,"span",17),e._uU(235),e.ALo(236,"extension"),e._UZ(237,"app-tabs",null,24),e.qZA(),e.TgZ(239,"pre")(240,"code",19),e._uU(241,"\nimport { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\n\n@Module({\n  imports: [UsersModule],\n  providers: [AuthService],\n})\nexport class AuthModule {}\n"),e.qZA()(),e.TgZ(242,"pre")(243,"code",19),e._uU(244,"\nimport { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\n\n@Module({\n  imports: [UsersModule],\n  providers: [AuthService],\n})\nexport class AuthModule {}\n"),e.qZA()(),e.TgZ(245,"h4",25)(246,"span"),e._uU(247,"Implementing Passport local"),e.qZA()(),e.TgZ(248,"p"),e._uU(249,"Now we can implement our Passport "),e.TgZ(250,"strong"),e._uU(251,"local authentication strategy"),e.qZA(),e._uU(252,". Create a file called "),e.TgZ(253,"code"),e._uU(254,"local.strategy.ts"),e.qZA(),e._uU(255," in the "),e.TgZ(256,"code"),e._uU(257,"auth"),e.qZA(),e._uU(258," folder, and add the following code:"),e.qZA(),e.TgZ(259,"span",17),e._uU(260),e.ALo(261,"extension"),e._UZ(262,"app-tabs",null,26),e.qZA(),e.TgZ(264,"pre")(265,"code",19),e._uU(266,"\nimport { Strategy } from 'passport-local';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { AuthService } from './auth.service';\n\n@Injectable()\nexport class LocalStrategy extends PassportStrategy(Strategy) {\n  constructor(private authService: AuthService) {\n    super();\n  }\n\n  async validate(username: string, password: string): Promise<any> {\n    const user = await this.authService.validateUser(username, password);\n    if (!user) {\n      throw new UnauthorizedException();\n    }\n    return user;\n  }\n}\n"),e.qZA()(),e.TgZ(267,"pre")(268,"code",19),e._uU(269,"\nimport { Strategy } from 'passport-local';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable, UnauthorizedException, Dependencies } from '@nestjs/common';\nimport { AuthService } from './auth.service';\n\n@Injectable()\n@Dependencies(AuthService)\nexport class LocalStrategy extends PassportStrategy(Strategy) {\n  constructor(authService) {\n    super();\n    this.authService = authService;\n  }\n\n  async validate(username, password) {\n    const user = await this.authService.validateUser(username, password);\n    if (!user) {\n      throw new UnauthorizedException();\n    }\n    return user;\n  }\n}\n"),e.qZA()(),e.TgZ(270,"p"),e._uU(271,"We've followed the recipe described earlier for all Passport strategies. In our use case with passport-local, there are no configuration options, so our constructor simply calls "),e.TgZ(272,"code"),e._uU(273,"super()"),e.qZA(),e._uU(274,", without an options object."),e.qZA(),e.TgZ(275,"blockquote",27)(276,"strong"),e._uU(277,"Hint"),e.qZA(),e._uU(278," We can pass an options object in the call to "),e.TgZ(279,"code"),e._uU(280,"super()"),e.qZA(),e._uU(281," to customize the behavior of the passport strategy. In this example, the passport-local strategy by default expects properties called "),e.TgZ(282,"code"),e._uU(283,"username"),e.qZA(),e._uU(284," and "),e.TgZ(285,"code"),e._uU(286,"password"),e.qZA(),e._uU(287," in the request body. Pass an options object to specify different property names, for example: "),e.TgZ(288,"code"),e._uU(289),e.qZA(),e._uU(290,". See the "),e.TgZ(291,"a",28),e._uU(292,"Passport documentation"),e.qZA(),e._uU(293," for more information.\n"),e.qZA(),e.TgZ(294,"p"),e._uU(295,"We've also implemented the "),e.TgZ(296,"code"),e._uU(297,"validate()"),e.qZA(),e._uU(298," method. For each strategy, Passport will call the verify function (implemented with the "),e.TgZ(299,"code"),e._uU(300,"validate()"),e.qZA(),e._uU(301," method in "),e.TgZ(302,"code"),e._uU(303,"@nestjs/passport"),e.qZA(),e._uU(304,") using an appropriate strategy-specific set of parameters. For the local-strategy, Passport expects a "),e.TgZ(305,"code"),e._uU(306,"validate()"),e.qZA(),e._uU(307," method with the following signature: "),e.TgZ(308,"code"),e._uU(309,"validate(username: string, password:string): any"),e.qZA(),e._uU(310,"."),e.qZA(),e.TgZ(311,"p"),e._uU(312,"Most of the validation work is done in our "),e.TgZ(313,"code"),e._uU(314,"AuthService"),e.qZA(),e._uU(315," (with the help of our "),e.TgZ(316,"code"),e._uU(317,"UsersService"),e.qZA(),e._uU(318,"), so this method is quite straightforward. The "),e.TgZ(319,"code"),e._uU(320,"validate()"),e.qZA(),e._uU(321," method for "),e.TgZ(322,"strong"),e._uU(323,"any"),e.qZA(),e._uU(324," Passport strategy will follow a similar pattern, varying only in the details of how credentials are represented. If a user is found and the credentials are valid, the user is returned so Passport can complete its tasks (e.g., creating the "),e.TgZ(325,"code"),e._uU(326,"user"),e.qZA(),e._uU(327," property on the "),e.TgZ(328,"code"),e._uU(329,"Request"),e.qZA(),e._uU(330," object), and the request handling pipeline can continue. If it's not found, we throw an exception and let our "),e.TgZ(331,"a",29),e._uU(332,"exceptions layer"),e.qZA(),e._uU(333," handle it."),e.qZA(),e.TgZ(334,"p"),e._uU(335,"Typically, the only significant difference in the "),e.TgZ(336,"code"),e._uU(337,"validate()"),e.qZA(),e._uU(338," method for each strategy is "),e.TgZ(339,"strong"),e._uU(340,"how"),e.qZA(),e._uU(341," you determine if a user exists and is valid. For example, in a JWT strategy, depending on requirements, we may evaluate whether the "),e.TgZ(342,"code"),e._uU(343,"userId"),e.qZA(),e._uU(344," carried in the decoded token matches a record in our user database, or matches a list of revoked tokens. Hence, this pattern of sub-classing and implementing strategy-specific validation is consistent, elegant and extensible."),e.qZA(),e.TgZ(345,"p"),e._uU(346,"We need to configure our "),e.TgZ(347,"code"),e._uU(348,"AuthModule"),e.qZA(),e._uU(349," to use the Passport features we just defined. Update "),e.TgZ(350,"code"),e._uU(351,"auth.module.ts"),e.qZA(),e._uU(352," to look like this:"),e.qZA(),e.TgZ(353,"span",17),e._uU(354),e.ALo(355,"extension"),e._UZ(356,"app-tabs",null,30),e.qZA(),e.TgZ(358,"pre")(359,"code",19),e._uU(360,"\nimport { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { LocalStrategy } from './local.strategy';\n\n@Module({\n  imports: [UsersModule, PassportModule],\n  providers: [AuthService, LocalStrategy],\n})\nexport class AuthModule {}\n"),e.qZA()(),e.TgZ(361,"pre")(362,"code",19),e._uU(363,"\nimport { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { LocalStrategy } from './local.strategy';\n\n@Module({\n  imports: [UsersModule, PassportModule],\n  providers: [AuthService, LocalStrategy],\n})\nexport class AuthModule {}\n"),e.qZA()(),e.TgZ(364,"h4",31)(365,"span"),e._uU(366,"Built-in Passport Guards"),e.qZA()(),e.TgZ(367,"p"),e._uU(368,"The "),e.TgZ(369,"a",32),e._uU(370,"Guards"),e.qZA(),e._uU(371," chapter describes the primary function of Guards: to determine whether a request will be handled by the route handler or not. That remains true, and we'll use that standard capability soon. However, in the context of using the "),e.TgZ(372,"code"),e._uU(373,"@nestjs/passport"),e.qZA(),e._uU(374," module, we will also introduce a slight new wrinkle that may at first be confusing, so let's discuss that now. Consider that your app can exist in two states, from an authentication perspective:"),e.qZA(),e.TgZ(375,"ol")(376,"li"),e._uU(377,"the user/client is "),e.TgZ(378,"strong"),e._uU(379,"not"),e.qZA(),e._uU(380," logged in (is not authenticated)"),e.qZA(),e.TgZ(381,"li"),e._uU(382,"the user/client "),e.TgZ(383,"strong"),e._uU(384,"is"),e.qZA(),e._uU(385," logged in (is authenticated)"),e.qZA()(),e.TgZ(386,"p"),e._uU(387,"In the first case (user is not logged in), we need to perform two distinct functions:"),e.qZA(),e.TgZ(388,"ul")(389,"li")(390,"p"),e._uU(391,"Restrict the routes an unauthenticated user can access (i.e., deny access to restricted routes). We'll use Guards in their familiar capacity to handle this function, by placing a Guard on the protected routes. As you may anticipate, we'll be checking for the presence of a valid JWT in this Guard, so we'll work on this Guard later, once we are successfully issuing JWTs."),e.qZA()(),e.TgZ(392,"li")(393,"p"),e._uU(394,"Initiate the "),e.TgZ(395,"strong"),e._uU(396,"authentication step"),e.qZA(),e._uU(397," itself when a previously unauthenticated user attempts to login. This is the step where we'll "),e.TgZ(398,"strong"),e._uU(399,"issue"),e.qZA(),e._uU(400," a JWT to a valid user. Thinking about this for a moment, we know we'll need to "),e.TgZ(401,"code"),e._uU(402,"POST"),e.qZA(),e._uU(403," username/password credentials to initiate authentication, so we'll set up a "),e.TgZ(404,"code"),e._uU(405,"POST /auth/login"),e.qZA(),e._uU(406," route to handle that. This raises the question: how exactly do we invoke the passport-local strategy in that route?"),e.qZA()()(),e.TgZ(407,"p"),e._uU(408,"The answer is straightforward: by using another, slightly different type of Guard. The "),e.TgZ(409,"code"),e._uU(410,"@nestjs/passport"),e.qZA(),e._uU(411," module provides us with a built-in Guard that does this for us. This Guard invokes the Passport strategy and kicks off the steps described above (retrieving credentials, running the verify function, creating the "),e.TgZ(412,"code"),e._uU(413,"user"),e.qZA(),e._uU(414," property, etc)."),e.qZA(),e.TgZ(415,"p"),e._uU(416,"The second case enumerated above (logged in user) simply relies on the standard type of Guard we already discussed to enable access to protected routes for logged in users."),e.qZA(),e.TgZ(417,"p"),e._UZ(418,"app-banner-courses"),e.qZA(),e.TgZ(419,"h4",33)(420,"span"),e._uU(421,"Login route"),e.qZA()(),e.TgZ(422,"p"),e._uU(423,"With the strategy in place, we can now implement a bare-bones "),e.TgZ(424,"code"),e._uU(425,"/auth/login"),e.qZA(),e._uU(426," route, and apply the built-in Guard to initiate the passport-local flow."),e.qZA(),e.TgZ(427,"p"),e._uU(428,"Open the "),e.TgZ(429,"code"),e._uU(430,"app.controller.ts"),e.qZA(),e._uU(431," file and replace its contents with the following:"),e.qZA(),e.TgZ(432,"span",17),e._uU(433),e.ALo(434,"extension"),e._UZ(435,"app-tabs",null,34),e.qZA(),e.TgZ(437,"pre")(438,"code",19),e._uU(439,"\nimport { Controller, Request, Post, UseGuards } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Controller()\nexport class AppController {\n  @UseGuards(AuthGuard('local'))\n  @Post('auth/login')\n  async login(@Request() req) {\n    return req.user;\n  }\n}\n"),e.qZA()(),e.TgZ(440,"pre")(441,"code",19),e._uU(442,"\nimport { Controller, Bind, Request, Post, UseGuards } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Controller()\nexport class AppController {\n  @UseGuards(AuthGuard('local'))\n  @Post('auth/login')\n  @Bind(Request())\n  async login(req) {\n    return req.user;\n  }\n}\n"),e.qZA()(),e.TgZ(443,"p"),e._uU(444,"With "),e.TgZ(445,"code"),e._uU(446,"@UseGuards(AuthGuard('local'))"),e.qZA(),e._uU(447," we are using an "),e.TgZ(448,"code"),e._uU(449,"AuthGuard"),e.qZA(),e._uU(450," that "),e.TgZ(451,"code"),e._uU(452,"@nestjs/passport"),e.qZA(),e.TgZ(453,"strong"),e._uU(454,"automatically provisioned"),e.qZA(),e._uU(455," for us when we extended the passport-local strategy. Let's break that down. Our Passport local strategy has a default name of "),e.TgZ(456,"code"),e._uU(457,"'local'"),e.qZA(),e._uU(458,". We reference that name in the "),e.TgZ(459,"code"),e._uU(460,"@UseGuards()"),e.qZA(),e._uU(461," decorator to associate it with code supplied by the "),e.TgZ(462,"code"),e._uU(463,"passport-local"),e.qZA(),e._uU(464," package. This is used to disambiguate which strategy to invoke in case we have multiple Passport strategies in our app (each of which may provision a strategy-specific "),e.TgZ(465,"code"),e._uU(466,"AuthGuard"),e.qZA(),e._uU(467,"). While we only have one such strategy so far, we'll shortly add a second, so this is needed for disambiguation."),e.qZA(),e.TgZ(468,"p"),e._uU(469,"In order to test our route we'll have our "),e.TgZ(470,"code"),e._uU(471,"/auth/login"),e.qZA(),e._uU(472," route simply return the user for now. This also lets us demonstrate another Passport feature: Passport automatically creates a "),e.TgZ(473,"code"),e._uU(474,"user"),e.qZA(),e._uU(475," object, based on the value we return from the "),e.TgZ(476,"code"),e._uU(477,"validate()"),e.qZA(),e._uU(478," method, and assigns it to the "),e.TgZ(479,"code"),e._uU(480,"Request"),e.qZA(),e._uU(481," object as "),e.TgZ(482,"code"),e._uU(483,"req.user"),e.qZA(),e._uU(484,". Later, we'll replace this with code to create and return a JWT instead."),e.qZA(),e.TgZ(485,"p"),e._uU(486,"Since these are API routes, we'll test them using the commonly available "),e.TgZ(487,"a",35),e._uU(488,"cURL"),e.qZA(),e._uU(489," library. You can test with any of the "),e.TgZ(490,"code"),e._uU(491,"user"),e.qZA(),e._uU(492," objects hard-coded in the "),e.TgZ(493,"code"),e._uU(494,"UsersService"),e.qZA(),e._uU(495,"."),e.qZA(),e.TgZ(496,"pre")(497,"code",14),e._uU(498,'\n$ # POST to /auth/login\n$ curl -X POST http://localhost:3000/auth/login -d \'{"username": "john", "password": "changeme"}\' -H "Content-Type: application/json"\n$ # result -> {"userId":1,"username":"john"}\n'),e.qZA()(),e.TgZ(499,"p"),e._uU(500,"While this works, passing the strategy name directly to the "),e.TgZ(501,"code"),e._uU(502,"AuthGuard()"),e.qZA(),e._uU(503," introduces magic strings in the codebase. Instead, we recommend creating your own class, as shown below:"),e.qZA(),e.TgZ(504,"span",17),e._uU(505),e.ALo(506,"extension"),e._UZ(507,"app-tabs",null,36),e.qZA(),e.TgZ(509,"pre")(510,"code",19),e._uU(511,"\nimport { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class LocalAuthGuard extends AuthGuard('local') {}\n"),e.qZA()(),e.TgZ(512,"p"),e._uU(513,"Now, we can update the "),e.TgZ(514,"code"),e._uU(515,"/auth/login"),e.qZA(),e._uU(516," route handler and use the "),e.TgZ(517,"code"),e._uU(518,"LocalAuthGuard"),e.qZA(),e._uU(519," instead:"),e.qZA(),e.TgZ(520,"pre")(521,"code",19),e._uU(522,"\n@UseGuards(LocalAuthGuard)\n@Post('auth/login')\nasync login(@Request() req) {\n  return req.user;\n}\n"),e.qZA()(),e.TgZ(523,"h4",37)(524,"span"),e._uU(525,"JWT functionality"),e.qZA()(),e.TgZ(526,"p"),e._uU(527,"We're ready to move on to the JWT portion of our auth system. Let's review and refine our requirements:"),e.qZA(),e.TgZ(528,"ul")(529,"li"),e._uU(530,"Allow users to authenticate with username/password, returning a JWT for use in subsequent calls to protected API endpoints. We're well on our way to meeting this requirement. To complete it, we'll need to write the code that issues a JWT."),e.qZA(),e.TgZ(531,"li"),e._uU(532,"Create API routes which are protected based on the presence of a valid JWT as a bearer token"),e.qZA()(),e.TgZ(533,"p"),e._uU(534,"We'll need to install a couple more packages to support our JWT requirements:"),e.qZA(),e.TgZ(535,"pre")(536,"code",14),e._uU(537,"\n$ npm install --save @nestjs/jwt passport-jwt\n$ npm install --save-dev @types/passport-jwt\n"),e.qZA()(),e.TgZ(538,"p"),e._uU(539,"The "),e.TgZ(540,"code"),e._uU(541,"@nestjs/jwt"),e.qZA(),e._uU(542," package (see more "),e.TgZ(543,"a",38),e._uU(544,"here"),e.qZA(),e._uU(545,") is a utility package that helps with JWT manipulation. The "),e.TgZ(546,"code"),e._uU(547,"passport-jwt"),e.qZA(),e._uU(548," package is the Passport package that implements the JWT strategy and "),e.TgZ(549,"code"),e._uU(550,"@types/passport-jwt"),e.qZA(),e._uU(551," provides the TypeScript type definitions."),e.qZA(),e.TgZ(552,"p"),e._uU(553,"Let's take a closer look at how a "),e.TgZ(554,"code"),e._uU(555,"POST /auth/login"),e.qZA(),e._uU(556," request is handled. We've decorated the route using the built-in "),e.TgZ(557,"code"),e._uU(558,"AuthGuard"),e.qZA(),e._uU(559," provided by the passport-local strategy. This means that:"),e.qZA(),e.TgZ(560,"ol")(561,"li"),e._uU(562,"The route handler "),e.TgZ(563,"strong"),e._uU(564,"will only be invoked if the user has been validated"),e.qZA()(),e.TgZ(565,"li"),e._uU(566,"The "),e.TgZ(567,"code"),e._uU(568,"req"),e.qZA(),e._uU(569," parameter will contain a "),e.TgZ(570,"code"),e._uU(571,"user"),e.qZA(),e._uU(572," property (populated by Passport during the passport-local authentication flow)"),e.qZA()(),e.TgZ(573,"p"),e._uU(574,"With this in mind, we can now finally generate a real JWT, and return it in this route. To keep our services cleanly modularized, we'll handle generating the JWT in the "),e.TgZ(575,"code"),e._uU(576,"authService"),e.qZA(),e._uU(577,". Open the "),e.TgZ(578,"code"),e._uU(579,"auth.service.ts"),e.qZA(),e._uU(580," file in the "),e.TgZ(581,"code"),e._uU(582,"auth"),e.qZA(),e._uU(583," folder, and add the "),e.TgZ(584,"code"),e._uU(585,"login()"),e.qZA(),e._uU(586," method, and import the "),e.TgZ(587,"code"),e._uU(588,"JwtService"),e.qZA(),e._uU(589," as shown:"),e.qZA(),e.TgZ(590,"span",17),e._uU(591),e.ALo(592,"extension"),e._UZ(593,"app-tabs",null,39),e.qZA(),e.TgZ(595,"pre")(596,"code",19),e._uU(597,"\nimport { Injectable } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\nimport { JwtService } from '@nestjs/jwt';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private usersService: UsersService,\n    private jwtService: JwtService\n  ) {}\n\n  async validateUser(username: string, pass: string): Promise<any> {\n    const user = await this.usersService.findOne(username);\n    if (user && user.password === pass) {\n      const { password, ...result } = user;\n      return result;\n    }\n    return null;\n  }\n\n  async login(user: any) {\n    const payload = { username: user.username, sub: user.userId };\n    return {\n      access_token: this.jwtService.sign(payload),\n    };\n  }\n}\n"),e.qZA()(),e.TgZ(598,"pre")(599,"code",19),e._uU(600,"\nimport { Injectable, Dependencies } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\nimport { JwtService } from '@nestjs/jwt';\n\n@Dependencies(UsersService, JwtService)\n@Injectable()\nexport class AuthService {\n  constructor(usersService, jwtService) {\n    this.usersService = usersService;\n    this.jwtService = jwtService;\n  }\n\n  async validateUser(username, pass) {\n    const user = await this.usersService.findOne(username);\n    if (user && user.password === pass) {\n      const { password, ...result } = user;\n      return result;\n    }\n    return null;\n  }\n\n  async login(user) {\n    const payload = { username: user.username, sub: user.userId };\n    return {\n      access_token: this.jwtService.sign(payload),\n    };\n  }\n}\n"),e.qZA()(),e.TgZ(601,"p"),e._uU(602,"We're using the "),e.TgZ(603,"code"),e._uU(604,"@nestjs/jwt"),e.qZA(),e._uU(605," library, which supplies a "),e.TgZ(606,"code"),e._uU(607,"sign()"),e.qZA(),e._uU(608," function to generate our JWT from a subset of the "),e.TgZ(609,"code"),e._uU(610,"user"),e.qZA(),e._uU(611," object properties, which we then return as a simple object with a single "),e.TgZ(612,"code"),e._uU(613,"access_token"),e.qZA(),e._uU(614," property. Note: we choose a property name of "),e.TgZ(615,"code"),e._uU(616,"sub"),e.qZA(),e._uU(617," to hold our "),e.TgZ(618,"code"),e._uU(619,"userId"),e.qZA(),e._uU(620," value to be consistent with JWT standards. Don't forget to inject the JwtService provider into the "),e.TgZ(621,"code"),e._uU(622,"AuthService"),e.qZA(),e._uU(623,"."),e.qZA(),e.TgZ(624,"p"),e._uU(625,"We now need to update the "),e.TgZ(626,"code"),e._uU(627,"AuthModule"),e.qZA(),e._uU(628," to import the new dependencies and configure the "),e.TgZ(629,"code"),e._uU(630,"JwtModule"),e.qZA(),e._uU(631,"."),e.qZA(),e.TgZ(632,"p"),e._uU(633,"First, create "),e.TgZ(634,"code"),e._uU(635,"constants.ts"),e.qZA(),e._uU(636," in the "),e.TgZ(637,"code"),e._uU(638,"auth"),e.qZA(),e._uU(639," folder, and add the following code:"),e.qZA(),e.TgZ(640,"span",17),e._uU(641),e.ALo(642,"extension"),e._UZ(643,"app-tabs",null,40),e.qZA(),e.TgZ(645,"pre")(646,"code",19),e._uU(647,"\nexport const jwtConstants = {\n  secret: 'secretKey',\n};\n"),e.qZA()(),e.TgZ(648,"pre")(649,"code",19),e._uU(650,"\nexport const jwtConstants = {\n  secret: 'secretKey',\n};\n"),e.qZA()(),e.TgZ(651,"p"),e._uU(652,"We'll use this to share our key between the JWT signing and verifying steps."),e.qZA(),e.TgZ(653,"blockquote",22)(654,"strong"),e._uU(655,"Warning"),e.qZA(),e.TgZ(656,"strong"),e._uU(657,"Do not expose this key publicly"),e.qZA(),e._uU(658,". We have done so here to make it clear what the code is doing, but in a production system "),e.TgZ(659,"strong"),e._uU(660,"you must protect this key"),e.qZA(),e._uU(661," using appropriate measures such as a secrets vault, environment variable, or configuration service.\n"),e.qZA(),e.TgZ(662,"p"),e._uU(663,"Now, open "),e.TgZ(664,"code"),e._uU(665,"auth.module.ts"),e.qZA(),e._uU(666," in the "),e.TgZ(667,"code"),e._uU(668,"auth"),e.qZA(),e._uU(669," folder and update it to look like this:"),e.qZA(),e.TgZ(670,"span",17),e._uU(671),e.ALo(672,"extension"),e._UZ(673,"app-tabs",null,41),e.qZA(),e.TgZ(675,"pre")(676,"code",19),e._uU(677,"\nimport { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { LocalStrategy } from './local.strategy';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtModule } from '@nestjs/jwt';\nimport { jwtConstants } from './constants';\n\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '60s' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n"),e.qZA()(),e.TgZ(678,"pre")(679,"code",19),e._uU(680,"\nimport { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { LocalStrategy } from './local.strategy';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtModule } from '@nestjs/jwt';\nimport { jwtConstants } from './constants';\n\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '60s' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n"),e.qZA()(),e.TgZ(681,"p"),e._uU(682,"We configure the "),e.TgZ(683,"code"),e._uU(684,"JwtModule"),e.qZA(),e._uU(685," using "),e.TgZ(686,"code"),e._uU(687,"register()"),e.qZA(),e._uU(688,", passing in a configuration object. See "),e.TgZ(689,"a",42),e._uU(690,"here"),e.qZA(),e._uU(691," for more on the Nest "),e.TgZ(692,"code"),e._uU(693,"JwtModule"),e.qZA(),e._uU(694," and "),e.TgZ(695,"a",43),e._uU(696,"here"),e.qZA(),e._uU(697," for more details on the available configuration options."),e.qZA(),e.TgZ(698,"p"),e._uU(699,"Now we can update the "),e.TgZ(700,"code"),e._uU(701,"/auth/login"),e.qZA(),e._uU(702," route to return a JWT."),e.qZA(),e.TgZ(703,"span",17),e._uU(704),e.ALo(705,"extension"),e._UZ(706,"app-tabs",null,44),e.qZA(),e.TgZ(708,"pre")(709,"code",19),e._uU(710,"\nimport { Controller, Request, Post, UseGuards } from '@nestjs/common';\nimport { LocalAuthGuard } from './auth/local-auth.guard';\nimport { AuthService } from './auth/auth.service';\n\n@Controller()\nexport class AppController {\n  constructor(private authService: AuthService) {}\n\n  @UseGuards(LocalAuthGuard)\n  @Post('auth/login')\n  async login(@Request() req) {\n    return this.authService.login(req.user);\n  }\n}\n"),e.qZA()(),e.TgZ(711,"pre")(712,"code",19),e._uU(713,"\nimport { Controller, Bind, Request, Post, UseGuards } from '@nestjs/common';\nimport { LocalAuthGuard } from './auth/local-auth.guard';\nimport { AuthService } from './auth/auth.service';\n\n@Controller()\nexport class AppController {\n  constructor(private authService: AuthService) {}\n\n  @UseGuards(LocalAuthGuard)\n  @Post('auth/login')\n  @Bind(Request())\n  async login(req) {\n    return this.authService.login(req.user);\n  }\n}\n"),e.qZA()(),e.TgZ(714,"p"),e._uU(715,"Let's go ahead and test our routes using cURL again. You can test with any of the "),e.TgZ(716,"code"),e._uU(717,"user"),e.qZA(),e._uU(718," objects hard-coded in the "),e.TgZ(719,"code"),e._uU(720,"UsersService"),e.qZA(),e._uU(721,"."),e.qZA(),e.TgZ(722,"pre")(723,"code",14),e._uU(724,'\n$ # POST to /auth/login\n$ curl -X POST http://localhost:3000/auth/login -d \'{"username": "john", "password": "changeme"}\' -H "Content-Type: application/json"\n$ # result -> {"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}\n$ # Note: above JWT truncated\n'),e.qZA()(),e.TgZ(725,"h4",45)(726,"span"),e._uU(727,"Implementing Passport JWT"),e.qZA()(),e.TgZ(728,"p"),e._uU(729,"We can now address our final requirement: protecting endpoints by requiring a valid JWT be present on the request. Passport can help us here too. It provides the "),e.TgZ(730,"a",46),e._uU(731,"passport-jwt"),e.qZA(),e._uU(732," strategy for securing RESTful endpoints with JSON Web Tokens. Start by creating a file called "),e.TgZ(733,"code"),e._uU(734,"jwt.strategy.ts"),e.qZA(),e._uU(735," in the "),e.TgZ(736,"code"),e._uU(737,"auth"),e.qZA(),e._uU(738," folder, and add the following code:"),e.qZA(),e.TgZ(739,"span",17),e._uU(740),e.ALo(741,"extension"),e._UZ(742,"app-tabs",null,47),e.qZA(),e.TgZ(744,"pre")(745,"code",19),e._uU(746,"\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\nimport { jwtConstants } from './constants';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor() {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: jwtConstants.secret,\n    });\n  }\n\n  async validate(payload: any) {\n    return { userId: payload.sub, username: payload.username };\n  }\n}\n"),e.qZA()(),e.TgZ(747,"pre")(748,"code",19),e._uU(749,"\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\nimport { jwtConstants } from './constants';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor() {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: jwtConstants.secret,\n    });\n  }\n\n  async validate(payload) {\n    return { userId: payload.sub, username: payload.username };\n  }\n}\n"),e.qZA()(),e.TgZ(750,"p"),e._uU(751,"With our "),e.TgZ(752,"code"),e._uU(753,"JwtStrategy"),e.qZA(),e._uU(754,", we've followed the same recipe described earlier for all Passport strategies. This strategy requires some initialization, so we do that by passing in an options object in the "),e.TgZ(755,"code"),e._uU(756,"super()"),e.qZA(),e._uU(757," call. You can read more about the available options "),e.TgZ(758,"a",48),e._uU(759,"here"),e.qZA(),e._uU(760,". In our case, these options are:"),e.qZA(),e.TgZ(761,"ul")(762,"li")(763,"code"),e._uU(764,"jwtFromRequest"),e.qZA(),e._uU(765,": supplies the method by which the JWT will be extracted from the "),e.TgZ(766,"code"),e._uU(767,"Request"),e.qZA(),e._uU(768,". We will use the standard approach of supplying a bearer token in the Authorization header of our API requests. Other options are described "),e.TgZ(769,"a",49),e._uU(770,"here"),e.qZA(),e._uU(771,"."),e.qZA(),e.TgZ(772,"li")(773,"code"),e._uU(774,"ignoreExpiration"),e.qZA(),e._uU(775,": just to be explicit, we choose the default "),e.TgZ(776,"code"),e._uU(777,"false"),e.qZA(),e._uU(778," setting, which delegates the responsibility of ensuring that a JWT has not expired to the Passport module. This means that if our route is supplied with an expired JWT, the request will be denied and a "),e.TgZ(779,"code"),e._uU(780,"401 Unauthorized"),e.qZA(),e._uU(781," response sent. Passport conveniently handles this automatically for us."),e.qZA(),e.TgZ(782,"li")(783,"code"),e._uU(784,"secretOrKey"),e.qZA(),e._uU(785,": we are using the expedient option of supplying a symmetric secret for signing the token. Other options, such as a PEM-encoded public key, may be more appropriate for production apps (see "),e.TgZ(786,"a",48),e._uU(787,"here"),e.qZA(),e._uU(788," for more information). In any case, as cautioned earlier, "),e.TgZ(789,"strong"),e._uU(790,"do not expose this secret publicly"),e.qZA(),e._uU(791,"."),e.qZA()(),e.TgZ(792,"p"),e._uU(793,"The "),e.TgZ(794,"code"),e._uU(795,"validate()"),e.qZA(),e._uU(796," method deserves some discussion. For the jwt-strategy, Passport first verifies the JWT's signature and decodes the JSON. It then invokes our "),e.TgZ(797,"code"),e._uU(798,"validate()"),e.qZA(),e._uU(799," method passing the decoded JSON as its single parameter. Based on the way JWT signing works, "),e.TgZ(800,"strong"),e._uU(801,"we're guaranteed that we're receiving a valid token"),e.qZA(),e._uU(802," that we have previously signed and issued to a valid user."),e.qZA(),e.TgZ(803,"p"),e._uU(804,"As a result of all this, our response to the "),e.TgZ(805,"code"),e._uU(806,"validate()"),e.qZA(),e._uU(807," callback is trivial: we simply return an object containing the "),e.TgZ(808,"code"),e._uU(809,"userId"),e.qZA(),e._uU(810," and "),e.TgZ(811,"code"),e._uU(812,"username"),e.qZA(),e._uU(813," properties. Recall again that Passport will build a "),e.TgZ(814,"code"),e._uU(815,"user"),e.qZA(),e._uU(816," object based on the return value of our "),e.TgZ(817,"code"),e._uU(818,"validate()"),e.qZA(),e._uU(819," method, and attach it as a property on the "),e.TgZ(820,"code"),e._uU(821,"Request"),e.qZA(),e._uU(822," object."),e.qZA(),e.TgZ(823,"p"),e._uU(824,"It's also worth pointing out that this approach leaves us room ('hooks' as it were) to inject other business logic into the process. For example, we could do a database lookup in our "),e.TgZ(825,"code"),e._uU(826,"validate()"),e.qZA(),e._uU(827," method to extract more information about the user, resulting in a more enriched "),e.TgZ(828,"code"),e._uU(829,"user"),e.qZA(),e._uU(830," object being available in our "),e.TgZ(831,"code"),e._uU(832,"Request"),e.qZA(),e._uU(833,". This is also the place we may decide to do further token validation, such as looking up the "),e.TgZ(834,"code"),e._uU(835,"userId"),e.qZA(),e._uU(836,' in a list of revoked tokens, enabling us to perform token revocation. The model we\'ve implemented here in our sample code is a fast, "stateless JWT" model, where each API call is immediately authorized based on the presence of a valid JWT, and a small bit of information about the requester (its '),e.TgZ(837,"code"),e._uU(838,"userId"),e.qZA(),e._uU(839," and "),e.TgZ(840,"code"),e._uU(841,"username"),e.qZA(),e._uU(842,") is available in our Request pipeline."),e.qZA(),e.TgZ(843,"p"),e._uU(844,"Add the new "),e.TgZ(845,"code"),e._uU(846,"JwtStrategy"),e.qZA(),e._uU(847," as a provider in the "),e.TgZ(848,"code"),e._uU(849,"AuthModule"),e.qZA(),e._uU(850,":"),e.qZA(),e.TgZ(851,"span",17),e._uU(852),e.ALo(853,"extension"),e._UZ(854,"app-tabs",null,50),e.qZA(),e.TgZ(856,"pre")(857,"code",19),e._uU(858,"\nimport { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { LocalStrategy } from './local.strategy';\nimport { JwtStrategy } from './jwt.strategy';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtModule } from '@nestjs/jwt';\nimport { jwtConstants } from './constants';\n\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '60s' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy, JwtStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n"),e.qZA()(),e.TgZ(859,"pre")(860,"code",19),e._uU(861,"\nimport { Module } from '@nestjs/common';\nimport { AuthService } from './auth.service';\nimport { LocalStrategy } from './local.strategy';\nimport { JwtStrategy } from './jwt.strategy';\nimport { UsersModule } from '../users/users.module';\nimport { PassportModule } from '@nestjs/passport';\nimport { JwtModule } from '@nestjs/jwt';\nimport { jwtConstants } from './constants';\n\n@Module({\n  imports: [\n    UsersModule,\n    PassportModule,\n    JwtModule.register({\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '60s' },\n    }),\n  ],\n  providers: [AuthService, LocalStrategy, JwtStrategy],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n"),e.qZA()(),e.TgZ(862,"p"),e._uU(863,"By importing the same secret used when we signed the JWT, we ensure that the "),e.TgZ(864,"strong"),e._uU(865,"verify"),e.qZA(),e._uU(866," phase performed by Passport, and the "),e.TgZ(867,"strong"),e._uU(868,"sign"),e.qZA(),e._uU(869," phase performed in our AuthService, use a common secret."),e.qZA(),e.TgZ(870,"p"),e._uU(871,"Finally, we define the "),e.TgZ(872,"code"),e._uU(873,"JwtAuthGuard"),e.qZA(),e._uU(874," class which extends the built-in "),e.TgZ(875,"code"),e._uU(876,"AuthGuard"),e.qZA(),e._uU(877,":"),e.qZA(),e.TgZ(878,"span",17),e._uU(879),e.ALo(880,"extension"),e._UZ(881,"app-tabs",null,51),e.qZA(),e.TgZ(883,"pre")(884,"code",19),e._uU(885,"\nimport { Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {}\n"),e.qZA()(),e.TgZ(886,"h4",52)(887,"span"),e._uU(888,"Implement protected route and JWT strategy guards"),e.qZA()(),e.TgZ(889,"p"),e._uU(890,"We can now implement our protected route and its associated Guard."),e.qZA(),e.TgZ(891,"p"),e._uU(892,"Open the "),e.TgZ(893,"code"),e._uU(894,"app.controller.ts"),e.qZA(),e._uU(895," file and update it as shown below:"),e.qZA(),e.TgZ(896,"span",17),e._uU(897),e.ALo(898,"extension"),e._UZ(899,"app-tabs",null,53),e.qZA(),e.TgZ(901,"pre")(902,"code",19),e._uU(903,"\nimport { Controller, Get, Request, Post, UseGuards } from '@nestjs/common';\nimport { JwtAuthGuard } from './auth/jwt-auth.guard';\nimport { LocalAuthGuard } from './auth/local-auth.guard';\nimport { AuthService } from './auth/auth.service';\n\n@Controller()\nexport class AppController {\n  constructor(private authService: AuthService) {}\n\n  @UseGuards(LocalAuthGuard)\n  @Post('auth/login')\n  async login(@Request() req) {\n    return this.authService.login(req.user);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Get('profile')\n  getProfile(@Request() req) {\n    return req.user;\n  }\n}\n"),e.qZA()(),e.TgZ(904,"pre")(905,"code",19),e._uU(906,"\nimport { Controller, Dependencies, Bind, Get, Request, Post, UseGuards } from '@nestjs/common';\nimport { JwtAuthGuard } from './auth/jwt-auth.guard';\nimport { LocalAuthGuard } from './auth/local-auth.guard';\nimport { AuthService } from './auth/auth.service';\n\n@Dependencies(AuthService)\n@Controller()\nexport class AppController {\n  constructor(authService) {\n    this.authService = authService;\n  }\n\n  @UseGuards(LocalAuthGuard)\n  @Post('auth/login')\n  @Bind(Request())\n  async login(req) {\n    return this.authService.login(req.user);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Get('profile')\n  @Bind(Request())\n  getProfile(req) {\n    return req.user;\n  }\n}\n"),e.qZA()(),e.TgZ(907,"p"),e._uU(908,"Once again, we're applying the "),e.TgZ(909,"code"),e._uU(910,"AuthGuard"),e.qZA(),e._uU(911," that the "),e.TgZ(912,"code"),e._uU(913,"@nestjs/passport"),e.qZA(),e._uU(914," module has automatically provisioned for us when we configured the passport-jwt module. This Guard is referenced by its default name, "),e.TgZ(915,"code"),e._uU(916,"jwt"),e.qZA(),e._uU(917,". When our "),e.TgZ(918,"code"),e._uU(919,"GET /profile"),e.qZA(),e._uU(920," route is hit, the Guard will automatically invoke our passport-jwt custom configured logic, validating the JWT, and assigning the "),e.TgZ(921,"code"),e._uU(922,"user"),e.qZA(),e._uU(923," property to the "),e.TgZ(924,"code"),e._uU(925,"Request"),e.qZA(),e._uU(926," object."),e.qZA(),e.TgZ(927,"p"),e._uU(928,"Ensure the app is running, and test the routes using "),e.TgZ(929,"code"),e._uU(930,"cURL"),e.qZA(),e._uU(931,"."),e.qZA(),e.TgZ(932,"pre")(933,"code",14),e._uU(934,'\n$ # GET /profile\n$ curl http://localhost:3000/profile\n$ # result -> {"statusCode":401,"message":"Unauthorized"}\n\n$ # POST /auth/login\n$ curl -X POST http://localhost:3000/auth/login -d \'{"username": "john", "password": "changeme"}\' -H "Content-Type: application/json"\n$ # result -> {"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm... }\n\n$ # GET /profile using access_token returned from previous step as bearer code\n$ curl http://localhost:3000/profile -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm..."\n$ # result -> {"userId":1,"username":"john"}\n'),e.qZA()(),e.TgZ(935,"p"),e._uU(936,"Note that in the "),e.TgZ(937,"code"),e._uU(938,"AuthModule"),e.qZA(),e._uU(939,", we configured the JWT to have an expiration of "),e.TgZ(940,"code"),e._uU(941,"60 seconds"),e.qZA(),e._uU(942,". This is probably too short an expiration, and dealing with the details of token expiration and refresh is beyond the scope of this article. However, we chose that to demonstrate an important quality of JWTs and the passport-jwt strategy. If you wait 60 seconds after authenticating before attempting a "),e.TgZ(943,"code"),e._uU(944,"GET /profile"),e.qZA(),e._uU(945," request, you'll receive a "),e.TgZ(946,"code"),e._uU(947,"401 Unauthorized"),e.qZA(),e._uU(948," response. This is because Passport automatically checks the JWT for its expiration time, saving you the trouble of doing so in your application."),e.qZA(),e.TgZ(949,"p"),e._uU(950,"We've now completed our JWT authentication implementation. JavaScript clients (such as Angular/React/Vue), and other JavaScript apps, can now authenticate and communicate securely with our API Server."),e.qZA(),e.TgZ(951,"h4",54)(952,"span"),e._uU(953,"Example"),e.qZA()(),e.TgZ(954,"p"),e._uU(955,"You can find a complete version of the code in this chapter "),e.TgZ(956,"a",10),e._uU(957,"here"),e.qZA(),e._uU(958,"."),e.qZA(),e.TgZ(959,"h4",55)(960,"span"),e._uU(961,"Extending guards"),e.qZA()(),e.TgZ(962,"p"),e._uU(963,"In most cases, using a provided "),e.TgZ(964,"code"),e._uU(965,"AuthGuard"),e.qZA(),e._uU(966," class is sufficient. However, there might be use-cases when you would like to simply extend the default error handling or authentication logic. For this, you can extend the built-in class and override methods within a sub-class."),e.qZA(),e.TgZ(967,"pre")(968,"code",19),e._uU(969,"\nimport {\n  ExecutionContext,\n  Injectable,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  canActivate(context: ExecutionContext) {\n    // Add your custom authentication logic here\n    // for example, call super.logIn(request) to establish a session.\n    return super.canActivate(context);\n  }\n\n  handleRequest(err, user, info) {\n    // You can throw an exception based on either \"info\" or \"err\" arguments\n    if (err || !user) {\n      throw err || new UnauthorizedException();\n    }\n    return user;\n  }\n}\n"),e.qZA()(),e.TgZ(970,"p"),e._uU(971,"In addition to extending the default error handling and authentication logic, we can allow authentication to go through a chain of strategies. The first strategy to succeed, redirect, or error will halt the chain. Authentication failures will proceed through each strategy in series, ultimately failing if all strategies fail."),e.qZA(),e.TgZ(972,"pre")(973,"code",19),e._uU(974,"\nexport class JwtAuthGuard extends AuthGuard(['strategy_jwt_1', 'strategy_jwt_2', '...']) { ... }\n"),e.qZA()(),e.TgZ(975,"h4",56)(976,"span"),e._uU(977,"Enable authentication globally"),e.qZA()(),e.TgZ(978,"p"),e._uU(979,"If the vast majority of your endpoints should be protected by default, you can register the authentication guard as a "),e.TgZ(980,"a",57),e._uU(981,"global guard"),e.qZA(),e._uU(982," and instead of using "),e.TgZ(983,"code"),e._uU(984,"@UseGuards()"),e.qZA(),e._uU(985," decorator on top of each controller, you could simply flag which routes should be public."),e.qZA(),e.TgZ(986,"p"),e._uU(987,"First, register the "),e.TgZ(988,"code"),e._uU(989,"JwtAuthGuard"),e.qZA(),e._uU(990," as a global guard using the following construction (in any module):"),e.qZA(),e.TgZ(991,"pre")(992,"code",19),e._uU(993,"\nproviders: [\n  {\n    provide: APP_GUARD,\n    useClass: JwtAuthGuard,\n  },\n],\n"),e.qZA()(),e.TgZ(994,"p"),e._uU(995,"With this in place, Nest will automatically bind "),e.TgZ(996,"code"),e._uU(997,"JwtAuthGuard"),e.qZA(),e._uU(998," to all endpoints."),e.qZA(),e.TgZ(999,"p"),e._uU(1e3,"Now we must provide a mechanism for declaring routes as public. For this, we can create a custom decorator using the "),e.TgZ(1001,"code"),e._uU(1002,"SetMetadata"),e.qZA(),e._uU(1003," decorator factory function."),e.qZA(),e.TgZ(1004,"pre")(1005,"code",19),e._uU(1006,"\nimport { SetMetadata } from '@nestjs/common';\n\nexport const IS_PUBLIC_KEY = 'isPublic';\nexport const Public = () => SetMetadata(IS_PUBLIC_KEY, true);\n"),e.qZA()(),e.TgZ(1007,"p"),e._uU(1008,"In the file above, we exported two constants. One being our metadata key named "),e.TgZ(1009,"code"),e._uU(1010,"IS_PUBLIC_KEY"),e.qZA(),e._uU(1011,", and the other being our new decorator itself that we\u2019re going to call "),e.TgZ(1012,"code"),e._uU(1013,"Public"),e.qZA(),e._uU(1014," (you can alternatively name it "),e.TgZ(1015,"code"),e._uU(1016,"SkipAuth"),e.qZA(),e._uU(1017," or "),e.TgZ(1018,"code"),e._uU(1019,"AllowAnon"),e.qZA(),e._uU(1020,", whatever fits your project)."),e.qZA(),e.TgZ(1021,"p"),e._uU(1022,"Now that we have a custom "),e.TgZ(1023,"code"),e._uU(1024,"@Public()"),e.qZA(),e._uU(1025," decorator, we can use it to decorate any method, as follows:"),e.qZA(),e.TgZ(1026,"pre")(1027,"code",19),e._uU(1028,"\n@Public()\n@Get()\nfindAll() {\n  return [];\n}\n"),e.qZA()(),e.TgZ(1029,"p"),e._uU(1030,"Lastly, we need the "),e.TgZ(1031,"code"),e._uU(1032,"JwtAuthGuard"),e.qZA(),e._uU(1033," to return "),e.TgZ(1034,"code"),e._uU(1035,"true"),e.qZA(),e._uU(1036," when the "),e.TgZ(1037,"code"),e._uU(1038,'"isPublic"'),e.qZA(),e._uU(1039," metadata is found. For this, we'll use the "),e.TgZ(1040,"code"),e._uU(1041,"Reflector"),e.qZA(),e._uU(1042," class (read more "),e.TgZ(1043,"a",58),e._uU(1044,"here"),e.qZA(),e._uU(1045,")."),e.qZA(),e.TgZ(1046,"pre")(1047,"code",19),e._uU(1048,"\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  constructor(private reflector: Reflector) {\n    super();\n  }\n\n  canActivate(context: ExecutionContext) {\n    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (isPublic) {\n      return true;\n    }\n    return super.canActivate(context);\n  }\n}\n"),e.qZA()(),e.TgZ(1049,"h4",59)(1050,"span"),e._uU(1051,"Request-scoped strategies"),e.qZA()(),e.TgZ(1052,"p"),e._uU(1053,"The passport API is based on registering strategies to the global instance of the library. Therefore strategies are not designed to have request-dependent options or to be dynamically instantiated per request (read more about the "),e.TgZ(1054,"a",60),e._uU(1055,"request-scoped"),e.qZA(),e._uU(1056,' providers). When you configure your strategy to be request-scoped, Nest will never instantiate it since it\'s not tied to any specific route. There is no physical way to determine which "request-scoped" strategies should be executed per request.'),e.qZA(),e.TgZ(1057,"p"),e._uU(1058,"However, there are ways to dynamically resolve request-scoped providers within the strategy. For this, we leverage the "),e.TgZ(1059,"a",61),e._uU(1060,"module reference"),e.qZA(),e._uU(1061," feature."),e.qZA(),e.TgZ(1062,"p"),e._uU(1063,"First, open the "),e.TgZ(1064,"code"),e._uU(1065,"local.strategy.ts"),e.qZA(),e._uU(1066," file and inject the "),e.TgZ(1067,"code"),e._uU(1068,"ModuleRef"),e.qZA(),e._uU(1069," in the normal way:"),e.qZA(),e.TgZ(1070,"pre")(1071,"code",19),e._uU(1072,"\nconstructor(private moduleRef: ModuleRef) {\n  super({\n    passReqToCallback: true,\n  });\n}\n"),e.qZA()(),e.TgZ(1073,"blockquote",27)(1074,"strong"),e._uU(1075,"Hint"),e.qZA(),e._uU(1076," The "),e.TgZ(1077,"code"),e._uU(1078,"ModuleRef"),e.qZA(),e._uU(1079," class is imported from the "),e.TgZ(1080,"code"),e._uU(1081,"@nestjs/core"),e.qZA(),e._uU(1082," package.\n"),e.qZA(),e.TgZ(1083,"p"),e._uU(1084,"Be sure to set the "),e.TgZ(1085,"code"),e._uU(1086,"passReqToCallback"),e.qZA(),e._uU(1087," configuration property to "),e.TgZ(1088,"code"),e._uU(1089,"true"),e.qZA(),e._uU(1090,", as shown above."),e.qZA(),e.TgZ(1091,"p"),e._uU(1092,"In the next step, the request instance will be used to obtain the current context identifier, instead of generating a new one (read more about request context "),e.TgZ(1093,"a",62),e._uU(1094,"here"),e.qZA(),e._uU(1095,")."),e.qZA(),e.TgZ(1096,"p"),e._uU(1097,"Now, inside the "),e.TgZ(1098,"code"),e._uU(1099,"validate()"),e.qZA(),e._uU(1100," method of the "),e.TgZ(1101,"code"),e._uU(1102,"LocalStrategy"),e.qZA(),e._uU(1103," class, use the "),e.TgZ(1104,"code"),e._uU(1105,"getByRequest()"),e.qZA(),e._uU(1106," method of the "),e.TgZ(1107,"code"),e._uU(1108,"ContextIdFactory"),e.qZA(),e._uU(1109," class to create a context id based on the request object, and pass this to the "),e.TgZ(1110,"code"),e._uU(1111,"resolve()"),e.qZA(),e._uU(1112," call:"),e.qZA(),e.TgZ(1113,"pre")(1114,"code",19),e._uU(1115,'\nasync validate(\n  request: Request,\n  username: string,\n  password: string,\n) {\n  const contextId = ContextIdFactory.getByRequest(request);\n  // "AuthService" is a request-scoped provider\n  const authService = await this.moduleRef.resolve(AuthService, contextId);\n  ...\n}\n'),e.qZA()(),e.TgZ(1116,"p"),e._uU(1117,"In the example above, the "),e.TgZ(1118,"code"),e._uU(1119,"resolve()"),e.qZA(),e._uU(1120," method will asynchronously return the request-scoped instance of the "),e.TgZ(1121,"code"),e._uU(1122,"AuthService"),e.qZA(),e._uU(1123," provider (we assumed that "),e.TgZ(1124,"code"),e._uU(1125,"AuthService"),e.qZA(),e._uU(1126," is marked as a request-scoped provider)."),e.qZA(),e.TgZ(1127,"h4",63)(1128,"span"),e._uU(1129,"Customize Passport"),e.qZA()(),e.TgZ(1130,"p"),e._uU(1131,"Any standard Passport customization options can be passed the same way, using the "),e.TgZ(1132,"code"),e._uU(1133,"register()"),e.qZA(),e._uU(1134," method. The available options depend on the strategy being implemented. For example:"),e.qZA(),e.TgZ(1135,"pre")(1136,"code",19),e._uU(1137,"\nPassportModule.register({ session: true });\n"),e.qZA()(),e.TgZ(1138,"p"),e._uU(1139,"You can also pass strategies an options object in their constructors to configure them.\nFor the local strategy you can pass e.g.:"),e.qZA(),e.TgZ(1140,"pre")(1141,"code",19),e._uU(1142,"\nconstructor(private authService: AuthService) {\n  super({\n    usernameField: 'email',\n    passwordField: 'password',\n  });\n}\n"),e.qZA()(),e.TgZ(1143,"p"),e._uU(1144,"Take a look at the official "),e.TgZ(1145,"a",64),e._uU(1146,"Passport Website"),e.qZA(),e._uU(1147," for property names."),e.qZA(),e.TgZ(1148,"h4",65)(1149,"span"),e._uU(1150,"Named strategies"),e.qZA()(),e.TgZ(1151,"p"),e._uU(1152,"When implementing a strategy, you can provide a name for it by passing a second argument to the "),e.TgZ(1153,"code"),e._uU(1154,"PassportStrategy"),e.qZA(),e._uU(1155," function. If you don't do this, each strategy will have a default name (e.g., 'jwt' for jwt-strategy):"),e.qZA(),e.TgZ(1156,"pre")(1157,"code",19),e._uU(1158,"\nexport class JwtStrategy extends PassportStrategy(Strategy, 'myjwt')\n"),e.qZA()(),e.TgZ(1159,"p"),e._uU(1160,"Then, you refer to this via a decorator like "),e.TgZ(1161,"code"),e._uU(1162,"@UseGuards(AuthGuard('myjwt'))"),e.qZA(),e._uU(1163,"."),e.qZA(),e.TgZ(1164,"h4",66)(1165,"span"),e._uU(1166,"GraphQL"),e.qZA()(),e.TgZ(1167,"p"),e._uU(1168,"In order to use an AuthGuard with "),e.TgZ(1169,"a",67),e._uU(1170,"GraphQL"),e.qZA(),e._uU(1171,", extend the built-in AuthGuard class and override the getRequest() method."),e.qZA(),e.TgZ(1172,"pre")(1173,"code",19),e._uU(1174,"\n@Injectable()\nexport class GqlAuthGuard extends AuthGuard('jwt') {\n  getRequest(context: ExecutionContext) {\n    const ctx = GqlExecutionContext.create(context);\n    return ctx.getContext().req;\n  }\n}\n"),e.qZA()(),e.TgZ(1175,"p"),e._uU(1176,"To get the current authenticated user in your graphql resolver, you can define a "),e.TgZ(1177,"code"),e._uU(1178,"@CurrentUser()"),e.qZA(),e._uU(1179," decorator:"),e.qZA(),e.TgZ(1180,"pre")(1181,"code",19),e._uU(1182,"\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\nimport { GqlExecutionContext } from '@nestjs/graphql';\n\nexport const CurrentUser = createParamDecorator(\n  (data: unknown, context: ExecutionContext) => {\n    const ctx = GqlExecutionContext.create(context);\n    return ctx.getContext().req.user;\n  },\n);\n"),e.qZA()(),e.TgZ(1183,"p"),e._uU(1184,"To use above decorator in your resolver, be sure to include it as a parameter of your query or mutation:"),e.qZA(),e.TgZ(1185,"pre")(1186,"code",19),e._uU(1187,"\n@Query(returns => User)\n@UseGuards(GqlAuthGuard)\nwhoAmI(@CurrentUser() user: User) {\n  return this.usersService.findById(user.id);\n}\n"),e.qZA()()()),2&n){const p=e.MAs(160),u=e.MAs(185),c=e.MAs(207),l=e.MAs(238),d=e.MAs(263),g=e.MAs(357),Z=e.MAs(436),C=e.MAs(508),U=e.MAs(594),_=e.MAs(644),m=e.MAs(674),A=e.MAs(707),f=e.MAs(743),T=e.MAs(855),P=e.MAs(882),q=e.MAs(900);e.xp6(157),e.hij(" ",e.xi3(158,74,"users/users.service",p.isJsActive),"\n"),e.xp6(4),e.ekj("hide",p.isJsActive),e.xp6(3),e.ekj("hide",!p.isJsActive),e.xp6(18),e.hij(" ",e.xi3(183,77,"users/users.module",u.isJsActive),"\n"),e.xp6(4),e.ekj("hide",u.isJsActive),e.xp6(3),e.ekj("hide",!u.isJsActive),e.xp6(15),e.hij(" ",e.xi3(205,80,"auth/auth.service",c.isJsActive),"\n"),e.xp6(4),e.ekj("hide",c.isJsActive),e.xp6(3),e.ekj("hide",!c.isJsActive),e.xp6(24),e.hij(" ",e.xi3(236,83,"auth/auth.module",l.isJsActive),"\n"),e.xp6(4),e.ekj("hide",l.isJsActive),e.xp6(3),e.ekj("hide",!l.isJsActive),e.xp6(18),e.hij(" ",e.xi3(261,86,"auth/local.strategy",d.isJsActive),"\n"),e.xp6(4),e.ekj("hide",d.isJsActive),e.xp6(3),e.ekj("hide",!d.isJsActive),e.xp6(22),e.AsE("super(","{"," usernameField: 'email' ","}",")"),e.xp6(65),e.hij(" ",e.xi3(355,89,"auth/auth.module",g.isJsActive),"\n"),e.xp6(4),e.ekj("hide",g.isJsActive),e.xp6(3),e.ekj("hide",!g.isJsActive),e.xp6(72),e.hij(" ",e.xi3(434,92,"app.controller",Z.isJsActive),"\n"),e.xp6(4),e.ekj("hide",Z.isJsActive),e.xp6(3),e.ekj("hide",!Z.isJsActive),e.xp6(65),e.hij(" ",e.xi3(506,95,"auth/local-auth.guard",C.isJsActive),"\n"),e.xp6(86),e.hij(" ",e.xi3(592,98,"auth/auth.service",U.isJsActive),"\n"),e.xp6(4),e.ekj("hide",U.isJsActive),e.xp6(3),e.ekj("hide",!U.isJsActive),e.xp6(43),e.hij(" ",e.xi3(642,101,"auth/constants",_.isJsActive),"\n"),e.xp6(4),e.ekj("hide",_.isJsActive),e.xp6(3),e.ekj("hide",!_.isJsActive),e.xp6(23),e.hij(" ",e.xi3(672,104,"auth/auth.module",m.isJsActive),"\n"),e.xp6(4),e.ekj("hide",m.isJsActive),e.xp6(3),e.ekj("hide",!m.isJsActive),e.xp6(26),e.hij(" ",e.xi3(705,107,"app.controller",A.isJsActive),"\n"),e.xp6(4),e.ekj("hide",A.isJsActive),e.xp6(3),e.ekj("hide",!A.isJsActive),e.xp6(29),e.hij(" ",e.xi3(741,110,"auth/jwt.strategy",f.isJsActive),"\n"),e.xp6(4),e.ekj("hide",f.isJsActive),e.xp6(3),e.ekj("hide",!f.isJsActive),e.xp6(105),e.hij(" ",e.xi3(853,113,"auth/auth.module",T.isJsActive),"\n"),e.xp6(4),e.ekj("hide",T.isJsActive),e.xp6(3),e.ekj("hide",!T.isJsActive),e.xp6(20),e.hij(" ",e.xi3(880,116,"auth/jwt-auth.guard",P.isJsActive),"\n"),e.xp6(18),e.hij(" ",e.xi3(898,119,"app.controller",q.isJsActive),"\n"),e.xp6(4),e.ekj("hide",q.isJsActive),e.xp6(3),e.ekj("hide",!q.isJsActive)}},dependencies:[b.n,i.U,j.f,h.yS,w.F],encapsulation:2,changeDetection:0}),t})(),data:{title:"Authentication"}},{path:"cors",component:(()=>{class t extends a.y{}return t.\u0275fac=function(){let o;return function(s){return(o||(o=e.n5z(t)))(s||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-cors"]],features:[e.qOj],decls:88,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/security/cors.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","cors"],["rel","nofollow","target","_blank","href","https://github.com/expressjs/cors"],["appAnchor","","id","getting-started"],[1,"language-typescript"],["rel","nofollow","target","_blank","href","https://github.com/expressjs/cors#configuration-options"],["rel","nofollow","target","_blank","href","https://github.com/expressjs/cors#configuring-cors-asynchronously"],[1,"warning"]],template:function(n,s){1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"CORS"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"Cross-origin resource sharing (CORS) is a mechanism that allows resources to be requested from another domain. Under the hood, Nest makes use of the Express "),e.TgZ(9,"a",6),e._uU(10,"cors"),e.qZA(),e._uU(11," package. This package provides various options that you can customize based on your requirements."),e.qZA(),e.TgZ(12,"h4",7)(13,"span"),e._uU(14,"Getting started"),e.qZA()(),e.TgZ(15,"p"),e._uU(16,"To enable CORS, call the "),e.TgZ(17,"code"),e._uU(18,"enableCors()"),e.qZA(),e._uU(19," method on the Nest application object."),e.qZA(),e.TgZ(20,"pre")(21,"code",8),e._uU(22,"\nconst app = await NestFactory.create(AppModule);\napp.enableCors();\nawait app.listen(3000);\n"),e.qZA()(),e.TgZ(23,"p"),e._uU(24,"The "),e.TgZ(25,"code"),e._uU(26,"enableCors()"),e.qZA(),e._uU(27," method takes an optional configuration object argument. The available properties of this object are described in the official "),e.TgZ(28,"a",9),e._uU(29,"CORS"),e.qZA(),e._uU(30," documentation. Another way is to pass a "),e.TgZ(31,"a",10),e._uU(32,"callback function"),e.qZA(),e._uU(33," that lets you define the configuration object asynchronously based on the request (on the fly)."),e.qZA(),e.TgZ(34,"p"),e._uU(35,"Alternatively, enable CORS via the "),e.TgZ(36,"code"),e._uU(37,"create()"),e.qZA(),e._uU(38," method's options object. Set the "),e.TgZ(39,"code"),e._uU(40,"cors"),e.qZA(),e._uU(41," property to "),e.TgZ(42,"code"),e._uU(43,"true"),e.qZA(),e._uU(44," to enable CORS with default settings.\nOr, pass a "),e.TgZ(45,"a",9),e._uU(46,"CORS configuration object"),e.qZA(),e._uU(47," or "),e.TgZ(48,"a",10),e._uU(49,"callback function"),e.qZA(),e._uU(50," as the "),e.TgZ(51,"code"),e._uU(52,"cors"),e.qZA(),e._uU(53," property value to customize its behavior."),e.qZA(),e.TgZ(54,"pre")(55,"code",8),e._uU(56,"\nconst app = await NestFactory.create(AppModule, { cors: true });\nawait app.listen(3000);\n"),e.qZA()(),e.TgZ(57,"p"),e._uU(58,"Above method only applies to REST endpoints."),e.qZA(),e.TgZ(59,"p"),e._uU(60,"To enable CORS in GraphQL, set "),e.TgZ(61,"code"),e._uU(62,"cors"),e.qZA(),e._uU(63," property to "),e.TgZ(64,"code"),e._uU(65,"true"),e.qZA(),e._uU(66," or pass "),e.TgZ(67,"a",9),e._uU(68,"CORS configuration object"),e.qZA(),e._uU(69," or a "),e.TgZ(70,"a",10),e._uU(71,"callback function"),e.qZA(),e._uU(72," as the "),e.TgZ(73,"code"),e._uU(74,"cors"),e.qZA(),e._uU(75," property value when you import GraphQL module."),e.qZA(),e.TgZ(76,"blockquote",11)(77,"strong"),e._uU(78,"Warning"),e.qZA(),e.TgZ(79,"code"),e._uU(80,"CorsOptionsDelegate"),e.qZA(),e._uU(81," solution is not working with the "),e.TgZ(82,"code"),e._uU(83,"apollo-server-fastify"),e.qZA(),e._uU(84," package yet.\n"),e.qZA(),e.TgZ(85,"pre")(86,"code",8),e._uU(87,"\nGraphQLModule.forRoot({\n  cors: {\n    origin: 'http://localhost:3000',\n    credentials: true,\n  },\n}),\n"),e.qZA()()())},dependencies:[i.U],encapsulation:2,changeDetection:0}),t})(),data:{title:"CORS"}},{path:"helmet",component:(()=>{class t extends a.y{}return t.\u0275fac=function(){let o;return function(s){return(o||(o=e.n5z(t)))(s||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-helmet"]],features:[e.qOj],decls:114,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/security/helmet.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","helmet"],["rel","nofollow","target","_blank","href","https://github.com/helmetjs/helmet"],["rel","nofollow","target","_blank","href","https://github.com/helmetjs/helmet#how-it-works"],[1,"info"],["appAnchor","","id","use-with-express-default"],[1,"language-bash"],[1,"language-typescript"],["appAnchor","","id","use-with-fastify"],["rel","nofollow","target","_blank","href","https://github.com/fastify/fastify-helmet"],["rel","nofollow","target","_blank","href","https://www.fastify.io/docs/latest/Reference/Plugins/"],[1,"warning"],["rel","nofollow","target","_blank","href","https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP"]],template:function(n,s){1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Helmet"),e.qZA(),e.TgZ(7,"p")(8,"a",6),e._uU(9,"Helmet"),e.qZA(),e._uU(10," can help protect your app from some well-known web vulnerabilities by setting HTTP headers appropriately. Generally, Helmet is just a collection of smaller middleware functions that set security-related HTTP headers (read "),e.TgZ(11,"a",7),e._uU(12,"more"),e.qZA(),e._uU(13,")."),e.qZA(),e.TgZ(14,"blockquote",8)(15,"strong"),e._uU(16,"Hint"),e.qZA(),e._uU(17," Note that applying "),e.TgZ(18,"code"),e._uU(19,"helmet"),e.qZA(),e._uU(20," as global or registering it must come before other calls to "),e.TgZ(21,"code"),e._uU(22,"app.use()"),e.qZA(),e._uU(23," or setup functions that may call "),e.TgZ(24,"code"),e._uU(25,"app.use()"),e.qZA(),e._uU(26,". This is due to the way the underlying platform (i.e., Express or Fastify) works, where the order that middleware/routes are defined matters. If you use middleware like "),e.TgZ(27,"code"),e._uU(28,"helmet"),e.qZA(),e._uU(29," or "),e.TgZ(30,"code"),e._uU(31,"cors"),e.qZA(),e._uU(32," after you define a route, then that middleware will not apply to that route, it will only apply to routes defined after the middleware.\n"),e.qZA(),e.TgZ(33,"h4",9)(34,"span"),e._uU(35,"Use with Express (default)"),e.qZA()(),e.TgZ(36,"p"),e._uU(37,"Start by installing the required package."),e.qZA(),e.TgZ(38,"pre")(39,"code",10),e._uU(40,"\n$ npm i --save helmet\n"),e.qZA()(),e.TgZ(41,"p"),e._uU(42,"Once the installation is complete, apply it as a global middleware."),e.qZA(),e.TgZ(43,"pre")(44,"code",11),e._uU(45,"\nimport * as helmet from 'helmet';\n// somewhere in your initialization file\napp.use(helmet());\n"),e.qZA()(),e.TgZ(46,"blockquote",8)(47,"strong"),e._uU(48,"Hint"),e.qZA(),e._uU(49," If you are getting the "),e.TgZ(50,"code"),e._uU(51,"This expression is not callable"),e.qZA(),e._uU(52," error while trying to import "),e.TgZ(53,"code"),e._uU(54,"Helmet"),e.qZA(),e._uU(55,", you very likely have the "),e.TgZ(56,"code"),e._uU(57,"allowSyntheticDefaultImports"),e.qZA(),e._uU(58," and "),e.TgZ(59,"code"),e._uU(60,"esModuleInterop"),e.qZA(),e._uU(61," options set to "),e.TgZ(62,"code"),e._uU(63,"true"),e.qZA(),e._uU(64," in your project's "),e.TgZ(65,"code"),e._uU(66,"tsconfig.json"),e.qZA(),e._uU(67," file. If that's the case, change the import statement to: "),e.TgZ(68,"code"),e._uU(69,"import helmet from 'helmet'"),e.qZA(),e._uU(70," instead.\n"),e.qZA(),e.TgZ(71,"h4",12)(72,"span"),e._uU(73,"Use with Fastify"),e.qZA()(),e.TgZ(74,"p"),e._uU(75,"If you are using the "),e.TgZ(76,"code"),e._uU(77,"FastifyAdapter"),e.qZA(),e._uU(78,", install the "),e.TgZ(79,"a",13),e._uU(80,"fastify-helmet"),e.qZA(),e._uU(81," package:"),e.qZA(),e.TgZ(82,"pre")(83,"code",10),e._uU(84,"\n$ npm i --save fastify-helmet\n"),e.qZA()(),e.TgZ(85,"p")(86,"a",13),e._uU(87,"fastify-helmet"),e.qZA(),e._uU(88," should not be used as a middleware, but as a "),e.TgZ(89,"a",14),e._uU(90,"Fastify plugin"),e.qZA(),e._uU(91,", i.e., by using "),e.TgZ(92,"code"),e._uU(93,"app.register()"),e.qZA(),e._uU(94,":"),e.qZA(),e.TgZ(95,"pre")(96,"code",11),e._uU(97,"\nimport { fastifyHelmet } from 'fastify-helmet';\n// somewhere in your initialization file\nawait app.register(fastifyHelmet);\n"),e.qZA()(),e.TgZ(98,"blockquote",15)(99,"strong"),e._uU(100,"Warning"),e.qZA(),e._uU(101," When using "),e.TgZ(102,"code"),e._uU(103,"apollo-server-fastify"),e.qZA(),e._uU(104," and "),e.TgZ(105,"code"),e._uU(106,"fastify-helmet"),e.qZA(),e._uU(107,", there may be a problem with "),e.TgZ(108,"a",16),e._uU(109,"CSP"),e.qZA(),e._uU(110," on the GraphQL playground, to solve this collision, configure the CSP as shown below:\n"),e.TgZ(111,"pre")(112,"code",11),e._uU(113,"\nawait app.register(fastifyHelmet, {\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [`'self'`],\n      styleSrc: [\n        `'self'`,\n        `'unsafe-inline'`,\n        'cdn.jsdelivr.net',\n        'fonts.googleapis.com',\n      ],\n      fontSrc: [`'self'`, 'fonts.gstatic.com'],\n      imgSrc: [`'self'`, 'data:', 'cdn.jsdelivr.net'],\n      scriptSrc: [`'self'`, `https: 'unsafe-inline'`, `cdn.jsdelivr.net`],\n    },\n  },\n});\n\n// If you are not going to use CSP at all, you can use this:\nawait app.register(fastifyHelmet, {\n  contentSecurityPolicy: false,\n});\n"),e.qZA()()()())},dependencies:[i.U],encapsulation:2,changeDetection:0}),t})(),data:{title:"Helmet"}},{path:"encryption-and-hashing",component:(()=>{class t extends a.y{}return t.\u0275fac=function(){let o;return function(s){return(o||(o=e.n5z(t)))(s||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-encryption-hashing"]],features:[e.qOj],decls:89,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/security/encryption-hashing.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","encryption-and-hashing"],["appAnchor","","id","encryption"],["rel","nofollow","target","_blank","href","https://nodejs.org/api/crypto.html"],[1,"language-typescript"],["appAnchor","","id","hashing"],["rel","nofollow","target","_blank","href","https://www.npmjs.com/package/bcrypt"],["rel","nofollow","target","_blank","href","https://www.npmjs.com/package/argon2"],[1,"language-shell"]],template:function(n,s){1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Encryption and Hashing"),e.qZA(),e.TgZ(7,"p")(8,"strong"),e._uU(9,"Encryption"),e.qZA(),e._uU(10," is the process of encoding information. This process converts the original representation of the information, known as plaintext, into an alternative form known as ciphertext. Ideally, only authorized parties can decipher a ciphertext back to plaintext and access the original information. Encryption does not itself prevent interference but denies the intelligible content to a would-be interceptor. Encryption is a two-way function; what is encrypted can be decrypted with the proper key."),e.qZA(),e.TgZ(11,"p")(12,"strong"),e._uU(13,"Hashing"),e.qZA(),e._uU(14," is the process of converting a given key into another value. A hash function is used to generate the new value according to a mathematical algorithm. Once hashing has been done, it should be impossible to go from the output to the input."),e.qZA(),e.TgZ(15,"h4",6)(16,"span"),e._uU(17,"Encryption"),e.qZA()(),e.TgZ(18,"p"),e._uU(19,"Node.js provides a built-in "),e.TgZ(20,"a",7),e._uU(21,"crypto module"),e.qZA(),e._uU(22," that you can use to encrypt and decrypt strings, numbers, buffers, streams, and more. Nest itself does not provide any additional package on top of this module to avoid introducing unnecessary abstractions."),e.qZA(),e.TgZ(23,"p"),e._uU(24,"As an example, let's use AES (Advanced Encryption System) "),e.TgZ(25,"code"),e._uU(26,"'aes-256-ctr'"),e.qZA(),e._uU(27," algorithm CTR encryption mode."),e.qZA(),e.TgZ(28,"pre")(29,"code",8),e._uU(30,"\nimport { createCipheriv, randomBytes, scrypt } from 'crypto';\nimport { promisify } from 'util';\n\nconst iv = randomBytes(16);\nconst password = 'Password used to generate key';\n\n// The key length is dependent on the algorithm.\n// In this case for aes256, it is 32 bytes.\nconst key = (await promisify(scrypt)(password, 'salt', 32)) as Buffer;\nconst cipher = createCipheriv('aes-256-ctr', key, iv);\n\nconst textToEncrypt = 'Nest';\nconst encryptedText = Buffer.concat([\n  cipher.update(textToEncrypt),\n  cipher.final(),\n]);\n"),e.qZA()(),e.TgZ(31,"p"),e._uU(32,"Now to decrypt "),e.TgZ(33,"code"),e._uU(34,"encryptedText"),e.qZA(),e._uU(35," value:"),e.qZA(),e.TgZ(36,"pre")(37,"code",8),e._uU(38,"\nimport { createDecipheriv } from 'crypto';\n\nconst decipher = createDecipheriv('aes-256-ctr', key, iv);\nconst decryptedText = Buffer.concat([\n  decipher.update(encryptedText),\n  decipher.final(),\n]);\n"),e.qZA()(),e.TgZ(39,"h4",9)(40,"span"),e._uU(41,"Hashing"),e.qZA()(),e.TgZ(42,"p"),e._uU(43,"For hashing, we recommend using either the "),e.TgZ(44,"a",10),e._uU(45,"bcrypt"),e.qZA(),e._uU(46," or "),e.TgZ(47,"a",11),e._uU(48,"argon2"),e.qZA(),e._uU(49," packages. Nest itself does not provide any additional wrappers on top of these modules to avoid introducing unnecessary abstractions (making the learning curve short)."),e.qZA(),e.TgZ(50,"p"),e._uU(51,"As an example, let's use "),e.TgZ(52,"code"),e._uU(53,"bcrypt"),e.qZA(),e._uU(54," to hash a random password."),e.qZA(),e.TgZ(55,"p"),e._uU(56,"First install required packages:"),e.qZA(),e.TgZ(57,"pre")(58,"code",12),e._uU(59,"\n$ npm i bcrypt\n$ npm i -D @types/bcrypt\n"),e.qZA()(),e.TgZ(60,"p"),e._uU(61,"Once the installation is complete, you can use the "),e.TgZ(62,"code"),e._uU(63,"hash"),e.qZA(),e._uU(64," function, as follows:"),e.qZA(),e.TgZ(65,"pre")(66,"code",8),e._uU(67,"\nimport * as bcrypt from 'bcrypt';\n\nconst saltOrRounds = 10;\nconst password = 'random_password';\nconst hash = await bcrypt.hash(password, saltOrRounds);\n"),e.qZA()(),e.TgZ(68,"p"),e._uU(69,"To generate a salt, use the "),e.TgZ(70,"code"),e._uU(71,"genSalt"),e.qZA(),e._uU(72," function:"),e.qZA(),e.TgZ(73,"pre")(74,"code",8),e._uU(75,"\nconst salt = await bcrypt.genSalt();\n"),e.qZA()(),e.TgZ(76,"p"),e._uU(77,"To compare/check a password, use the "),e.TgZ(78,"code"),e._uU(79,"compare"),e.qZA(),e._uU(80," function:"),e.qZA(),e.TgZ(81,"pre")(82,"code",8),e._uU(83,"\nconst isMatch = await bcrypt.compare(password, hash);\n"),e.qZA()(),e.TgZ(84,"p"),e._uU(85,"You can read more about available functions "),e.TgZ(86,"a",10),e._uU(87,"here"),e.qZA(),e._uU(88,"."),e.qZA()())},dependencies:[i.U],encapsulation:2,changeDetection:0}),t})(),data:{title:"Encryption and Hashing"}},{path:"csrf",component:(()=>{class t extends a.y{}return t.\u0275fac=function(){let o;return function(s){return(o||(o=e.n5z(t)))(s||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-csrf"]],features:[e.qOj],decls:69,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/security/csrf.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","csrf-protection"],["rel","nofollow","target","_blank","href","https://github.com/expressjs/csurf"],["appAnchor","","id","use-with-express-default"],[1,"language-bash"],[1,"warning"],["rel","nofollow","target","_blank","href","https://github.com/expressjs/csurf#csurf"],[1,"language-typescript"],["appAnchor","","id","use-with-fastify"],["rel","nofollow","target","_blank","href","https://github.com/fastify/fastify-csrf#usage"]],template:function(n,s){1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"CSRF Protection"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"Cross-site request forgery (also known as CSRF or XSRF) is a type of malicious exploit of a website where "),e.TgZ(9,"strong"),e._uU(10,"unauthorized"),e.qZA(),e._uU(11," commands are transmitted from a user that the web application trusts. To mitigate this kind of attack you can use the "),e.TgZ(12,"a",6),e._uU(13,"csurf"),e.qZA(),e._uU(14," package."),e.qZA(),e.TgZ(15,"h4",7)(16,"span"),e._uU(17,"Use with Express (default)"),e.qZA()(),e.TgZ(18,"p"),e._uU(19,"Start by installing the required package:"),e.qZA(),e.TgZ(20,"pre")(21,"code",8),e._uU(22,"\n$ npm i --save csurf\n"),e.qZA()(),e.TgZ(23,"blockquote",9)(24,"strong"),e._uU(25,"Warning"),e.qZA(),e._uU(26," As explained in the "),e.TgZ(27,"a",10)(28,"code"),e._uU(29,"csurf"),e.qZA(),e._uU(30," docs"),e.qZA(),e._uU(31,", this middleware requires either session middleware or "),e.TgZ(32,"code"),e._uU(33,"cookie-parser"),e.qZA(),e._uU(34," to be initialized first. Please see that documentation for further instructions.\n"),e.qZA(),e.TgZ(35,"p"),e._uU(36,"Once the installation is complete, apply the "),e.TgZ(37,"code"),e._uU(38,"csurf"),e.qZA(),e._uU(39," middleware as global middleware."),e.qZA(),e.TgZ(40,"pre")(41,"code",11),e._uU(42,"\nimport * as csurf from 'csurf';\n// ...\n// somewhere in your initialization file\napp.use(csurf());\n"),e.qZA()(),e.TgZ(43,"h4",12)(44,"span"),e._uU(45,"Use with Fastify"),e.qZA()(),e.TgZ(46,"p"),e._uU(47,"Start by installing the required package:"),e.qZA(),e.TgZ(48,"pre")(49,"code",8),e._uU(50,"\n$ npm i --save fastify-csrf\n"),e.qZA()(),e.TgZ(51,"p"),e._uU(52,"Once the installation is complete, register the "),e.TgZ(53,"code"),e._uU(54,"fastify-csrf"),e.qZA(),e._uU(55," plugin, as follows:"),e.qZA(),e.TgZ(56,"pre")(57,"code",11),e._uU(58,"\nimport fastifyCsrf from 'fastify-csrf';\n// ...\n// somewhere in your initialization file after registering some storage plugin\nawait app.register(fastifyCsrf);\n"),e.qZA()(),e.TgZ(59,"blockquote",9)(60,"strong"),e._uU(61,"Warning"),e.qZA(),e._uU(62," As explained in the "),e.TgZ(63,"code"),e._uU(64,"fastify-csrf"),e.qZA(),e._uU(65," docs "),e.TgZ(66,"a",13),e._uU(67,"here"),e.qZA(),e._uU(68,", this plugin requires a storage plugin to be initialized first. Please, see that documentation for further instructions.\n"),e.qZA()())},dependencies:[i.U],encapsulation:2,changeDetection:0}),t})(),data:{title:"CSRF"}},{path:"rate-limiting",component:(()=>{class t extends a.y{}return t.\u0275fac=function(){let o;return function(s){return(o||(o=e.n5z(t)))(s||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-rate-limiting"]],features:[e.qOj],decls:263,vars:0,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/security/rate-limiting.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","rate-limiting"],[1,"language-bash"],[1,"language-typescript"],["rel","nofollow","target","_blank","href","https://docs.nestjs.com/guards"],["appAnchor","","id","customization"],["appAnchor","","id","proxies"],["rel","nofollow","target","_blank","href","http://expressjs.com/en/guide/behind-proxies.html"],["rel","nofollow","target","_blank","href","https://www.fastify.io/docs/latest/Reference/Server/#trustproxy"],[1,"info"],["rel","nofollow","target","_blank","href","https://expressjs.com/en/api.html#req.ips"],["rel","nofollow","target","_blank","href","https://www.fastify.io/docs/latest/Reference/Request/"],["appAnchor","","id","websockets"],["appAnchor","","id","graphql"],["appAnchor","","id","configuration"],["appAnchor","","id","async-configuration"],["appAnchor","","id","storages"],["rel","nofollow","target","_blank","href","https://github.com/kkoomen/nestjs-throttler-storage-redis"]],template:function(n,s){1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Rate Limiting"),e.qZA(),e.TgZ(7,"p"),e._uU(8,"A common technique to protect applications from brute-force attacks is "),e.TgZ(9,"strong"),e._uU(10,"rate-limiting"),e.qZA(),e._uU(11,". To get started, you'll need to install the "),e.TgZ(12,"code"),e._uU(13,"@nestjs/throttler"),e.qZA(),e._uU(14," package."),e.qZA(),e.TgZ(15,"pre")(16,"code",6),e._uU(17,"\n$ npm i --save @nestjs/throttler\n"),e.qZA()(),e.TgZ(18,"p"),e._uU(19,"Once the installation is complete, the "),e.TgZ(20,"code"),e._uU(21,"ThrottlerModule"),e.qZA(),e._uU(22," can be configured as any other Nest package with "),e.TgZ(23,"code"),e._uU(24,"forRoot"),e.qZA(),e._uU(25," or "),e.TgZ(26,"code"),e._uU(27,"forRootAsync"),e.qZA(),e._uU(28," methods."),e.qZA(),e.TgZ(29,"pre")(30,"code",7),e._uU(31,"\n@Module({\n  imports: [\n    ThrottlerModule.forRoot({\n      ttl: 60,\n      limit: 10,\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(32,"p"),e._uU(33,"The above will set the global options for the "),e.TgZ(34,"code"),e._uU(35,"ttl"),e.qZA(),e._uU(36,", the time to live, and the "),e.TgZ(37,"code"),e._uU(38,"limit"),e.qZA(),e._uU(39,", the maximum number of requests within the ttl, for the routes of your application that are guarded."),e.qZA(),e.TgZ(40,"p"),e._uU(41,"Once the module has been imported, you can then choose how you would like to bind the "),e.TgZ(42,"code"),e._uU(43,"ThrottlerGuard"),e.qZA(),e._uU(44,". Any kind of binding as mentioned in the "),e.TgZ(45,"a",8),e._uU(46,"guards"),e.qZA(),e._uU(47," section is fine. If you wanted to bind the guard globally, for example, you could do so by adding this provider to any module:"),e.qZA(),e.TgZ(48,"pre")(49,"code",7),e._uU(50,"\n{\n  provide: APP_GUARD,\n  useClass: ThrottlerGuard\n}\n"),e.qZA()(),e.TgZ(51,"h4",9)(52,"span"),e._uU(53,"Customization"),e.qZA()(),e.TgZ(54,"p"),e._uU(55,"There may be a time where you want to bind the guard to a controller or globally, but want to disable rate limiting for one or more of your endpoints. For that, you can use the "),e.TgZ(56,"code"),e._uU(57,"@SkipThrottle()"),e.qZA(),e._uU(58," decorator, to negate the throttler for an entire class or a single route. The "),e.TgZ(59,"code"),e._uU(60,"@SkipThrottle()"),e.qZA(),e._uU(61," decorator can also take in a boolean for if there is a case where you want to exclude "),e.TgZ(62,"em"),e._uU(63,"most"),e.qZA(),e._uU(64," of a controller, but not every route."),e.qZA(),e.TgZ(65,"pre")(66,"code",7),e._uU(67,"\n@SkipThrottle()\n@Controller('users')\nexport class UsersController {}\n"),e.qZA()(),e.TgZ(68,"p"),e._uU(69,"This "),e.TgZ(70,"code"),e._uU(71,"@SkipThrottle()"),e.qZA(),e._uU(72," decorator can be used to skip a route or a class or to negate the skipping of a route in a class that is skipped."),e.qZA(),e.TgZ(73,"pre")(74,"code",7),e._uU(75,'\n@SkipThrottle()\n@Controller(\'users\')\nexport class UsersController {\n  // Rate limiting is applied to this route.\n  @SkipThrottle(false)\n  dontSkip() {\n    return "List users work with Rate limiting.";\n  }\n  // This route will skip rate limiting.\n  doSkip() {\n    return "List users work without Rate limiting.";\n  }\n}\n'),e.qZA()(),e.TgZ(76,"p"),e._uU(77,"There is also the "),e.TgZ(78,"code"),e._uU(79,"@Throttle()"),e.qZA(),e._uU(80," decorator which can be used to override the "),e.TgZ(81,"code"),e._uU(82,"limit"),e.qZA(),e._uU(83," and "),e.TgZ(84,"code"),e._uU(85,"ttl"),e.qZA(),e._uU(86," set in the global module, to give tighter or looser security options. This decorator can be used on a class or a function as well. The order for this decorator does matter, as the arguments are in the order of "),e.TgZ(87,"code"),e._uU(88,"limit, ttl"),e.qZA(),e._uU(89,". You have to configure it like this:"),e.qZA(),e.TgZ(90,"pre")(91,"code",7),e._uU(92,'\n// Override default configuration for Rate limiting and duration.\n@Throttle(3, 60)\n@Get()\nfindAll() {\n  return "List users works with custom rate limiting.";\n}\n'),e.qZA()(),e.TgZ(93,"h4",10)(94,"span"),e._uU(95,"Proxies"),e.qZA()(),e.TgZ(96,"p"),e._uU(97,"If your application runs behind a proxy server, check the specific HTTP adapter options ("),e.TgZ(98,"a",11),e._uU(99,"express"),e.qZA(),e._uU(100," and "),e.TgZ(101,"a",12),e._uU(102,"fastify"),e.qZA(),e._uU(103,") for the "),e.TgZ(104,"code"),e._uU(105,"trust proxy"),e.qZA(),e._uU(106," option and enable it. Doing so will allow you to get the original IP address from the "),e.TgZ(107,"code"),e._uU(108,"X-Forwarded-For"),e.qZA(),e._uU(109," header, and you can override the "),e.TgZ(110,"code"),e._uU(111,"getTracker()"),e.qZA(),e._uU(112," method to pull the value from the header rather than from "),e.TgZ(113,"code"),e._uU(114,"req.ip"),e.qZA(),e._uU(115,". The following example works with both express and fastify:"),e.qZA(),e.TgZ(116,"pre")(117,"code",7),e._uU(118,"\n// throttler-behind-proxy.guard.ts\nimport { ThrottlerGuard } from '@nestjs/throttler';\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class ThrottlerBehindProxyGuard extends ThrottlerGuard {\n  protected getTracker(req: Record<string, any>): string {\n    return req.ips.length ? req.ips[0] : req.ip; // individualize IP extraction to meet your own needs\n  }\n}\n\n// app.controller.ts\nimport { ThrottlerBehindProxyGuard } from './throttler-behind-proxy.guard';\n\n@UseGuards(ThrottlerBehindProxyGuard)\n"),e.qZA()(),e.TgZ(119,"blockquote",13)(120,"strong"),e._uU(121,"Hint"),e.qZA(),e._uU(122," You can find the API of the "),e.TgZ(123,"code"),e._uU(124,"req"),e.qZA(),e._uU(125," Request object for express "),e.TgZ(126,"a",14),e._uU(127,"here"),e.qZA(),e._uU(128," and for fastify "),e.TgZ(129,"a",15),e._uU(130,"here"),e.qZA(),e._uU(131,".\n"),e.qZA(),e.TgZ(132,"h4",16)(133,"span"),e._uU(134,"Websockets"),e.qZA()(),e.TgZ(135,"p"),e._uU(136,"This module can work with websockets, but it requires some class extension. You can extend the "),e.TgZ(137,"code"),e._uU(138,"ThrottlerGuard"),e.qZA(),e._uU(139," and override the "),e.TgZ(140,"code"),e._uU(141,"handleRequest"),e.qZA(),e._uU(142," method like so:"),e.qZA(),e.TgZ(143,"pre")(144,"code",7),e._uU(145,"\n@Injectable()\nexport class WsThrottlerGuard extends ThrottlerGuard {\n  async handleRequest(\n    context: ExecutionContext,\n    limit: number,\n    ttl: number,\n  ): Promise<boolean> {\n    const client = context.switchToWs().getClient();\n    const ip = client.conn.remoteAddress;\n    const key = this.generateKey(context, ip);\n    const ttls = await this.storageService.getRecord(key);\n\n    if (ttls.length >= limit) {\n      throw new ThrottlerException();\n    }\n\n    await this.storageService.addRecord(key, ttl);\n    return true;\n  }\n}\n"),e.qZA()(),e.TgZ(146,"blockquote",13)(147,"strong"),e._uU(148,"Hint"),e.qZA(),e._uU(149," If you are using the "),e.TgZ(150,"code"),e._uU(151,"@nestjs/platform-ws"),e.qZA(),e._uU(152," package you can use "),e.TgZ(153,"code"),e._uU(154,"client._socket.remoteAddress"),e.qZA(),e._uU(155," instead.\n"),e.qZA(),e.TgZ(156,"h4",17)(157,"span"),e._uU(158,"GraphQL"),e.qZA()(),e.TgZ(159,"p"),e._uU(160,"The "),e.TgZ(161,"code"),e._uU(162,"ThrottlerGuard"),e.qZA(),e._uU(163," can also be used to work with GraphQL requests. Again, the guard can be extended, but this time the "),e.TgZ(164,"code"),e._uU(165,"getRequestResponse"),e.qZA(),e._uU(166," method will be overridden"),e.qZA(),e.TgZ(167,"pre")(168,"code",7),e._uU(169,"\n@Injectable()\nexport class GqlThrottlerGuard extends ThrottlerGuard {\n  getRequestResponse(context: ExecutionContext) {\n    const gqlCtx = GqlExecutionContext.create(context);\n    const ctx = gqlCtx.getContext();\n    return { req: ctx.req, res: ctx.res };\n  }\n}\n"),e.qZA()(),e.TgZ(170,"h4",18)(171,"span"),e._uU(172,"Configuration"),e.qZA()(),e.TgZ(173,"p"),e._uU(174,"The following options are valid for the "),e.TgZ(175,"code"),e._uU(176,"ThrottlerModule"),e.qZA(),e._uU(177,":"),e.qZA(),e.TgZ(178,"table")(179,"tr")(180,"td")(181,"code"),e._uU(182,"ttl"),e.qZA()(),e.TgZ(183,"td"),e._uU(184,"the number of seconds that each request will last in storage"),e.qZA()(),e.TgZ(185,"tr")(186,"td")(187,"code"),e._uU(188,"limit"),e.qZA()(),e.TgZ(189,"td"),e._uU(190,"the maximum number of requests within the TTL limit"),e.qZA()(),e.TgZ(191,"tr")(192,"td")(193,"code"),e._uU(194,"ignoreUserAgents"),e.qZA()(),e.TgZ(195,"td"),e._uU(196,"an array of regular expressions of user-agents to ignore when it comes to throttling requests"),e.qZA()(),e.TgZ(197,"tr")(198,"td")(199,"code"),e._uU(200,"storage"),e.qZA()(),e.TgZ(201,"td"),e._uU(202," the storage setting for how to keep track of the requests"),e.qZA()()(),e.TgZ(203,"h4",19)(204,"span"),e._uU(205,"Async Configuration"),e.qZA()(),e.TgZ(206,"p"),e._uU(207,"You may want to get your rate-limiting configuration asynchronously instead of synchronously. You can use the "),e.TgZ(208,"code"),e._uU(209,"forRootAsync()"),e.qZA(),e._uU(210," method, which allows for dependency injection and "),e.TgZ(211,"code"),e._uU(212,"async"),e.qZA(),e._uU(213," methods."),e.qZA(),e.TgZ(214,"p"),e._uU(215,"One approach would be to use a factory function:"),e.qZA(),e.TgZ(216,"pre")(217,"code",7),e._uU(218,"\n@Module({\n  imports: [\n    ThrottlerModule.forRootAsync({\n      imports: [ConfigModule],\n      inject: [ConfigService],\n      useFactory: (config: ConfigService) => ({\n        ttl: config.get('THROTTLE_TTL'),\n        limit: config.get('THROTTLE_LIMIT'),\n      }),\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(219,"p"),e._uU(220,"You can also use the "),e.TgZ(221,"code"),e._uU(222,"useClass"),e.qZA(),e._uU(223," syntax:"),e.qZA(),e.TgZ(224,"pre")(225,"code",7),e._uU(226,"\n@Module({\n  imports: [\n    ThrottlerModule.forRootAsync({\n      imports: [ConfigModule],\n      useClass: ThrottlerConfigService,\n    }),\n  ],\n})\nexport class AppModule {}\n"),e.qZA()(),e.TgZ(227,"p"),e._uU(228,"This is doable, as long as "),e.TgZ(229,"code"),e._uU(230,"ThrottlerConfigService"),e.qZA(),e._uU(231," implements the interface "),e.TgZ(232,"code"),e._uU(233,"ThrottlerOptionsFactory"),e.qZA(),e._uU(234,"."),e.qZA(),e.TgZ(235,"h4",20)(236,"span"),e._uU(237,"Storages"),e.qZA()(),e.TgZ(238,"p"),e._uU(239,"The built in storage is an in memory cache that keeps track of the requests made until they have passed the TTL set by the global options. You can drop in your own storage option to the "),e.TgZ(240,"code"),e._uU(241,"storage"),e.qZA(),e._uU(242," option of the "),e.TgZ(243,"code"),e._uU(244,"ThrottlerModule"),e.qZA(),e._uU(245," so long as the class implements the "),e.TgZ(246,"code"),e._uU(247,"ThrottlerStorage"),e.qZA(),e._uU(248," interface."),e.qZA(),e.TgZ(249,"p"),e._uU(250,"For distributed servers you could use the community storage provider for "),e.TgZ(251,"a",21),e._uU(252,"Redis"),e.qZA(),e._uU(253," to have a single source of truth."),e.qZA(),e.TgZ(254,"blockquote",13)(255,"strong"),e._uU(256,"Note"),e.qZA(),e.TgZ(257,"code"),e._uU(258,"ThrottlerStorage"),e.qZA(),e._uU(259," can be imported from "),e.TgZ(260,"code"),e._uU(261,"@nestjs/throttler"),e.qZA(),e._uU(262,".\n"),e.qZA()())},dependencies:[i.U],encapsulation:2,changeDetection:0}),t})(),data:{title:"Rate Limiting"}},{path:"authorization",component:(()=>{class t extends a.y{}return t.\u0275fac=function(){let o;return function(s){return(o||(o=e.n5z(t)))(s||t)}}(),t.\u0275cmp=e.Xpm({type:t,selectors:[["app-authorization"]],features:[e.qOj],decls:579,vars:36,consts:[[1,"content"],["contentReference",""],[1,"github-links"],["href","https://github.com/nestjs/docs.nestjs.com/edit/master/content/security/authorization.md","aria-label","Suggest Edits","title","Suggest Edits"],[1,"fas","fa-edit"],["id","authorization"],["appAnchor","","id","basic-rbac-implementation"],["routerLink","/guards"],[1,"filename"],["app0f4276494cb168fd1debf8bf7b6d18c089aacf11",""],[1,"language-typescript"],[1,"info"],["app8494af6ed75a7191653b8baff6bc1d631c43dc1a",""],["app0fdecf6f1839b0b3cddcb91d4c845d424f5a1892",""],["app34a7c644da565d573c89f02d47864dbb9296efd2",""],["href","/fundamentals/execution-context#reflection-and-metadata"],[1,"warning"],["routerLink","/security/authentication"],["appAnchor","","id","claims-based-authorization"],["href","/security/authorization#basic-rbac-implementation"],["appad93d7a481317bea5140e255a0766201e43b2b21",""],["appAnchor","","id","integrating-casl"],["rel","nofollow","target","_blank","href","https://casl.js.org/"],[1,"language-bash"],["rel","nofollow","target","_blank","href","https://casl.js.org/v5/en/guide/subject-type-detection#use-classes-as-subject-types"],["rel","nofollow","target","_blank","href","https://casl.js.org/v5/en/guide/intro"],["appAnchor","","id","advanced-implementing-a-policiesguard"],["routerLink","/fundamentals/module-ref"]],template:function(n,s){if(1&n&&(e.TgZ(0,"div",0,1)(2,"div",2)(3,"a",3),e._UZ(4,"i",4),e.qZA()(),e.TgZ(5,"h3",5),e._uU(6,"Authorization"),e.qZA(),e.TgZ(7,"p")(8,"strong"),e._uU(9,"Authorization"),e.qZA(),e._uU(10," refers to the process that determines what a user is able to do. For example, an administrative user is allowed to create, edit, and delete posts. A non-administrative user is only authorized to read the posts."),e.qZA(),e.TgZ(11,"p"),e._uU(12,"Authorization is orthogonal and independent from authentication. However, authorization requires an authentication mechanism."),e.qZA(),e.TgZ(13,"p"),e._uU(14,"There are many different approaches and strategies to handle authorization. The approach taken for any project depends on its particular application requirements. This chapter presents a few approaches to authorization that can be adapted to a variety of different requirements."),e.qZA(),e.TgZ(15,"h4",6)(16,"span"),e._uU(17,"Basic RBAC implementation"),e.qZA()(),e.TgZ(18,"p"),e._uU(19,"Role-based access control ("),e.TgZ(20,"strong"),e._uU(21,"RBAC"),e.qZA(),e._uU(22,") is a policy-neutral access-control mechanism defined around roles and privileges. In this section, we'll demonstrate how to implement a very basic RBAC mechanism using Nest "),e.TgZ(23,"a",7),e._uU(24,"guards"),e.qZA(),e._uU(25,"."),e.qZA(),e.TgZ(26,"p"),e._uU(27,"First, let's create a "),e.TgZ(28,"code"),e._uU(29,"Role"),e.qZA(),e._uU(30," enum representing roles in the system:"),e.qZA(),e.TgZ(31,"span",8),e._uU(32),e.ALo(33,"extension"),e._UZ(34,"app-tabs",null,9),e.qZA(),e.TgZ(36,"pre")(37,"code",10),e._uU(38,"\nexport enum Role {\n  User = 'user',\n  Admin = 'admin',\n}\n"),e.qZA()(),e.TgZ(39,"blockquote",11)(40,"strong"),e._uU(41,"Hint"),e.qZA(),e._uU(42," In more sophisticated systems, you may store roles within a database, or pull them from the external authentication provider.\n"),e.qZA(),e.TgZ(43,"p"),e._uU(44,"With this in place, we can create a "),e.TgZ(45,"code"),e._uU(46,"@Roles()"),e.qZA(),e._uU(47," decorator. This decorator allows specifying what roles are required to access specific resources."),e.qZA(),e.TgZ(48,"span",8),e._uU(49),e.ALo(50,"extension"),e._UZ(51,"app-tabs",null,12),e.qZA(),e.TgZ(53,"pre")(54,"code",10),e._uU(55,"\nimport { SetMetadata } from '@nestjs/common';\nimport { Role } from '../enums/role.enum';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);\n"),e.qZA()(),e.TgZ(56,"pre")(57,"code",10),e._uU(58,"\nimport { SetMetadata } from '@nestjs/common';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles) => SetMetadata(ROLES_KEY, roles);\n"),e.qZA()(),e.TgZ(59,"p"),e._uU(60,"Now that we have a custom "),e.TgZ(61,"code"),e._uU(62,"@Roles()"),e.qZA(),e._uU(63," decorator, we can use it to decorate any route handler."),e.qZA(),e.TgZ(64,"span",8),e._uU(65),e.ALo(66,"extension"),e._UZ(67,"app-tabs",null,13),e.qZA(),e.TgZ(69,"pre")(70,"code",10),e._uU(71,"\n@Post()\n@Roles(Role.Admin)\ncreate(@Body() createCatDto: CreateCatDto) {\n  this.catsService.create(createCatDto);\n}\n"),e.qZA()(),e.TgZ(72,"pre")(73,"code",10),e._uU(74,"\n@Post()\n@Roles(Role.Admin)\n@Bind(Body())\ncreate(createCatDto) {\n  this.catsService.create(createCatDto);\n}\n"),e.qZA()(),e.TgZ(75,"p"),e._uU(76,"Finally, we create a "),e.TgZ(77,"code"),e._uU(78,"RolesGuard"),e.qZA(),e._uU(79," class which will compare the roles assigned to the current user to the actual roles required by the current route being processed. In order to access the route's role(s) (custom metadata), we'll use the "),e.TgZ(80,"code"),e._uU(81,"Reflector"),e.qZA(),e._uU(82," helper class, which is provided out of the box by the framework and exposed from the "),e.TgZ(83,"code"),e._uU(84,"@nestjs/core"),e.qZA(),e._uU(85," package."),e.qZA(),e.TgZ(86,"span",8),e._uU(87),e.ALo(88,"extension"),e._UZ(89,"app-tabs",null,14),e.qZA(),e.TgZ(91,"pre")(92,"code",10),e._uU(93,"\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (!requiredRoles) {\n      return true;\n    }\n    const { user } = context.switchToHttp().getRequest();\n    return requiredRoles.some((role) => user.roles?.includes(role));\n  }\n}\n"),e.qZA()(),e.TgZ(94,"pre")(95,"code",10),e._uU(96,"\nimport { Injectable, Dependencies } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\n\n@Injectable()\n@Dependencies(Reflector)\nexport class RolesGuard {\n  constructor(reflector) {\n    this.reflector = reflector;\n  }\n\n  canActivate(context) {\n    const requiredRoles = this.reflector.getAllAndOverride(ROLES_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (!requiredRoles) {\n      return true;\n    }\n    const { user } = context.switchToHttp().getRequest();\n    return requiredRoles.some((role) => user.roles.includes(role));\n  }\n}\n"),e.qZA()(),e.TgZ(97,"blockquote",11)(98,"strong"),e._uU(99,"Hint"),e.qZA(),e._uU(100," Refer to the "),e.TgZ(101,"a",15),e._uU(102,"Reflection and metadata"),e.qZA(),e._uU(103," section of the Execution context chapter for more details on utilizing "),e.TgZ(104,"code"),e._uU(105,"Reflector"),e.qZA(),e._uU(106," in a context-sensitive way.\n"),e.qZA(),e.TgZ(107,"blockquote",16)(108,"strong"),e._uU(109,"Notice"),e.qZA(),e._uU(110,' This example is named "'),e.TgZ(111,"strong"),e._uU(112,"basic"),e.qZA(),e._uU(113,"\" as we only check for the presence of roles on the route handler level. In real-world applications, you may have endpoints/handlers that involve several operations, in which each of them requires a specific set of permissions. In this case, you'll have to provide a mechanism to check roles somewhere within your business-logic, making it somewhat harder to maintain as there will be no centralized place that associates permissions with specific actions.\n"),e.qZA(),e.TgZ(114,"p"),e._uU(115,"In this example, we assumed that "),e.TgZ(116,"code"),e._uU(117,"request.user"),e.qZA(),e._uU(118," contains the user instance and allowed roles (under the "),e.TgZ(119,"code"),e._uU(120,"roles"),e.qZA(),e._uU(121," property). In your app, you will probably make that association in your custom "),e.TgZ(122,"strong"),e._uU(123,"authentication guard"),e.qZA(),e._uU(124," - see "),e.TgZ(125,"a",17),e._uU(126,"authentication"),e.qZA(),e._uU(127," chapter for more details."),e.qZA(),e.TgZ(128,"p"),e._uU(129,"To make sure this example works, your "),e.TgZ(130,"code"),e._uU(131,"User"),e.qZA(),e._uU(132," class must look as follows:"),e.qZA(),e.TgZ(133,"pre")(134,"code",10),e._uU(135,"\nclass User {\n  // ...other properties\n  roles: Role[];\n}\n"),e.qZA()(),e.TgZ(136,"p"),e._uU(137,"Lastly, make sure to register the "),e.TgZ(138,"code"),e._uU(139,"RolesGuard"),e.qZA(),e._uU(140,", for example, at the controller level, or globally:"),e.qZA(),e.TgZ(141,"pre")(142,"code",10),e._uU(143,"\nproviders: [\n  {\n    provide: APP_GUARD,\n    useClass: RolesGuard,\n  },\n],\n"),e.qZA()(),e.TgZ(144,"p"),e._uU(145,"When a user with insufficient privileges requests an endpoint, Nest automatically returns the following response:"),e.qZA(),e.TgZ(146,"pre")(147,"code",10),e._uU(148,'\n{\n  "statusCode": 403,\n  "message": "Forbidden resource",\n  "error": "Forbidden"\n}\n'),e.qZA()(),e.TgZ(149,"blockquote",11)(150,"strong"),e._uU(151,"Hint"),e.qZA(),e._uU(152," If you want to return a different error response, you should throw your own specific exception instead of returning a boolean value.\n"),e.qZA(),e.TgZ(153,"h4",18)(154,"span"),e._uU(155,"Claims-based authorization"),e.qZA()(),e.TgZ(156,"p"),e._uU(157,"When an identity is created it may be assigned one or more claims issued by a trusted party. A claim is a name-value pair that represents what the subject can do, not what the subject is."),e.qZA(),e.TgZ(158,"p"),e._uU(159,"To implement a Claims-based authorization in Nest, you can follow the same steps we have shown above in the "),e.TgZ(160,"a",19),e._uU(161,"RBAC"),e.qZA(),e._uU(162," section with one significant difference: instead of checking for specific roles, you should compare "),e.TgZ(163,"strong"),e._uU(164,"permissions"),e.qZA(),e._uU(165,". Every user would have a set of permissions assigned. Likewise, each resource/endpoint would define what permissions are required (for example, through a dedicated "),e.TgZ(166,"code"),e._uU(167,"@RequirePermissions()"),e.qZA(),e._uU(168," decorator) to access them."),e.qZA(),e.TgZ(169,"span",8),e._uU(170),e.ALo(171,"extension"),e._UZ(172,"app-tabs",null,20),e.qZA(),e.TgZ(174,"pre")(175,"code",10),e._uU(176,"\n@Post()\n@RequirePermissions(Permission.CREATE_CAT)\ncreate(@Body() createCatDto: CreateCatDto) {\n  this.catsService.create(createCatDto);\n}\n"),e.qZA()(),e.TgZ(177,"pre")(178,"code",10),e._uU(179,"\n@Post()\n@RequirePermissions(Permission.CREATE_CAT)\n@Bind(Body())\ncreate(createCatDto) {\n  this.catsService.create(createCatDto);\n}\n"),e.qZA()(),e.TgZ(180,"blockquote",11)(181,"strong"),e._uU(182,"Hint"),e.qZA(),e._uU(183," In the example above, "),e.TgZ(184,"code"),e._uU(185,"Permission"),e.qZA(),e._uU(186," (similar to "),e.TgZ(187,"code"),e._uU(188,"Role"),e.qZA(),e._uU(189," we have shown in RBAC section) is a TypeScript enum that contains all the permissions available in your system.\n"),e.qZA(),e.TgZ(190,"h4",21)(191,"span"),e._uU(192,"Integrating CASL"),e.qZA()(),e.TgZ(193,"p")(194,"a",22),e._uU(195,"CASL"),e.qZA(),e._uU(196," is an isomorphic authorization library which restricts what resources a given client is allowed to access. It's designed to be incrementally adoptable and can easily scale between a simple claim based and fully featured subject and attribute based authorization."),e.qZA(),e.TgZ(197,"p"),e._uU(198,"To start, first install the "),e.TgZ(199,"code"),e._uU(200,"@casl/ability"),e.qZA(),e._uU(201," package:"),e.qZA(),e.TgZ(202,"pre")(203,"code",23),e._uU(204,"\n$ npm i @casl/ability\n"),e.qZA()(),e.TgZ(205,"blockquote",11)(206,"strong"),e._uU(207,"Hint"),e.qZA(),e._uU(208," In this example, we chose CASL, but you can use any other library like "),e.TgZ(209,"code"),e._uU(210,"accesscontrol"),e.qZA(),e._uU(211," or "),e.TgZ(212,"code"),e._uU(213,"acl"),e.qZA(),e._uU(214,", depending on your preferences and project needs.\n"),e.qZA(),e.TgZ(215,"p"),e._uU(216,"Once the installation is complete, for the sake of illustrating the mechanics of CASL, we'll define two entity classes: "),e.TgZ(217,"code"),e._uU(218,"User"),e.qZA(),e._uU(219," and "),e.TgZ(220,"code"),e._uU(221,"Article"),e.qZA(),e._uU(222,"."),e.qZA(),e.TgZ(223,"pre")(224,"code",10),e._uU(225,"\nclass User {\n  id: number;\n  isAdmin: boolean;\n}\n"),e.qZA()(),e.TgZ(226,"p")(227,"code"),e._uU(228,"User"),e.qZA(),e._uU(229," class consists of two properties, "),e.TgZ(230,"code"),e._uU(231,"id"),e.qZA(),e._uU(232,", which is a unique user identifier, and "),e.TgZ(233,"code"),e._uU(234,"isAdmin"),e.qZA(),e._uU(235,", indicating whether a user has administrator privileges."),e.qZA(),e.TgZ(236,"pre")(237,"code",10),e._uU(238,"\nclass Article {\n  id: number;\n  isPublished: boolean;\n  authorId: number;\n}\n"),e.qZA()(),e.TgZ(239,"p")(240,"code"),e._uU(241,"Article"),e.qZA(),e._uU(242," class has three properties, respectively "),e.TgZ(243,"code"),e._uU(244,"id"),e.qZA(),e._uU(245,", "),e.TgZ(246,"code"),e._uU(247,"isPublished"),e.qZA(),e._uU(248,", and "),e.TgZ(249,"code"),e._uU(250,"authorId"),e.qZA(),e._uU(251,". "),e.TgZ(252,"code"),e._uU(253,"id"),e.qZA(),e._uU(254," is a unique article identifier, "),e.TgZ(255,"code"),e._uU(256,"isPublished"),e.qZA(),e._uU(257," indicates whether an article was already published or not, and "),e.TgZ(258,"code"),e._uU(259,"authorId"),e.qZA(),e._uU(260,", which is an ID of a user who wrote the article."),e.qZA(),e.TgZ(261,"p"),e._uU(262,"Now let's review and refine our requirements for this example:"),e.qZA(),e.TgZ(263,"ul")(264,"li"),e._uU(265,"Admins can manage (create/read/update/delete) all entities"),e.qZA(),e.TgZ(266,"li"),e._uU(267,"Users have read-only access to everything"),e.qZA(),e.TgZ(268,"li"),e._uU(269,"Users can update their articles ("),e.TgZ(270,"code"),e._uU(271,"article.authorId === userId"),e.qZA(),e._uU(272,")"),e.qZA(),e.TgZ(273,"li"),e._uU(274,"Articles that are published already cannot be removed ("),e.TgZ(275,"code"),e._uU(276,"article.isPublished === true"),e.qZA(),e._uU(277,")"),e.qZA()(),e.TgZ(278,"p"),e._uU(279,"With this in mind, we can start off by creating an "),e.TgZ(280,"code"),e._uU(281,"Action"),e.qZA(),e._uU(282," enum representing all possible actions that the users can perform with entities:"),e.qZA(),e.TgZ(283,"pre")(284,"code",10),e._uU(285,"\nexport enum Action {\n  Manage = 'manage',\n  Create = 'create',\n  Read = 'read',\n  Update = 'update',\n  Delete = 'delete',\n}\n"),e.qZA()(),e.TgZ(286,"blockquote",16)(287,"strong"),e._uU(288,"Notice"),e.qZA(),e.TgZ(289,"code"),e._uU(290,"manage"),e.qZA(),e._uU(291,' is a special keyword in CASL which represents "any" action.\n'),e.qZA(),e.TgZ(292,"p"),e._uU(293,"To encapsulate CASL library, let's generate the "),e.TgZ(294,"code"),e._uU(295,"CaslModule"),e.qZA(),e._uU(296," and "),e.TgZ(297,"code"),e._uU(298,"CaslAbilityFactory"),e.qZA(),e._uU(299," now."),e.qZA(),e.TgZ(300,"pre")(301,"code",23),e._uU(302,"\n$ nest g module casl\n$ nest g class casl/casl-ability.factory\n"),e.qZA()(),e.TgZ(303,"p"),e._uU(304,"With this in place, we can define the "),e.TgZ(305,"code"),e._uU(306,"createForUser()"),e.qZA(),e._uU(307," method on the "),e.TgZ(308,"code"),e._uU(309,"CaslAbilityFactory"),e.qZA(),e._uU(310,". This method will create the "),e.TgZ(311,"code"),e._uU(312,"Ability"),e.qZA(),e._uU(313," object for a given user:"),e.qZA(),e.TgZ(314,"pre")(315,"code",10),e._uU(316,"\ntype Subjects = InferSubjects<typeof Article | typeof User> | 'all';\n\nexport type AppAbility = Ability<[Action, Subjects]>;\n\n@Injectable()\nexport class CaslAbilityFactory {\n  createForUser(user: User) {\n    const { can, cannot, build } = new AbilityBuilder<\n      Ability<[Action, Subjects]>\n    >(Ability as AbilityClass<AppAbility>);\n\n    if (user.isAdmin) {\n      can(Action.Manage, 'all'); // read-write access to everything\n    } else {\n      can(Action.Read, 'all'); // read-only access to everything\n    }\n\n    can(Action.Update, Article, { authorId: user.id });\n    cannot(Action.Delete, Article, { isPublished: true });\n\n    return build({\n      // Read https://casl.js.org/v5/en/guide/subject-type-detection#use-classes-as-subject-types for details\n      detectSubjectType: (item) =>\n        item.constructor as ExtractSubjectType<Subjects>,\n    });\n  }\n}\n"),e.qZA()(),e.TgZ(317,"blockquote",16)(318,"strong"),e._uU(319,"Notice"),e.qZA(),e.TgZ(320,"code"),e._uU(321,"all"),e.qZA(),e._uU(322,' is a special keyword in CASL that represents "any subject".\n'),e.qZA(),e.TgZ(323,"blockquote",11)(324,"strong"),e._uU(325,"Hint"),e.qZA(),e.TgZ(326,"code"),e._uU(327,"Ability"),e.qZA(),e._uU(328,", "),e.TgZ(329,"code"),e._uU(330,"AbilityBuilder"),e.qZA(),e._uU(331,", "),e.TgZ(332,"code"),e._uU(333,"AbilityClass"),e.qZA(),e._uU(334,", and "),e.TgZ(335,"code"),e._uU(336,"ExtractSubjectType"),e.qZA(),e._uU(337," classes are exported from the "),e.TgZ(338,"code"),e._uU(339,"@casl/ability"),e.qZA(),e._uU(340," package.\n"),e.qZA(),e.TgZ(341,"blockquote",11)(342,"strong"),e._uU(343,"Hint"),e.qZA(),e.TgZ(344,"code"),e._uU(345,"detectSubjectType"),e.qZA(),e._uU(346," option let CASL understand how to get subject type out of an object. For more information read "),e.TgZ(347,"a",24),e._uU(348,"CASL documentation"),e.qZA(),e._uU(349," for details.\n"),e.qZA(),e.TgZ(350,"p"),e._uU(351,"In the example above, we created the "),e.TgZ(352,"code"),e._uU(353,"Ability"),e.qZA(),e._uU(354," instance using the "),e.TgZ(355,"code"),e._uU(356,"AbilityBuilder"),e.qZA(),e._uU(357," class. As you probably guessed, "),e.TgZ(358,"code"),e._uU(359,"can"),e.qZA(),e._uU(360," and "),e.TgZ(361,"code"),e._uU(362,"cannot"),e.qZA(),e._uU(363," accept the same arguments but has different meanings, "),e.TgZ(364,"code"),e._uU(365,"can"),e.qZA(),e._uU(366," allows to do an action on the specified subject and "),e.TgZ(367,"code"),e._uU(368,"cannot"),e.qZA(),e._uU(369," forbids. Both may accept up to 4 arguments. To learn more about these functions, visit the official "),e.TgZ(370,"a",25),e._uU(371,"CASL documentation"),e.qZA(),e._uU(372,"."),e.qZA(),e.TgZ(373,"p"),e._uU(374,"Lastly, make sure to add the "),e.TgZ(375,"code"),e._uU(376,"CaslAbilityFactory"),e.qZA(),e._uU(377," to the "),e.TgZ(378,"code"),e._uU(379,"providers"),e.qZA(),e._uU(380," and "),e.TgZ(381,"code"),e._uU(382,"exports"),e.qZA(),e._uU(383," arrays in the "),e.TgZ(384,"code"),e._uU(385,"CaslModule"),e.qZA(),e._uU(386," module definition:"),e.qZA(),e.TgZ(387,"pre")(388,"code",10),e._uU(389,"\nimport { Module } from '@nestjs/common';\nimport { CaslAbilityFactory } from './casl-ability.factory';\n\n@Module({\n  providers: [CaslAbilityFactory],\n  exports: [CaslAbilityFactory],\n})\nexport class CaslModule {}\n"),e.qZA()(),e.TgZ(390,"p"),e._uU(391,"With this in place, we can inject the "),e.TgZ(392,"code"),e._uU(393,"CaslAbilityFactory"),e.qZA(),e._uU(394," to any class using standard constructor injection as long as the "),e.TgZ(395,"code"),e._uU(396,"CaslModule"),e.qZA(),e._uU(397," is imported in the host context:"),e.qZA(),e.TgZ(398,"pre")(399,"code",10),e._uU(400,"\nconstructor(private caslAbilityFactory: CaslAbilityFactory) {}\n"),e.qZA()(),e.TgZ(401,"p"),e._uU(402,"Then use it in a class as follows."),e.qZA(),e.TgZ(403,"pre")(404,"code",10),e._uU(405,"\nconst ability = this.caslAbilityFactory.createForUser(user);\nif (ability.can(Action.Read, 'all')) {\n  // \"user\" has read access to everything\n}\n"),e.qZA()(),e.TgZ(406,"blockquote",11)(407,"strong"),e._uU(408,"Hint"),e.qZA(),e._uU(409," Learn more about the "),e.TgZ(410,"code"),e._uU(411,"Ability"),e.qZA(),e._uU(412," class in the official "),e.TgZ(413,"a",25),e._uU(414,"CASL documentation"),e.qZA(),e._uU(415,".\n"),e.qZA(),e.TgZ(416,"p"),e._uU(417,"For example, let's say we have a user who is not an admin. In this case, the user should be able to read articles, but creating new ones or removing the existing articles should be prohibited."),e.qZA(),e.TgZ(418,"pre")(419,"code",10),e._uU(420,"\nconst user = new User();\nuser.isAdmin = false;\n\nconst ability = this.caslAbilityFactory.createForUser(user);\nability.can(Action.Read, Article); // true\nability.can(Action.Delete, Article); // false\nability.can(Action.Create, Article); // false\n"),e.qZA()(),e.TgZ(421,"blockquote",11)(422,"strong"),e._uU(423,"Hint"),e.qZA(),e._uU(424," Although both "),e.TgZ(425,"code"),e._uU(426,"Ability"),e.qZA(),e._uU(427," and "),e.TgZ(428,"code"),e._uU(429,"AbilityBuilder"),e.qZA(),e._uU(430," classes provide "),e.TgZ(431,"code"),e._uU(432,"can"),e.qZA(),e._uU(433," and "),e.TgZ(434,"code"),e._uU(435,"cannot"),e.qZA(),e._uU(436," methods, they have different purposes and accept slightly different arguments.\n"),e.qZA(),e.TgZ(437,"p"),e._uU(438,"Also, as we have specified in our requirements, the user should be able to update its articles:"),e.qZA(),e.TgZ(439,"pre")(440,"code",10),e._uU(441,"\nconst user = new User();\nuser.id = 1;\n\nconst article = new Article();\narticle.authorId = user.id;\n\nconst ability = this.caslAbilityFactory.createForUser(user);\nability.can(Action.Update, article); // true\n\narticle.authorId = 2;\nability.can(Action.Update, article); // false\n"),e.qZA()(),e.TgZ(442,"p"),e._uU(443,"As you can see, "),e.TgZ(444,"code"),e._uU(445,"Ability"),e.qZA(),e._uU(446," instance allows us to check permissions in pretty readable way. Likewise, "),e.TgZ(447,"code"),e._uU(448,"AbilityBuilder"),e.qZA(),e._uU(449," allows us to define permissions (and specify various conditions) in a similar fashion. To find more examples, visit the official documentation."),e.qZA(),e.TgZ(450,"h4",26)(451,"span"),e._uU(452,"Advanced: Implementing a "),e.TgZ(453,"code"),e._uU(454,"PoliciesGuard"),e.qZA()()(),e.TgZ(455,"p"),e._uU(456,"In this section, we'll demonstrate how to build a somewhat more sophisticated guard, which checks if a user meets specific "),e.TgZ(457,"strong"),e._uU(458,"authorization policies"),e.qZA(),e._uU(459," that can be configured on the method-level (you can extend it to respect policies configured on the class-level too). In this example, we are going to use the CASL package just for illustration purposes, but using this library is not required. Also, we will use the "),e.TgZ(460,"code"),e._uU(461,"CaslAbilityFactory"),e.qZA(),e._uU(462," provider that we've created in the previous section."),e.qZA(),e.TgZ(463,"p"),e._uU(464,"First, let's flesh out the requirements. The goal is to provide a mechanism that allows specifying policy checks per route handler. We will support both objects and functions (for simpler checks and for those who prefer more functional-style code)."),e.qZA(),e.TgZ(465,"p"),e._uU(466,"Let's start off by defining interfaces for policy handlers:"),e.qZA(),e.TgZ(467,"pre")(468,"code",10),e._uU(469,"\nimport { AppAbility } from '../casl/casl-ability.factory';\n\ninterface IPolicyHandler {\n  handle(ability: AppAbility): boolean;\n}\n\ntype PolicyHandlerCallback = (ability: AppAbility) => boolean;\n\nexport type PolicyHandler = IPolicyHandler | PolicyHandlerCallback;\n"),e.qZA()(),e.TgZ(470,"p"),e._uU(471,"As mentioned above, we provided two possible ways of defining a policy handler, an object (instance of a class that implements the "),e.TgZ(472,"code"),e._uU(473,"IPolicyHandler"),e.qZA(),e._uU(474," interface) and a function (which meets the "),e.TgZ(475,"code"),e._uU(476,"PolicyHandlerCallback"),e.qZA(),e._uU(477," type)."),e.qZA(),e.TgZ(478,"p"),e._uU(479,"With this in place, we can create a "),e.TgZ(480,"code"),e._uU(481,"@CheckPolicies()"),e.qZA(),e._uU(482," decorator. This decorator allows specifying what policies have to be met to access specific resources."),e.qZA(),e.TgZ(483,"pre")(484,"code",10),e._uU(485,"\nexport const CHECK_POLICIES_KEY = 'check_policy';\nexport const CheckPolicies = (...handlers: PolicyHandler[]) =>\n  SetMetadata(CHECK_POLICIES_KEY, handlers);\n"),e.qZA()(),e.TgZ(486,"p"),e._uU(487,"Now let's create a "),e.TgZ(488,"code"),e._uU(489,"PoliciesGuard"),e.qZA(),e._uU(490," that will extract and execute all the policy handlers bound to a route handler."),e.qZA(),e.TgZ(491,"pre")(492,"code",10),e._uU(493,"\n@Injectable()\nexport class PoliciesGuard implements CanActivate {\n  constructor(\n    private reflector: Reflector,\n    private caslAbilityFactory: CaslAbilityFactory,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const policyHandlers =\n      this.reflector.get<PolicyHandler[]>(\n        CHECK_POLICIES_KEY,\n        context.getHandler(),\n      ) || [];\n\n    const { user } = context.switchToHttp().getRequest();\n    const ability = this.caslAbilityFactory.createForUser(user);\n\n    return policyHandlers.every((handler) =>\n      this.execPolicyHandler(handler, ability),\n    );\n  }\n\n  private execPolicyHandler(handler: PolicyHandler, ability: AppAbility) {\n    if (typeof handler === 'function') {\n      return handler(ability);\n    }\n    return handler.handle(ability);\n  }\n}\n"),e.qZA()(),e.TgZ(494,"blockquote",11)(495,"strong"),e._uU(496,"Hint"),e.qZA(),e._uU(497," In this example, we assumed that "),e.TgZ(498,"code"),e._uU(499,"request.user"),e.qZA(),e._uU(500," contains the user instance. In your app, you will probably make that association in your custom "),e.TgZ(501,"strong"),e._uU(502,"authentication guard"),e.qZA(),e._uU(503," - see "),e.TgZ(504,"a",17),e._uU(505,"authentication"),e.qZA(),e._uU(506," chapter for more details.\n"),e.qZA(),e.TgZ(507,"p"),e._uU(508,"Let's break this example down. The "),e.TgZ(509,"code"),e._uU(510,"policyHandlers"),e.qZA(),e._uU(511," is an array of handlers assigned to the method through the "),e.TgZ(512,"code"),e._uU(513,"@CheckPolicies()"),e.qZA(),e._uU(514," decorator. Next, we use the "),e.TgZ(515,"code"),e._uU(516,"CaslAbilityFactory#create"),e.qZA(),e._uU(517," method which constructs the "),e.TgZ(518,"code"),e._uU(519,"Ability"),e.qZA(),e._uU(520," object, allowing us to verify whether a user has sufficient permissions to perform specific actions. We are passing this object to the policy handler which is either a function or an instance of a class that implements the "),e.TgZ(521,"code"),e._uU(522,"IPolicyHandler"),e.qZA(),e._uU(523,", exposing the "),e.TgZ(524,"code"),e._uU(525,"handle()"),e.qZA(),e._uU(526," method that returns a boolean. Lastly, we use the "),e.TgZ(527,"code"),e._uU(528,"Array#every"),e.qZA(),e._uU(529," method to make sure that every handler returned "),e.TgZ(530,"code"),e._uU(531,"true"),e.qZA(),e._uU(532," value."),e.qZA(),e.TgZ(533,"p"),e._uU(534,"Finally, to test this guard, bind it to any route handler, and register an inline policy handler (functional approach), as follows:"),e.qZA(),e.TgZ(535,"pre")(536,"code",10),e._uU(537,"\n@Get()\n@UseGuards(PoliciesGuard)\n@CheckPolicies((ability: AppAbility) => ability.can(Action.Read, Article))\nfindAll() {\n  return this.articlesService.findAll();\n}\n"),e.qZA()(),e.TgZ(538,"p"),e._uU(539,"Alternatively, we can define a class which implements the "),e.TgZ(540,"code"),e._uU(541,"IPolicyHandler"),e.qZA(),e._uU(542," interface:"),e.qZA(),e.TgZ(543,"pre")(544,"code",10),e._uU(545,"\nexport class ReadArticlePolicyHandler implements IPolicyHandler {\n  handle(ability: AppAbility) {\n    return ability.can(Action.Read, Article);\n  }\n}\n"),e.qZA()(),e.TgZ(546,"p"),e._uU(547,"And use it as follows:"),e.qZA(),e.TgZ(548,"pre")(549,"code",10),e._uU(550,"\n@Get()\n@UseGuards(PoliciesGuard)\n@CheckPolicies(new ReadArticlePolicyHandler())\nfindAll() {\n  return this.articlesService.findAll();\n}\n"),e.qZA()(),e.TgZ(551,"blockquote",16)(552,"strong"),e._uU(553,"Notice"),e.qZA(),e._uU(554," Since we must instantiate the policy handler in-place using the "),e.TgZ(555,"code"),e._uU(556,"new"),e.qZA(),e._uU(557," keyword, "),e.TgZ(558,"code"),e._uU(559,"ReadArticlePolicyHandler"),e.qZA(),e._uU(560," class cannot use the Dependency Injection. This can be addressed with the "),e.TgZ(561,"code"),e._uU(562,"ModuleRef#get"),e.qZA(),e._uU(563," method (read more "),e.TgZ(564,"a",27),e._uU(565,"here"),e.qZA(),e._uU(566,"). Basically, instead of registering functions and instances through the "),e.TgZ(567,"code"),e._uU(568,"@CheckPolicies()"),e.qZA(),e._uU(569," decorator, you must allow passing a "),e.TgZ(570,"code"),e._uU(571,"Type<IPolicyHandler>"),e.qZA(),e._uU(572,". Then, inside your guard, you could retrieve an instance using a type reference: "),e.TgZ(573,"code"),e._uU(574,"moduleRef.get(YOUR_HANDLER_TYPE)"),e.qZA(),e._uU(575," or even dynamically instantiate it using the "),e.TgZ(576,"code"),e._uU(577,"ModuleRef#create"),e.qZA(),e._uU(578," method.\n"),e.qZA()()),2&n){const p=e.MAs(35),u=e.MAs(52),c=e.MAs(68),l=e.MAs(90),d=e.MAs(173);e.xp6(32),e.hij(" ",e.xi3(33,21,"role.enum",p.isJsActive),"\n"),e.xp6(17),e.hij(" ",e.xi3(50,24,"roles.decorator",u.isJsActive),"\n"),e.xp6(4),e.ekj("hide",u.isJsActive),e.xp6(3),e.ekj("hide",!u.isJsActive),e.xp6(9),e.hij(" ",e.xi3(66,27,"cats.controller",c.isJsActive),"\n"),e.xp6(4),e.ekj("hide",c.isJsActive),e.xp6(3),e.ekj("hide",!c.isJsActive),e.xp6(15),e.hij(" ",e.xi3(88,30,"roles.guard",l.isJsActive),"\n"),e.xp6(4),e.ekj("hide",l.isJsActive),e.xp6(3),e.ekj("hide",!l.isJsActive),e.xp6(76),e.hij(" ",e.xi3(171,33,"cats.controller",d.isJsActive),"\n"),e.xp6(4),e.ekj("hide",d.isJsActive),e.xp6(3),e.ekj("hide",!d.isJsActive)}},dependencies:[b.n,i.U,h.yS,w.F],encapsulation:2,changeDetection:0}),t})(),data:{title:"Authorization"}}];let S=(()=>{class t{}return t.\u0275fac=function(n){return new(n||t)},t.\u0275mod=e.oAB({type:t}),t.\u0275inj=e.cJS({imports:[v.ez,x.m,h.Bz.forChild(k)]}),t})()}}]);