<div class="content" #contentReference>
      <h3 id="gateways">Gateways</h3>
<p>Gateway is a class annotated with <code>@WebSocketGateway()</code> decorator. Gateways, by default, make use of <a href="https://github.com/socketio/socket.io">socket.io</a> package under the hood, but also, provide compatibility with a wide range of other libraries, including native web sockets implementation, read more <a routerLink="/websockets/adapter">here</a>.</p>
<figure><img src="/assets/Gateways_1.png" /></figure>

<blockquote class="
warning "><strong>Hint</strong> Gateway behaves same as a simple <strong>provider</strong>, therefore it can effortlessly inject dependencies through constructor. Also, gateway might be injected by other classes (providers and controllers) as well.
</blockquote>
<h4 appAnchor id="installation"><span>Installation</span></h4>
<p>Firstly, we need to install the required package:</p>
<pre><code class="language-bash">
$ npm i --save @nestjs/websockets</code></pre>
<h4 appAnchor id="overview"><span>Overview</span></h4>
<p>In general, each gateway is listening to the same port as <strong>HTTP server</strong> is running on, unless your app is not a web application, or you have changed the port manually. We can change this behavior by passing an argument to the <code>@WebSocketGateway(81)</code> decorator where <code>81</code> is a chosen port number. Additionally, you can set a <a href="https://socket.io/docs/rooms-and-namespaces/">namespace</a> used by this gateway with the following construction:</p>
<pre><code class="language-typescript">
@WebSocketGateway(81, &#123; namespace: &#39;events&#39; &#125;)</code></pre>
<blockquote class="
"><strong>Warning</strong> The gateway won&#39;t start until you put it inside the <code>providers</code> array.
</blockquote>
<p>The <code>namespace</code> is not a sole available option. You can pass any other property that is mentioned <a href="https://socket.io/docs/server-api/">here</a>. Those properties will be passed to the socket constructor during the instantiation process.</p>
<pre><code class="language-typescript">
@WebSocketGateway(81, &#123; transports: [&#39;websocket&#39;] &#125;)</code></pre>
<p>Alright, the gateway is listening now, but we are not subscribing to the incoming messages so far. Let&#39;s create a handler that will subscribe to the <code>events</code> messages and respond to the user with the exact same data.</p>

<span class="filename">
  {{ 'events.gateway' | extension: appc61173714124994b6e19d464e8612861a309189e.isJsActive }}
<app-tabs #appc61173714124994b6e19d464e8612861a309189e></app-tabs>
</span><pre [class.hide]="appc61173714124994b6e19d464e8612861a309189e.isJsActive"><code class="language-typescript">
@SubscribeMessage(&#39;events&#39;)
onEvent(client, data: string): string &#123;
  return data;
&#125;</code></pre>
<pre [class.hide]="!appc61173714124994b6e19d464e8612861a309189e.isJsActive"><code class="language-typescript">
@SubscribeMessage(&#39;events&#39;)
onEvent(client, data) &#123;
  return data;
&#125;</code></pre><blockquote class="
info "><strong>Hint</strong> The <code>@SubscribeMessage()</code> decorator is imported from <code>@nestjs/websockets</code> package.
</blockquote>
<p>The <code>onEvent()</code> function takes two arguments. First one is a library-specific <a href="https://socket.io/docs/server-api/#socket">socket instance</a> and the second one is the data received from the client. Once we get the message, we send an acknowledgment with the same data that someone has sent over the network. Also, it is possible to emit messages using a library-specific approach, for example, by making use of <code>client.emit()</code> method. However, in this case, you aren&#39;t able to use interceptors. If you don&#39;t want to respond to the user, just don&#39;t return anything (or explicitly return &quot;falsy&quot; value, e.g. <code>undefined</code>).</p>
<p>Now when the client emits a message in the following manner:</p>
<pre><code class="language-typescript">
socket.emit(&#39;events&#39;, &#123; name: &#39;Nest&#39; &#125;);</code></pre>
<p>The <code>onEvent()</code> method will be executed. In order to listen for messages emitted from within above handler, the client has to attach a corresponding acknowledgment&#39;s listener:</p>
<pre><code class="language-typescript">
socket.emit(&#39;events&#39;, &#123; name: &#39;Nest&#39; &#125;, data =&gt; console.log(data));</code></pre>
<h4 appAnchor id="multiple-responses"><span>Multiple responses</span></h4>
<p>The acknowledgment is dispatched only once. Furthermore, it is not supported by native WebSockets implementation. To solve this limitation, you may return an object which consist of two properties. The <code>event</code> which is a name of the emitted event and the <code>data</code> that has to be forwarded to the client.</p>

<span class="filename">
  {{ 'events.gateway' | extension: app001e185372a6311c311ef43bd8f475e85a3c1332.isJsActive }}
<app-tabs #app001e185372a6311c311ef43bd8f475e85a3c1332></app-tabs>
</span><pre [class.hide]="app001e185372a6311c311ef43bd8f475e85a3c1332.isJsActive"><code class="language-typescript">
@SubscribeMessage(&#39;events&#39;)
onEvent(client, data: any): WsResponse&lt;any&gt; &#123;
  const event = &#39;events&#39;;
  return &#123; event, data &#125;;
&#125;</code></pre>
<pre [class.hide]="!app001e185372a6311c311ef43bd8f475e85a3c1332.isJsActive"><code class="language-typescript">
@SubscribeMessage(&#39;events&#39;)
onEvent(client, data) &#123;
  const event = &#39;events&#39;;
  return &#123; event, data &#125;;
&#125;</code></pre><blockquote class="
info "><strong>Hint</strong> The <code>WsResponse</code> interface is imported from <code>@nestjs/websockets</code> package.
</blockquote>
<p>In order to listen for the incoming response(s), the client has to apply another event listener.</p>
<pre><code class="language-typescript">
socket.on(&#39;events&#39;, data =&gt; console.log(data));</code></pre>
<h4 appAnchor id="asynchronous-responses"><span>Asynchronous responses</span></h4>
<p>Each message handler can be either synchronous or <strong>asynchronous</strong> (<code>async</code>), thereby you&#39;re able to return the <code>Promise</code>. Moreover, you can return the <a href="https://github.com/reactivex/rxjs">Rx</a>  <code>Observable</code>, which means that you can return multiple values (they will be emitted until the stream is completed).</p>

<span class="filename">
  {{ 'events.gateway' | extension: app2678dafbb71123c7f44a334f273167060be2522e.isJsActive }}
<app-tabs #app2678dafbb71123c7f44a334f273167060be2522e></app-tabs>
</span><pre [class.hide]="app2678dafbb71123c7f44a334f273167060be2522e.isJsActive"><code class="language-typescript">
@SubscribeMessage(&#39;events&#39;)
onEvent(client, data: any): Observable&lt;WsResponse&lt;number&gt;&gt; &#123;
  const event = &#39;events&#39;;
  const response = [1, 2, 3];

  return from(response).pipe(
    map(data =&gt; (&#123; event, data &#125;)),
  );
&#125;</code></pre>
<pre [class.hide]="!app2678dafbb71123c7f44a334f273167060be2522e.isJsActive"><code class="language-typescript">
@SubscribeMessage(&#39;events&#39;)
onEvent(client, data) &#123;
  const event = &#39;events&#39;;
  const response = [1, 2, 3];

  return from(response).pipe(
    map(data =&gt; (&#123; event, data &#125;)),
  );
&#125;</code></pre><p>The above message handler will respond <strong>3 times</strong> (sequentially, with each item from the <code>response</code> array).</p>
<h4 appAnchor id="lifecycle-hooks"><span>Lifecycle hooks</span></h4>
<p>There are 3 useful lifecycle hooks. All of them have corresponding interfaces and are described in the following table:</p>
<table>
  <tr>
    <td>
      <code>OnGatewayInit</code>
    </td>
    <td>
      Forces to implement the <code>afterInit()</code> method. Takes library-specific server instance as an argument (and
      spreads the rest if required).
    </td>
  </tr>
  <tr>
    <td>
      <code>OnGatewayConnection</code>
    </td>
    <td>
      Forces to implement the <code>handleConnection()</code> method. Takes library-specific client socket instance as
      an argument.
    </td>
  </tr>
  <tr>
    <td>
      <code>OnGatewayDisconnect</code>
    </td>
    <td>
      Forces to implement the <code>handleDisconnect()</code> method. Takes library-specific client socket instance as
      an argument.
    </td>
  </tr>
</table>

<blockquote class="
info "><strong>Hint</strong> Each lifecycle interface is exposed from <code>@nestjs/websockets</code> package.
</blockquote>
<h4 appAnchor id="server"><span>Server</span></h4>
<p>Occasionally, you may want to have a direct access to the native, <strong>library-specific</strong> server instance. The reference to this object is passed as an argument to the <code>afterInit()</code> method (<code>OnGatewayInit</code> interface). The second approach is to make use of <code>@WebSocketServer()</code> decorator.</p>
<pre><code class="language-typescript">
@WebSocketServer() server;</code></pre>
<blockquote class="
warning "><strong>Notice</strong> The <code>@WebSocketServer()</code> decorator is imported from the <code>@nestjs/websockets</code> package.
</blockquote>
<p>Nest will automatically assign the server instance to this property when it&#39;s ready to use.</p>
<h4 appAnchor id="example"><span>Example</span></h4>
<p>A working example is available <a href="https://github.com/nestjs/nest/tree/master/sample/02-gateways">here</a>.</p>

    </div>
