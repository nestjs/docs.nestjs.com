<div class="content">
  <h3>Mixin Class</h3>
  <h5>This chapter applies only to TypeScript</h5>
  <p>
    TypeScript 2.2 adds support for the ECMAScript 2015 <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html" target="blank">mixin class pattern</a>.
    This pattern's quite useful since it's not easy to pass custom arguments to some Nest application building blocks, such as <a routerLink="/interceptors">interceptors</a> or <a routerLink="/guards">guards</a>.
    The <strong>mixin classes</strong> have much more applications, but here we're gonna focus on this single use-case.
  </p>
  <p>
    For demonstration purposes, let's rewrite the <code>CacheInterceptor</code> which we've built in the <a routerLink="/interceptors">interceptors</a> section and extract the <code>isCached</code> condition.
  </p>
  <span class="filename">cache.interceptor.ts</span>
  <pre><code class="language-typescript">{{ cacheInterceptor }}</code></pre>
  <p>
    Now the <code>CacheInterceptor</code> is abstract and contains the single abstract member - the <code>isCached</code> function.
    Based on this class, we're gonna create the <code>mixinCacheInterceptor</code> function.
  </p>
  <span class="filename">mixin-cache.interceptor.ts</span>
  <pre><code class="language-typescript">{{ mixinCacheInterceptor }}</code></pre>
  <blockquote>
    <strong>Notice</strong> The <code>mixin()</code> is a helper function. Use it whenever you wanna create a mixin class.
  </blockquote>
  <p>
    This function takes the <code>isCached()</code> predicate as an argument and assigns it to the mixin class.
    The last step is to set up the interceptor:
  </p>
  <pre><code class="language-typescript">{{ setup }}</code></pre>
  <p>
    The <code>mixin()</code> function returns the class, so you can use it in the same manner as a plain, self-created classes.
  </p>
</div>