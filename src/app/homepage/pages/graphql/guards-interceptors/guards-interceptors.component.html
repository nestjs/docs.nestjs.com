<div class="content" #contentReference>
      <h3 id="tooling">Tooling</h3>
<p>In the GraphQL world, a lot of articles complain how to handle stuff like an <strong>authentication</strong>, or <strong>side-effects</strong> of operations. Should we put it inside the business logic? Shall we use a higher-order function to enhance queries and mutations as well, for example, with an authorization logic? Or maybe use <a href="https://www.apollographql.com/docs/apollo-server/v2/features/directives.html">schema directives</a>. There is no single answer anyway.</p>
<p>Nest ecosystem is trying to help with this issue using existing features like <a routerLink="/guards">guards</a> and <a routerLink="/interceptors">interceptors</a>. The idea behind them is to reduce redundancy and also, supply you with tooling that helps creating well-structured, readable, and consistent applications.</p>
<h4 appAnchor id="overview"><span>Overview</span></h4>
<p>You can use either <a routerLink="/guards">guards</a>, <a routerLink="/interceptors">interceptors</a>, and <a routerLink="/pipes">pipes</a> in the same fashion as in the simple REST application. Additionally, you are able to easily create your own decorators, by leveraging <a routerLink="/custom-decorators">custom decorators</a> feature. They all act equivalently. Let&#39;s have a look at the following code:</p>
<pre><code class="language-typescript">
@Query(&#39;author&#39;)
@UseGuards(AuthGuard)
async getAuthor(@Args(&#39;id&#39;, ParseIntPipe) id: number) &#123;
  return await this.authorsService.findOneById(id);
&#125;</code></pre>
<p>As you can see, GraphQL works pretty well with both guards and pipes. Thanks to that you can, for instance, move your authentication logic to the guard, or even reuse the same guard class as in the REST application. The interceptors works in the exact same way:</p>
<pre><code class="language-typescript">
@Query(&#39;author&#39;)
@UseGuards(AuthGuard)
async getAuthor(@Args(&#39;id&#39;, ParseIntPipe) id: number) &#123;
  return await this.authorsService.findOneById(id);
&#125;</code></pre>
<h4 appAnchor id="execution-context"><span>Execution context</span></h4>
<p>However, the <code>ExecutionContext</code> received by both guards and interceptors is somewhat different. GraphQL resolvers have a separate set of arguments, respectively, <code>root</code>, <code>args</code>, <code>context</code>, and <code>info</code>. Hence, we need to transform given <code>ExecutionContext</code> to <code>GqlExecutionContext</code>, which is basically very simple.</p>
<pre><code class="language-typescript">
@Mutation()
@UseInterceptors(EventsInterceptor)
async upvotePost(@Args(&#39;postId&#39;) postId: number) &#123;
  return await this.postsService.upvoteById(&#123; id: postId &#125;);
&#125;</code></pre>
<p><code>GqlExecutionContext</code> exposes corresponding methods for each argument, like <code>getArgs()</code>, <code>getContext()</code>, and so on. Now we can effortlessly pick up every argument specific for currently processed request.</p>
<h4 appAnchor id="custom-decorators"><span>Custom decorators</span></h4>
<p>As mentioned before, the <a routerLink="/custom-decorators">custom decorators</a> feature works like a charm with GraphQL resolvers as well. Though, the factory function takes an array of arguments, instead of a <code>request</code> object.</p>
<pre><code class="language-typescript">
export const User = createParamDecorator(
  (data, [root, args, ctx, info]) =&gt; ctx.user,
);</code></pre>
<p>And then:</p>
<pre><code class="language-typescript">
@Mutation()
async upvotePost(
  @User() user: UserEntity,
  @Args(&#39;postId&#39;) postId: number,
) &#123;&#125;</code></pre>

    </div>
