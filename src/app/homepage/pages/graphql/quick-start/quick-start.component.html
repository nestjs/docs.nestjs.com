<div class="content">
  <h3>Quick Start</h3>
  <p>
    GraphQL is a new way of thinking about the APIs. Here's a great
    <a href="https://dev-blog.apollodata.com/graphql-vs-rest-5d425123e34b" target="blank">comparison</a> between GraphQL and REST. In this set of articles, I'm not gonna explain what the GraphQL is, but rather
    show how to work with the dedicated
    <code>@nestjs/graphql</code> module.
  </p>
  <p>
    The
    <code>GraphQLModule</code> is nothing more than a wrapper around the
    <a href="https://www.apollographql.com/" target="blank">Apollo</a> server. We don't reinvent the wheel but provide a ready to use a module instead, that brings a clean way to
    play with the GraphQL and Nest together.
  </p>
  <h4>Installation</h4>
  <p>
    Firstly, we need to install the required packages:
  </p>
  <pre><code class="language-typescript">
$ npm i --save @nestjs/graphql apollo-server-express graphql-tools graphql</code></pre>
  <h4>Apollo Middleware</h4>
  <p>
    Once the packages are installed, we can apply the GraphQL middleware provided by the
    <code>apollo-server-express</code> package:
  </p>
  <span class="filename">
    {{ 'app.module' | extension: appModuleT.isJsActive }}
    <app-tabs #appModuleT></app-tabs>
  </span>
  <pre [class.hide]="appModuleT.isJsActive"><code class="language-typescript">{{ middleware }}</code></pre>
  <pre [class.hide]="!appModuleT.isJsActive"><code class="language-typescript">{{ middlewareJs }}</code></pre>
  <p>
    That's all. We passed an empty object as a GraphQL <code>schema</code> and <code>req</code> (request object) as a <code>rootValue</code> for now.
    Additionally, there're a few other available <code>graphqlExpress</code> options and you can read about them <a href="https://www.apollographql.com/docs/apollo-server/setup.html#graphqlOptions" target="blank">here</a>.
  </p>
  <h4>Schema</h4>
  <p>
    To create a schema, we are using <code>GraphQLFactory</code> which is a part of the <code>@nestjs/graphql</code> package.
    This component provides a <code>createSchema()</code> method that accepts the same object as a <code>makeExecutableSchema()</code> function, well-described <a href="https://www.apollographql.com/docs/graphql-tools/generate-schema.html#makeExecutableSchema" target="blank">here</a>.
  </p>
  <p>
    The schema options object demand at least <code>resolvers</code> and the <code>typeDefs</code> property.
    You can pass type definitions manually, or use a utility <code>mergeTypesByPaths()</code> method of the <code>GraphQLFactory</code>.
    Let's have a look on the following example:
  </p>
  <span class="filename">
    {{ 'app.module' | extension: appModuleSchemaT.isJsActive }}
    <app-tabs #appModuleSchemaT></app-tabs>
  </span>
  <pre [class.hide]="appModuleSchemaT.isJsActive"><code class="language-typescript">{{ createSchema }}</code></pre>
  <pre [class.hide]="!appModuleSchemaT.isJsActive"><code class="language-typescript">{{ createSchemaJs }}</code></pre>
  <blockquote class="info">
    <strong>Hint</strong> Learn more about GraphQL schema <a href="http://graphql.org/learn/schema/" target="blank">here</a>.
  </blockquote>
  <p>
    In this case, the <code>GraphQLFactory</code> will go through each directory, and merge files that have a <code>.graphql</code> extension. 
    Afterwards, we can create a schema using these particular type definitions. The <code>resolvers</code> will be reflected <strong>automatically</strong>.
  </p>
  <p>
    <a href="https://www.apollographql.com/docs/graphql-tools/resolvers.html" target="blank">Here</a> you can read more about what the <strong>resolvers map</strong> actually is.
  </p>
</div>
