<div class="content">
  <h3>Configuration</h3>
  <p>
    The applications used to run in different <strong>environments</strong>. Depending on an environment, various sets of
    configuration variables should be used. For example, that's very likely that local environment relays on specific database
    credentials, valid solely for local db instance. In order to solve this issue, we used to take advantage of <code>.env</code>    files,
    that hold key-value pairs, where each key represents a particular value since this approach is very convenient.
  </p>
  <p>
    But when we use a <code>process</code> global object, it's difficult to keep our tests clean since tested class may directly
    use it. Another way is to create an abstraction layer, a <code>ConfigModule</code> that exposes a <code>ConfigService</code>    with
    loaded configuration variables.
  </p>
  <h4>Installation</h4>
  <p>
    Certain platforms automatically attach our environment variables to the <code>process.env</code> global. However, in
    the local environment, we have to manually take care of it. In order to parse our environment files, we'll use a <a href="https://github.com/motdotla/dotenv"
      target="blank">dotenv</a> package.
  </p>
  <pre><code class="language-typescript">{{ packages }}</code></pre>
  <h4>Service</h4>
  <p>
    Firstly, let's create a <code>ConfigService</code> class.
  </p>
  <span class="filename">
    <app-tabs #configServiceT></app-tabs>
  </span>
  <pre [class.hide]="configServiceT.isJsActive"><code class="language-typescript">{{ configService }}</code></pre>
  <pre [class.hide]="!configServiceT.isJsActive"><code class="language-typescript">{{ configServiceJs }}</code></pre>
  <p>
    This class takes a single argument, a <code>filePath</code>, which is a path to your <code>.env</code> file. The <code>get()</code>    method
    is provided to enable access to a private <code>envConfig</code> object that holds each property defined inside an environment
    file.
  </p>
  <p>
    The last step is to create a <code>ConfigModule</code>.
  </p>
  <span class="filename">
    <app-tabs #configModuleT></app-tabs>
  </span>
  <pre><code class="language-typescript">{{ configModule }}</code></pre>
  <p>
    The <code>ConfigModule</code> registers a <code>ConfigService</code> and exports it as well. Additionally, we passed
    a path to the <code>.env</code> file. This path will be different depending on actual execution environment. Now you
    can simply inject <code>ConfigService</code> anywhere, and pull out a particular value based on a passed key. Sample
    <code>.env</code> file could look like below:
  </p>
  <span class="filename">
    development.env
  </span>
  <pre><code class="language-typescript">{{ sampleEnv }}</code></pre>

  <h4>Using the ConfigService</h4>
  <p>
    To access <strong>environment variables</strong> from our <code>ConfigService</code> we need to inject it. Therefore
    we firstly need to import the module.
  </p>
  <span class="filename">app.module.ts</span>
  <pre><code class="language-typescript">{{ configModuleImport }}</code></pre>
  <p>
    Afterward, you can inject it using an injection token. By default, the token is equal to the class name (in our example <code>ConfigService</code>).
  </p>
  <span class="filename">app.service.ts</span>
  <pre><code class="language-typescript">{{ configServiceInjection }}</code></pre>
  <blockquote class="info">
    Instead of importing <code>ConfigModule</code> repeatingly in all your modules, you can also declare <code>ConfigModule</code>    as
    a global module.
  </blockquote>
  <h4>Advanced configuration</h4>
  <p>
    We just implemented a basic <code>ConfigService</code>. However, this approach has a couple of disadvantages, which we'll
    address now:
  </p>
  <ul>
    <li>
      missing names & types for the environment variables (no IntelliSense)
    </li>
    <li>
      a lack of <strong>validation</strong> of the provided <code>.env</code> file
    </li>
    <li>
      the env file provides booleans as string (<code>'true'</code>), and thus have to cast them to a <code>boolean</code>      every
      time
    </li>
  </ul>
  <h4>Validation</h4>
  <p>
    We'll start with the validation of the provided environment variables. You can throw an error if required environment variables
    haven't been provided or if they don't meet your predefined requirements. For this purpose, we are going to use the npm
    package <a href="https://github.com/hapijs/joi" target="blank">Joi</a>. With Joi, you define an object schema and
    validate JavaScript objects against it.
  </p>

  <p>
    Install Joi and it's types (for <strong>TypeScript</strong> users):
  </p>
  <pre><code class="language-bash">
$ npm install --save joi
$ npm install --save-dev @types/joi</code></pre>
  <p>
    Once the packages are installed, we can move to our <code>ConfigService</code>.
  </p>
  <span class="filename">config.service.ts</span>
  <pre><code class="language-typescript">{{ configServiceValidation }}</code></pre>
  <p>
    Since we set default values for <code>NODE_ENV</code> and <code>PORT</code> the validation will not fail if we don't
    provide these variables in the environment file. Nevertheless, we need to explicitly provide <code>API_AUTH_ENABLED</code>.
    The validation will also throw an error if we have variables in our .env file which aren't part of the schema. Additionally,
    Joi tries to convert the env strings into the right type.
  </p>
  <h4> Class properties</h4>
  <p>
    For each config property, we have to add a getter function.
  </p>
  <span class="filename">config.service.ts</span>
  <pre><code class="language-typescript">{{ configServiceProperties }}</code></pre>
  <h4>Usage example</h4>
  <p>
    Now we can directly access the class properties.
  </p>
  <span class="filename">app.service.ts</span>
  <pre><code class="language-typescript">{{ advancedConfigServiceSample }}</code></pre>
</div>