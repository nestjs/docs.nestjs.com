### Nestia

[Nestia](https://github.com/samchon/nestia) is an evolved `SDK` and `Swagger` generator than ever. It does not require any DTO class. Instead, pure interface type can be the DTO. Furthermore, it supports generic, union and conditional types, even containing not only DTOs but also controllers.

  - [Guide Documents](https://github.com/samchon/nestia/wiki)

> info **info** `nestia` is a third party package and is not managed by the `NestJS` core team. Please, report any issues found with the library in the [appropriate repository](https://github.com/samchon/nestia/issues/new/choose).




#### Setup
Just like any other package, you've got to install it before you can use it.

```sh
npm install --save-dev nestia
```

After the installation, you can generate the `SDK` or `Swagger`, directly.

```sh
npx nestia sdk "src/**/*.controller" --out "src/api"
npx nestia swagger "src/**/*.controller" --out "swagger.json"
```

If all of your controller files are gathered into one directory:

```sh
npx nestia sdk "src/controllers" --out "src/api"
npx nestia swagger "src/controllers" --out "swagger.json"
```




#### Preface

Don't write any swagger comment and DTO decorator. Just run `nestia` up.

  - No swagger comment/decorator
  - No DTO comment/decorator
  - Only pure `interface`s and `NestJS` code are required
    - Support generic typed `interface`s and `controller`s
    - Support union/intersection types
    - Support conditional types

`nestia` is an evolved `SDK` and `Swagger` generator, which analyzes your `NestJS` server code in the compilation level. Reading below sections and looking at the example codes, feel how the "compilation level" makes `nestia` stronger.

```typescript
// IMPORT SDK LIBRARY GENERATED BY THE NESTIA
import api from "@samchon/shopping-api";
import { IPage } from "@samchon/shopping-api/lib/structures/IPage";
import { ISale } from "@samchon/shopping-api/lib/structures/ISale";
import { ISaleArticleComment } from "@samchon/shopping-api/lib/structures/ISaleArticleComment";
import { ISaleQuestion } from "@samchon/shopping-api/lib/structures/ISaleQuestion";

export async function traceSaleQuestionAndComment(connection: api.IConnection): Promise<void> {
    // LIST UP SALE SUMMARIES
    const index: IPage<ISale.ISummary> = await api.functional.shoppings.sales.index(
        connection,
        "general",
        { limit: 100, page: 1 }
    );

    // PICK A SALE
    const sale: ISale = await api.functional.shoppings.sales.at(
        connection, 
        index.data[0].id
    );
    console.log("sale", sale);

    // WRITE A QUESTION
    const question: ISaleQuestion = await api.functional.shoppings.sales.questions.store(
        connection,
        "general",
        sale.id,
        {
            title: "How to use this product?",
            body: "The description is not fully enough. Can you introduce me more?",
            files: []
        }
    );
    console.log("question", question);

    // WRITE A COMMENT
    const comment: ISaleArticleComment = await api.functional.shoppings.sales.comments.store(
        connection,
        "general",
        sale.id,
        question.id,
        {
            body: "p.s) Can you send me a detailed catalogue?",
            anonymous: false
        }
    );
    console.log("comment", comment);
}
```




#### Pure DTO Interface

`nestia` can utilize pure interface type as DTO.

Unlike `@nestjs/swagger` which requires the DTO class with decorator functions, `nestia` can use the pure interface type directly. Also, `nestia` can utilize the pure descriptive comments, instead of using the `description` decorator. Furthermore, generic type, union/intersection type and even conditional type, `nestia` supports all of them.

Look at the code below; you may see the difference between `nestia` and `@nestjs/swagger`, and thereby catch the meaning of the pure DTO interface.

> info **Tip** 
>
> The below example codes would be shown by clicking the arrow button or text.

<details>
    <summary>
        Traditional DTO class using <code>@nestjs/swagger</code>
    </summary>

```typescript
@@filename(SaleArticleComment)
export class SaleArticleComment {
    @ApiProperty({
        description: 
`Comment wrote on a sale related article.

When an article of a sale has been enrolled, all of the participants like consumers and sellers can write a comment on that article. However, when the writer is a consumer, the consumer can hide its name through the annoymous option.

Also, writing a reply comment for a specific comment is possible and in that case, the ISaleArticleComment.parent_id property would be activated.`
    })
    id: number;

    @ApiProperty({
        type: "number",
        nullable: true,
        description:
`Parent comment ID.

Only When this comment has been written as a reply.`
    })
    parent_id: number | null;

    @ApiProperty({
        type: "string",
        description: "Type of the writer."
    })
    writer_type: "seller" | "consumer";

    @ApiProperty({
        type: "string",
        nullable: true,
        description:
`Name of the writer.

When this is a type of anonymous comment, writer name would be hidden.`
    })
    writer_name: string | null;

    @ApiProperty({
        type: "array",
        items: {
            schema: { $ref: getSchemaPath(SaleArticleComment.Content) }
        },
        description:
`Contents of the comments.

When the comment writer tries to modify content, it would not modify the comment content but would be accumulated Therefore, all the people can read how the content has been changed.`
    })
    contents: SaleArticleComment.Content[];

    @ApiProperty({
        description: "Creation time."
    })
    created_at: string;
}
```
</details>

<details>
    <summary>
        Pure DTO interface using <code>nestia</code>
    </summary>

```typescript
@@filename(ISaleArticleComment)
/**
 * Comment wrote on a sale related article.
 * 
 * When an article of a sale has been enrolled, all of the participants like consumers and
 * sellers can write a comment on that article. However, when the writer is a consumer, the
 * consumer can hide its name through the annoymous option. 
 * 
 * Also, writing a reply comment for a specific comment is possible and in that case, the 
 * {@link ISaleArticleComment.parentId} property would be activated.
 * 
 * @author Jeongho Nam - https://github.com/samchon
 */
export interface ISaleArticleComment {
    /**
     * Primary Key.
     */
    id: number;

    /**
     * Parent comment ID.
     * 
     * Only When this comment has been written as a reply.
     */
    parentId: number | null;

    /**
     * Type of the writer.
     */
    writerType: "seller" | "consumer";

    /**
     * Name of the writer.
     * 
     * When this is a type of anonymous comment, writer name would be hidden.
     */
    writerName: string | null;

    /**
     * Contents of the comments.
     * 
     * When the comment writer tries to modify content, it would not modify the comment
     * content but would be accumulated. Therefore, all the people can read how
     * the content has been changed.
     */
    contents: ISaleArticleComment.IContent[];

    /**
     * Creation time.
     */
    createdAt: string;
}
export namespace ISaleArticleComment {
    /**
     * Store info.
     */
    export interface IStore {
        /**
         * Body of the content.
         */
        body: string;

        /**
         * Whether to hide the writer name or not.
         */
        annonymous: boolean;
    }

    /**
     * Content info.
     */
    export interface IContent {
        /**
         * Primary Key.
         */
        id: string;

        /**
         * Body of the content.
         */
        body: string;

        /**
         * Creation time.
         */
        createdAt: string;
    }
}
```
</details>

<details>
    <summary>
        Generic typed DTO using <code>nestia</code>
    </summary>

```typescript
@@filename(ISaleInquiry)
/**
 * Inquiry article.
 * 
 * Sub-type of article and super-type of question and answer.
 * 
 *  - List of the sub-types
 *    - {@link ISaleQuestion}
 *    - {@link ISaleReview}
 * 
 * @template Content Content type
 * @author Jeongho Nam - https://github.com/samchon
 */
export interface ISaleInquiry<Content extends ISaleInquiry.IContent> 
    extends ISaleArticle<Content> {
    /**
     * Primary Key.
     */
    id: number;

    /**
     * Name of the writer.
     */
    writer: string;

    /**
     * List of contents.
     * 
     * When the article writer tries to modify content, it would not modify the article
     * content but would be accumulated. Therefore, all the people can read how
     * the content has been changed.
     */
    contents: Content[];

    /**
     * Creation time.
     */
    createdAat: string;
        
    /**
     * Formal answer from the seller.
     */
    answer: ISaleInquiryAnswer | null;
}
export namespace ISaleInquiry {
    /**
     * Content info.
     */
    export interface IContent {
        /**
         * Primary Key
         */
        id: string;

        /**
         * Title of the content.
         */
        title: string;

        /**
         * Body of the content.
         */
        body: string;

        /**
         * Attached files.
         */
        files: IAttachmentFile[];

        /**
         * Creation time.
         */
        createdAt: string;
    }
}
```
</details>

<details>
    <summary>
        Union typed DTO using <code>nestia</code>
    </summary>

```typescript
@@filename(ISaleEntireArticle)
/**
 * Union type of the entire sub-type articles.
 * 
 * @author Jeongho Nam - https://github.com/samchon
 */
export type ISaleEntireArtcle = ISaleQuestion | ISaleReview;
```
</details>




#### Advanced Controller Class

Controller also can use the generic arguments.

In the previous `Pure DTO Interface` corner, we've learned that `nestia` can use the pure interface type as DTO. Also, we've learned that utilizing generic, union/intersection and even conditional typed interfaces are also possible.

In the Controller case, it's same with the upper DTO story. With `nestia`, defining a generic typed controller class is also possible, too. By defining a generic typed controller class as a super-type class, you can reduce both duplicated code and description comments.

Look at the below code and feel how powerful `nestia` is. It should be stated that, `@nestjs/swagger` cannot construct such generic or union typed controller class.

```typescript
@@filename(src/controllers/SaleInquiriesController)
import { Body, Post, Put } from "@nestjs/common";
import { Request } from "express";
import { TypedParam } from "nestia-helper";

import { ISaleInquiry } from "@api/structures/ISaleInquiry";

export abstract class SaleInquiriesController<
        Content extends ISaleInquiry.IContent,
        Store extends ISaleInquiry.IStore,
        Json extends ISaleInquiry<Content>> {
    /**
     * Store a new inquiry.
     * 
     * Write a new article inquirying about a sale.
     * 
     * @param request Instance of the Express.Request
     * @param section Code of the target section
     * @param saleId ID of the target sale
     * @param input Content to archive
     * @return Newly archived inquiry
     * 
     * @throw 400 bad request error when type of the input data is not valid
     * @throw 401 unauthorized error when you've not logged in yet
     */
    @Post()
    public store(
            @Request() request: Request,
            @TypedParam("section", "string") section: string, 
            @TypedParam("saleId", "string") saleId: string,
            @Body() input: Store
        ): Promise<Json>;

    /**
     * Update an inquiry.
     * 
     * Update ordinary inquiry article. However, it would not modify the content record
     * {@link ISaleInquiry.IContent}, but be accumulated into the {@link ISaleInquiry.contents}. 
     * Therefore, all the people can read how the content has been changed.
     * 
     * @param request Instance of the Express.Request
     * @param section Code of the target section
     * @param saleId ID of the target sale
     * @param id ID of the target article to be updated
     * @param input New content to be overwritten
     * @return The newly created content record
     * 
     * @throw 400 bad request error when type of the input data is not valid
     * @throw 401 unauthorized error when you've not logged in yet
     * @throw 403 forbidden error when the article is not yours
     */
    @Put(":id")
    public update(
            @Request() request: Request,
            @TypedParam("section", "string") section: string, 
            @TypedParam("saleId", "string") saleId: string,
            @TypedParam("id", "number") id: number,
            @Body() input: Store
        ): Promise<Json>;
}
```




#### Software Development Kit

Looking at the SDK library file, generated by `nestia`, it is perfect.

Route method, path and parameters are well-formed and DTO structures are correctly imported. Also, descriptive comments are fully revived in the SDK library, regardless of where they are written.

Furthermore, there's not any problem even when a generic typed controller class comes. `nestia` will specialize the generic arguments exactly, by analyzing your `NestJS` server code, in the compilation level.

```typescript
@@filename(src/api/functional/consumers/sales/articles/reviews/index)
/**
 * @packageDocumentation
 * @module api.functional.consumers.sales.reviews
 * @nestia Generated by Nestia - https://github.com/samchon/nestia 
 */
//================================================================
import { Fetcher, Primitive } from "nestia-fetcher";
import type { IConnection } from "nestia-fetcher";
import { createStringifier } from "typescript-json";

import type { ISaleReview } from "./../../../../structures/ISaleReview";
import type { ISaleInquiry } from "./../../../../structures/ISaleInquiry";

/**
 * Store a new inquiry.
 * 
 * Write a new article inquirying about a sale.
 * 
 * @param connection Connection information of the remote HTTP(s) server with headers (+encryption password)
 * @param request Instance of the Express.Request
 * @param section Code of the target section
 * @param saleId ID of the target sale
 * @param input Content to archive
 * @return Newly archived inquiry
 * @throw 400 bad request error when type of the input data is not valid
 * @throw 401 unauthorized error when you've not logged in yet
 * 
 * @controller ConsumerSaleReviewsController.store()
 * @path POST /consumers/:section/sales/:saleId/reviews
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export function store(
        connection: IConnection,
        section: string,
        saleId: string,
        input: Primitive<store.Input>
    ): Promise<store.Output>
{
    return Fetcher.fetch(
        connection,
        store.ENCRYPTED,
        store.METHOD,
        store.path(section, saleId),
        input,
        store.stringify
    );
}
export namespace store {
    export type Input = Primitive<ISaleReview.IStore>;
    export type Output = Primitive<ISaleInquiry<ISaleReview.IContent>>;

    export const METHOD = "POST" as const;
    export const PATH: string = "/consumers/:section/sales/:saleId/reviews";
    export const ENCRYPTED: Fetcher.IEncrypted = {
        request: false,
        response: false,
    };

    export function path(section: string, saleId: string): string {
        return `/consumers/${section}/sales/${saleId}/reviews`;
    }
    export const stringify = createStringifier<Input>();
}

/**
 * Update an inquiry.
 * 
 * Update ordinary inquiry article. However, it would not modify the content record
 * {@link ISaleInquiry.IContent}, but be accumulated into the {@link ISaleInquiry.contents}. 
 * Therefore, all of the people can read how the content has been changed.
 * 
 * @param connection connection Information of the remote HTTP(s) server with headers (+encryption password)
 * @param request Instance of the Express.Request
 * @param section Code of the target section
 * @param saleId ID of the target sale
 * @param id ID of the target article to be updated
 * @param input New content to be overwritten
 * @return The newly created content record
 * @throw 400 bad request error when type of the input data is not valid
 * @throw 401 unauthorized error when you've not logged in yet
 * @throw 403 forbidden error when the article is not yours
 * 
 * @controller ConsumerSaleReviewsController.update()
 * @path PUT /consumers/:section/sales/:saleId/reviews/:id
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export function update(
        connection: IConnection,
        section: string,
        saleId: string,
        id: number,
        input: Primitive<update.Input>
    ): Promise<update.Output>
{
    return Fetcher.fetch(
        connection,
        update.ENCRYPTED,
        update.METHOD,
        update.path(section, saleId, id),
        input,
        update.stringify
    );
}
export namespace update
{
    export type Input = Primitive<ISaleReview.IStore>;
    export type Output = Primitive<ISaleInquiry<ISaleReview.IContent>>;

    export const METHOD = "PUT" as const;
    export const PATH: string = "/consumers/:section/sales/:saleId/reviews/:id";
    export const ENCRYPTED: Fetcher.IEncrypted = {
        request: false,
        response: false,
    };

    export function path(section: string, saleId: string, id: number): string {
        return `/consumers/${section}/sales/${saleId}/reviews/${id}`;
    }
    export const stringify = createStringifier<Input>();
}
```




#### Swagger

Building `Swagger` is also possible and even much powerful.

Looking at the [simple/swagger.json](https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Fdemo%2Fsimple%2Fswagger.json) file, generated by `nestia`, everything is perfect. Route method, path and parameters are well-formed. Also, schema definitions are exactly matched with the pure interface type `ISaleArticleComment`. Of course, descriptive comments are perfectly resurrected in the `description` properties of the `swagger.json` file.

Looking at the another file [generic/swagger.json](https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Fdemo%2Fgeneric%2Fswagger.json), you can find that there isn't any problem even when a generic typed DTO and controller come. The last file [union/swagger.json](https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Fdemo%2Funion%2Fswagger.json), there's no problem on the union type, either.

  - View in the `Swagger Editor`
    - [simple/swagger.json](https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Fdemo%2Fsimple%2Fswagger.json)
    - [generic/swagger.json](https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Fdemo%2Fgeneric%2Fswagger.json)
    - [union/swagger.json](https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Fdemo%2Funion%2Fswagger.json)




#### Configuration

`nestia` can configure generator options by two ways: CLI and configuration file.

At first, the CLI (Command Line Interface) is convenient, but does not support detailed options.

```sh
# BASIC COMMAND
npx nestia <sdk|swagger> <source_directories_or_patterns> \
    --exclude <exclude_directory_or_pattern> \
    --out <output_directory_or_file>

# EXAMPLES
npx nestia sdk "src/controllers" --out "src/api"
npx nestia swagger "src/**/*.controller.ts" --out "swagger.json"
npx nestia swagger "src/main/controllers" "src/sub/controllers" \
    --exclude "src/main/test" \
    --out "composite.swagger.json"

# ONLY WHEN NESTIA.CONFIG.TS EXISTS
npx nestia sdk
npx nestia swagger
```

Besides, the configuration file `nestia.config.ts` supports much detailed options. 

The detailed options are listed up to the `IConfiguration` interface. You can utilize the `IConfiguration` type like below. If you want to know more about those options, please check the [nestia docs](https://github.com/samchon/nestia/wiki/Configuration).

<details>
    <summary> Read <code>IConfiguration</code> </summary>

```typescript
@@filename(IConfiguration)
/**
 * Definition for the `nestia.config.ts` file.
 * 
 * @author Jeongho Nam - https://github.com/samchon
 */
export interface IConfiguration {
    /**
     * List of files or directories containing the `NestJS` controller classes.
     */
    input: string | string[] | IConfiguration.IInput;

    /**
     * Output directory that SDK would be placed in.
     * 
     * If not configured, you can't build the SDK library.
     */
    output?: string;

    /**
     * Compiler options for the TypeScript.
     * 
     * If you've omitted this property or the assigned property cannot fully cover the
     * `tsconfig.json`, the properties from the `tsconfig.json` would be assigned to here.
     * Otherwise, this property has been configured and it's detailed values are different 
     * with the `tsconfig.json`, this property values would be overwritten.
     * 
     * ```typescript
     * import ts from "typescript";
     * 
     * const tsconfig: ts.TsConfig;
     * const nestiaConfig: IConfiguration;
     * 
     * const compilerOptions: ts.CompilerOptions = {
     *     ...tsconfig.compilerOptions,
     *     ...(nestiaConfig.compilerOptions || {})
     * }
     * ```
     */
    compilerOptions?: ts.CompilerOptions;

    /**
     * Whether to assert parameter types or not.
     * 
     * If you configure this property to be `true`, all of the function parameters would be
     * checked through the [typescript-is](https://github.com/woutervh-/typescript-is). This
     * option would make your SDK library slower, but would be much safer in the type level
     * even in the runtime environment.
     */
    assert?: boolean;

    /**
     * Whether to optimize JSON string conversion 2x faster or not.
     * 
     * If you configure this property to be `true`, the SDK library would utilize the
     * [typescript-json](https://github.com/samchon/typescript-json) and the JSON string
     * conversion speed really be 2x faster.
     */
    json?: boolean;

    /**
     * Building `swagger.json` is also possible.
     * 
     * If not specified, you can't build the `swagger.json`.
     */
    swagger?: IConfiguration.ISwagger;
}
export namespace IConfiguration
{
    /**
     * List of files or directories to include or exclude to specifying the `NestJS` 
     * controllers.
     */
    export interface IInput {
        /**
         * List of files or directories containing the `NestJS` controller classes.
         */
        include: string[];

        /**
         * List of files or directories to be excluded.
         */
        exclude?: string[];
    }

    /**
     * Building `swagger.json` is also possible.
     */
    export interface ISwagger {
        /**
         * Output path of the `swagger.json`.
         * 
         * If you've configured only directory, the file name would be the `swagger.json`. 
         * Otherwise you've configured the full path with file name and extension, the 
         * `swagger.json` file would be renamed to it.
         */
        output: string;
    }
}
```
</details>

```typescript
@@filename(nestia.config)
import type { IConfiguration } from "nestia";

export const NESTIA_CONFIG: IConfiguration = {
    input: "./src/controllers",
    output: "./src/api",
    json: true,
    swagger: {
        output: "./public/swagger.json"
    }
};
export default NESTIA_CONFIG;
```