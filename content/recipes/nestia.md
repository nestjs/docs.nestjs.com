### Nestia

[Nestia](https://github.com/samchon/nestia) is an evolved `SDK` and `Swagger` generator than ever, which requires not DTO class with decorator but pure interface type. Furthermore, it supports generic, union and conditional types, even containig not only DTOs but also controllers.

  - [Guide Documents](https://github.com/samchon/nestia/wiki)

> info **info** `nestia` is a third party package and is not managed by the `NestJS` core team. Please, report any issues found with the library in the [appropriate repository](https://github.com/samchon/nestia/issues/new/choose).




#### Outline

```sh
# INSTALL NESTIA
npm install --save-dev nestia

# BUILDING SDK LIBRARY
npx nestia sdk "src/controller" --out "src/api"
npx nestia sdk "src/**/*.controller.ts" --out "src/api"
npx nestia sdk "src/controller" \ 
    --exclude "src/controller/test" \
    --out "src/api"

# BUILDING SWAGGER.JSON IS ALSO POSSIBLE
npx nestia swagger "src/controller" -- out "swagger.json"
```

Don't write any swagger comment and DTO decorator. Just run `nestia` up.

  - No swagger comment/decorator
  - No DTO comment/decorator
  - Only pure `interface`s and `NestJS` code are required
    - Support generic typed `interface`s and `controller`s
    - Support union/intersection types
    - Support conditional types

`nestia` is an evolved `SDK` and `Swagger` generator, which analyzes your `NestJS` server code in the compilation level. Reading below sections and looking at example codes, feel how the "compilation level" makes `nestia` stronger.

```typescript
// IMPORT SDK LIBRARY WHO'VE BEEN GENERATED BY THE NESTIA
import api from "@samchon/shopping-api";
import { IPage } from "@samchon/shopping-api/lib/structures/IPage";
import { ISale } from "@samchon/shopping-api/lib/structures/ISale";
import { ISaleArticleComment } from "@samchon/shopping-api/lib/structures/ISaleArticleComment";
import { ISaleQuestion } from "@samchon/shopping-api/lib/structures/ISaleQuestion";

export async function traceSaleQuestionAndComment(connection: api.IConnection): Promise<void> {
    // LIST UP SALE SUMMARIES
    const index: IPage<ISale.ISummary> = await api.functional.shoppings.sales.index(
        connection,
        "general",
        { limit: 100, page: 1 }
    );

    // PICK A SALE
    const sale: ISale = await api.functional.shoppings.sales.at(
        connection, 
        index.data[0].id
    );
    console.log("sale", sale);

    // WRITE A QUESTION
    const question: ISaleQuestion = await api.functional.shoppings.sales.questions.store(
        connection,
        "general",
        sale.id,
        {
            title: "How to use this product?",
            body: "The description is not fully enough. Can you introduce me more?",
            files: []
        }
    );
    console.log("question", question);

    // WRITE A COMMENT
    const comment: ISaleArticleComment = await api.functional.shoppings.sales.comments.store(
        connection,
        "general",
        sale.id,
        question.id,
        {
            body: "p.s) Can you send me a detailed catalogue?",
            anonymous: false
        }
    );
    console.log("comment", comment);
}
```




#### Pure DTO Interface

`nestia` can utilize the pure interface type as DTO.

Unlike `@nestjs/swagger` who requires a class with decorator functions when defining the DTO, `nestia` can use the pure interface directly. Also, `nestia` can use the descriptive comments of the pure DTO interface, too.

Furthermore, as `nestia` can use the pure interface type directly, it's possible to define a generic typed DTO interface with inheritance. Of course, using alis type or union typed DTO are also possibble, too.

  - Simple [`ISaleArticleComment`](https://github.com/samchon/nestia/tree/master/demo/simple/src/api/structures/ISaleArticleComment.ts)
  - Generic interfaces
    - grandparent interface, [`ISaleArticle<Content>`](https://github.com/samchon/nestia/tree/master/demo/generic/src/api/structures/ISaleArticle.ts)
    - parent interface, [`ISaleInquiry<Content>`](https://github.com/samchon/nestia/tree/master/demo/generic/src/api/structures/ISaleInquiry.ts)
    - 1st sub-type interface, [`ISaleQuestion`](https://github.com/samchon/nestia/tree/master/demo/generic/src/api/structures/ISaleQuestion.ts)
    - 2nd sub-type interface, [`ISaleReview`](https://github.com/samchon/nestia/tree/master/demo/generic/src/api/structures/ISaleReview.ts)
  - Union alias type [`ISaleEntireArticle`](https://github.com/samchon/nestia/tree/master/demo/generic/src/api/structures/ISaleArticle.ts)

Looking at the below example code, then you may understand which differences between `nestia` and `@nestjs/swagger` and what the pure interface DTO type means. Writing the traditional DTO class of `@nestjs/swagger` after a very long time, I felt the feeling again, "this is insane". 

> info **Tip** 
>
> The below example code would be shown by clicking the arrow button or text.

<details>
    <summary>
        Pure DTO interface using <code>nestia</code>
    </summary>

```typescript
@@filename(ISaleArticleComment)
/**
 * Comment wrote on a sale related article.
 * 
 * When an article of a sale has been enrolled, all of the participants like consumers and
 * sellers can write a comment on that article. However, when the writer is a consumer, the
 * consumer can hide its name through the annoymous option. 
 * 
 * Also, writing a reply comment for a specific comment is possible and in that case, the 
 * {@link ISaleArticleComment.parentId} property would be activated.
 * 
 * @author Jeongho Nam - https://github.com/samchon
 */
export interface ISaleArticleComment {
    /**
     * Primary Key.
     */
    id: number;

    /**
     * Parent comment ID.
     * 
     * Only When this comment has been written as a reply.
     */
    parentId: number | null;

    /**
     * Type of the writer.
     */
    writerType: "seller" | "consumer";

    /**
     * Name of the writer.
     * 
     * When this is a type of anonymous comment, writer name would be hidden.
     */
    writerName: string | null;

    /**
     * Contents of the comments.
     * 
     * When the comment writer tries to modify content, it would not modify the comment
     * content but would be accumulated. Therefore, all of the people can read how
     * the content has been changed.
     */
    contents: ISaleArticleComment.IContent[];

    /**
     * Creation time.
     */
    createdAt: string;
}
export namespace ISaleArticleComment {
    /**
     * Store info.
     */
    export interface IStore {
        /**
         * Body of the content.
         */
        body: string;

        /**
         * Whether to hide the writer name or not.
         */
        annonymous: boolean;
    }

    /**
     * Content info.
     */
    export interface IContent {
        /**
         * Primary Key.
         */
        id: string;

        /**
         * Body of the content.
         */
        body: string;

        /**
         * Creation time.
         */
        createdAt: string;
    }
}
```
</details>

<details>
    <summary>
        Traditional DTO class using <code>@nestjs/swagger</code>
    </summary>

```typescript
@@filename(SaleArticleComment)
export class SaleArticleComment {
    @ApiProperty({
        description: 
`Comment wrote on a sale related article.

When an article of a sale has been enrolled, all of the participants like consumers and sellers can write a comment on that article. However, when the writer is a consumer, the consumer can hide its name through the annoymous option.

Also, writing a reply comment for a specific comment is possible and in that case, the ISaleArticleComment.parent_id property would be activated.`
    })
    id: number;

    @ApiProperty({
        type: "number",
        nullable: true,
        description:
`Parent comment ID.

Only When this comment has been written as a reply.`
    })
    parent_id: number | null;

    @ApiProperty({
        type: "string",
        description: "Type of the writer."
    })
    writer_type: "seller" | "consumer";

    @ApiProperty({
        type: "string",
        nullable: true,
        description:
`Name of the writer.

When this is a type of anonymous comment, writer name would be hidden.`
    })
    writer_name: string | null;

    @ApiProperty({
        type: "array",
        items: {
            schema: { $ref: getSchemaPath(SaleArticleComment.Content) }
        },
        description:
`Contents of the comments.

When the comment writer tries to modify content, it would not modify the comment content but would be accumulated Therefore, all of the people can read how the content has been changed.`
    })
    contents: SaleArticleComment.Content[];

    @ApiProperty({
        description: "Creation time."
    })
    created_at: string;
}
```
</details>




#### Advanced Controller Class

Controller also can use the generic arguments.

In the previous `Pure DTO Interface` corner, we've learned that `nestia` can use the pure interface type as the DTO. Also, we've learned that using the pure interface type as DTO means that making generic typed interface or union typed interface as the DTO are also possible.

In the Controller case, it's the same with the upper interface story. With `nestia`, as using a generic typed interface as DTO was possible, defining a generic typed controller class is also possible, too. By defining the generic typed controller class as the super type class, you can reduce both duplicated code and duplicated description comments.

Look at the below code and feel how `nestia` is powerful. It should be stated that, `@nestjs/swagger` can not easilsy construct such generic or union typed controller classes, either.

  - Simple [`CustomerSaleArticleCommentsController`](https://github.com/samchon/nestia/blob/master/demo/simple/src/controllers/ConsumerSaleArticleCommentsController.ts)
  - Generic controllers
    - abstract controller, [`SaleInquiriesController<Content, Store, Json>`](https://github.com/samchon/nestia/tree/master/demo/generic/src/controllers/SaleInquiriesController.ts)
    - 1st sub-type controller, [`ConsumerSaleQuestionsController`](https://github.com/samchon/nestia/tree/master/demo/generic/src/controllers/ConsumerSaleQuestionsController.ts)
    - 2nd sub-type controller, [`ConsumerSaleQuestionsController`](https://github.com/samchon/nestia/tree/master/demo/generic/src/controllers/ConsumerSaleQuestionsController.ts)
  - Union controller, [`ConsumerSaleEntireArticlesController`](https://github.com/samchon/nestia/tree/master/demo/union/src/controllers/ConsumerSaleEntireArticlesController.ts)

```typescript
@@filename(src/controllers/SaleInquiriesController)
import { Request } express from "express";
import { Body, Post, Put } from "@nestjs/common";
import { TypedParam } from "nestia-helper";

import { ISaleInquiry } from "@api/structures/ISaleInquiry";

export abstract class SaleInquiriesController<
        Content extends ISaleInquiry.IContent,
        Store extends ISaleInquiry.IStore,
        Json extends ISaleInquiry<Content>> {
    /**
     * Store a new inquiry.
     * 
     * Write a new article inquirying about a sale.
     * 
     * @param request Instance of the Express.Request
     * @param section Code of the target section
     * @param saleId ID of the target sale
     * @param input Content to archive
     * @return Newly archived inquiry
     * 
     * @throw 400 bad request error when type of the input data is not valid
     * @throw 401 unauthorized error when you've not logged in yet
     */
    @Post()
    public store(
            @Request() request: express.Request,
            @TypedParam("section", "string") section: string, 
            @TypedParam("saleId", "string") saleId: string,
            @Body() input: Store
        ): Promise<Json>;

    /**
     * Update an inquiry.
     * 
     * Update ordinary inquiry article. However, it would not modify the content reocrd
     * {@link ISaleInquiry.IContent}, but be accumulated into the {@link ISaleInquiry.contents}. 
     * Therefore, all of the poeple can read how the content has been changed.
     * 
     * @param request Instance of the Express.Request
     * @param section Code of the target section
     * @param saleId ID of the target sale
     * @param id ID of the target article to be updated
     * @param input New content to be overwritten
     * @return The newly created content record
     * 
     * @throw 400 bad request error when type of the input data is not valid
     * @throw 401 unauthorized error when you've not logged in yet
     * @throw 403 forbidden error when the article is not yours
     */
    @Put(":id")
    public update(
            @Request() request: express.Request,
            @TypedParam("section", "string") section: string, 
            @TypedParam("saleId", "string") saleId: string,
            @TypedParam("id", "number") id: number,
            @Body() input: Store
        ): Promise<Json>;
}
```




#### Software Development Kit

Looking at the SDK library file, generated by `nestia`, it seems perfect.

Exact route method, path and parameters are constructed and DTO structures are perfectly imported. Also, descriptive comments written on the controller class methods, DTO interfaces and their properties are exactly revied in the SDK library.

Furthermore, there's not any problem even when the generic typed abstract controller classes with generic typed DTO comes. `nestia` will specialize the generic arguments exactly, by analyzing your `NestJS` server code, in the compilation level.

  - [simple/.../comments/index.ts](https://github.com/samchon/nestia/blob/master/demo/simple/src/api/functional/consumers/sales/articles/comments/index.ts)
  - [generic/.../questions/index.ts](https://github.com/samchon/nestia/tree/master/demo/generic/src/api/functional/consumers/sales/questions/index.ts)
  - [generic/.../reviews/index.ts](https://github.com/samchon/nestia/tree/master/demo/generic/src/api/functional/consumers/sales/reviews/index.ts)
  - [union/.../entire_articles/index.ts](https://github.com/samchon/nestia/tree/master/demo/union/src/api/functional/consumers/sales/entire_articles/index.ts)

```typescript
@@filename(src/api/functional/consumers/sales/articles/reviews/index)
/**
 * @packageDocumentation
 * @module api.functional.consumers.sales.reviews
 * @nestia Generated by Nestia - https://github.com/samchon/nestia 
 */
//================================================================
import { Fetcher, Primitive } from "nestia-fetcher";
import type { IConnection } from "nestia-fetcher";
import { createStringifier } from "typescript-json";

import type { ISaleReview } from "./../../../../structures/ISaleReview";
import type { ISaleInquiry } from "./../../../../structures/ISaleInquiry";

/**
 * Store a new inquiry.
 * 
 * Write a new article inquirying about a sale.
 * 
 * @param connection connection Information of the remote HTTP(s) server with headers (+encryption password)
 * @param request Instance of the Express.Request
 * @param section Code of the target section
 * @param saleId ID of the target sale
 * @param input Content to archive
 * @return Newly archived inquiry
 * @throw 400 bad request error when type of the input data is not valid
 * @throw 401 unauthorized error when you've not logged in yet
 * 
 * @controller ConsumerSaleReviewsController.store()
 * @path POST /consumers/:section/sales/:saleId/reviews
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export function store(
        connection: IConnection,
        section: string,
        saleId: string,
        input: Primitive<store.Input>
    ): Promise<store.Output>
{
    return Fetcher.fetch(
        connection,
        store.ENCRYPTED,
        store.METHOD,
        store.path(section, saleId),
        input,
        store.stringify
    );
}
export namespace store {
    export type Input = Primitive<ISaleReview.IStore>;
    export type Output = Primitive<ISaleInquiry<ISaleReview.IContent>>;

    export const METHOD = "POST" as const;
    export const PATH: string = "/consumers/:section/sales/:saleId/reviews";
    export const ENCRYPTED: Fetcher.IEncrypted = {
        request: false,
        response: false,
    };

    export function path(section: string, saleId: string): string {
        return `/consumers/${section}/sales/${saleId}/reviews`;
    }
    export const stringify = createStringifier<Input>();
}

/**
 * Update an inquiry.
 * 
 * Update ordinary inquiry article. However, it would not modify the content reocrd
 * {@link ISaleInquiry.IContent}, but be accumulated into the {@link ISaleInquiry.contents}. 
 * Therefore, all of the poeple can read how the content has been changed.
 * 
 * @param connection connection Information of the remote HTTP(s) server with headers (+encryption password)
 * @param request Instance of the Express.Request
 * @param section Code of the target section
 * @param saleId ID of the target sale
 * @param id ID of the target article to be updated
 * @param input New content to be overwritten
 * @return The newly created content record
 * @throw 400 bad request error when type of the input data is not valid
 * @throw 401 unauthorized error when you've not logged in yet
 * @throw 403 forbidden error when the article is not yours
 * 
 * @controller ConsumerSaleReviewsController.update()
 * @path PUT /consumers/:section/sales/:saleId/reviews/:id
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export function update(
        connection: IConnection,
        section: string,
        saleId: string,
        id: number,
        input: Primitive<update.Input>
    ): Promise<update.Output>
{
    return Fetcher.fetch(
        connection,
        update.ENCRYPTED,
        update.METHOD,
        update.path(section, saleId, id),
        input,
        update.stringify
    );
}
export namespace update
{
    export type Input = Primitive<ISaleReview.IStore>;
    export type Output = Primitive<ISaleInquiry<ISaleReview.IContent>>;

    export const METHOD = "PUT" as const;
    export const PATH: string = "/consumers/:section/sales/:saleId/reviews/:id";
    export const ENCRYPTED: Fetcher.IEncrypted = {
        request: false,
        response: false,
    };

    export function path(section: string, saleId: string, id: number): string {
        return `/consumers/${section}/sales/${saleId}/reviews/${id}`;
    }
    export const stringify = createStringifier<Input>();
}
```




#### Swagger

Building `Swagger` is also possible and even much powerful.

`nestia` also can build the `swagger.json` file and the `Swagger` generator of `nestia` is even much powerful and convenient than `@nestjs/swagger`. It doesn't require any type of the swagger comment or DTO decorator function and just using the pure interface type as DTO is possible.

Looking at the [simple/swagger.json](https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Fdemo%2Fsimple%2Fswagger.json) file, generated by `nestia`, it seems perfect. Exact route method, path and parameters are constructed and DTO structures are exactly same with the pure interace type `ISaleArticleComment`. Also, comments written on the controller class method, DTO interface `ISaleArticleComment` and its properties are exactly revied on the `description` fields in the `swagger.json`.

Looking at the another file [generic/swagger.json](https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Fdemo%2Fgeneric%2Fswagger.json), you can find that there isn't any problem even when the generic typed DTO interfaces or controller classes come. Furthermore, traveling the `description` properties of the [generic/swagger.json](https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Fdemo%2Funion%2Fswagger.json), comments written on the generic interfaces and controllers are exactly revived in each route functions and schema definitions.

  - View in the `Swagger Editor`
    - [simple/swagger.json](https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Fdemo%2Fsimple%2Fswagger.json)
    - [generic/swagger.json](https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Fdemo%2Fgeneric%2Fswagger.json)
    - [union/swagger.json](https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Fdemo%2Funion%2Fswagger.json)




#### Configuration

`nestia` can configure detailed building options by two ways: CLI and configuration file.

At first, the CLI (Command Line Interface) is convenient, but does not support detailed options.

```sh
# BASIC COMMAND
npx nestia <nestia|swagger> <source_directories_or_patterns> \
    --exclude <exclude_directory_or_pattern> \
    --out <output_directory_or_file>

# EXAMPLES
npx nestia nestia "src/controllers" --out "src/api"
npx nestia swagger "src/**/*.controller.ts" -- out "swagger.json"
npx nestia swagger "src/main/controllers" "src/sub/controllers" \
    --exclude "src/main/test" \
    --out "composite.swagger.json"

# ONLY WHEN NESTIA.CONFIG.TS EXISTS
npx nestia nestia
npx nestia swagger
```

Besides, the configuration file `nestia.config.ts` supports much detailed options than the CLI. 

Detailed options of the configuration file are listed up into the `IConfiguration` interface type and you can utilzie it by the `import` statement like below. If you want to know more about the detailed options, please check the [nestia docs](https://github.com/samchon/nestia/wiki/Configuration).

<details>
    <summary> Read <code>IConfiguration</code> </summary>

```typescript
@@filename(IConfiguration)
/**
 * Definition for the `nestia.config.ts` file.
 * 
 * @author Jeongho Nam - https://github.com/samchon
 */
export interface IConfiguration {
    /**
     * List of files or directories containing the `NestJS` controller classes.
     */
    input: string | string[] | IConfiguration.IInput;

    /**
     * Output directory that SDK would be placed in.
     * 
     * If not configured, you can't build the SDK library.
     */
    output?: string;

    /**
     * Compiler options for the TypeScript.
     * 
     * If you've omitted this property or the assigned property cannot fully cover the
     * `tsconfig.json`, the properties from the `tsconfig.json` would be assigned to here.
     * Otherwise, this property has been configured and it's detailed values are different 
     * with the `tsconfig.json`, this property values would be overwritten.
     * 
     * ```typescript
     * import ts from "typescript";
     * 
     * const tsconfig: ts.TsConfig;
     * const nestiaConfig: IConfiguration;
     * 
     * const compilerOptions: ts.CompilerOptions = {
     *     ...tsconfig.compilerOptions,
     *     ...(nestiaConfig.compilerOptions || {})
     * }
     * ```
     */
    compilerOptions?: ts.CompilerOptions;

    /**
     * Whether to assert parameter types or not.
     * 
     * If you configure this property to be `true`, all of the function parameters would be
     * checked through the [typescript-is](https://github.com/woutervh-/typescript-is). This
     * option would make your SDK library slower, but would be much safer in the type level
     * even in the runtime environment.
     */
    assert?: boolean;

    /**
     * Whether to optimize JSON string conversion 2x faster or not.
     * 
     * If you configure this property to be `true`, the SDK library would utilize the
     * [typescript-json](https://github.com/samchon/typescript-json) and the JSON string
     * conversion speed really be 2x faster.
     */
    json?: boolean;

    /**
     * Building `swagger.json` is also possible.
     * 
     * If not specified, you can't build the `swagger.json`.
     */
    swagger?: IConfiguration.ISwagger;
}
export namespace IConfiguration
{
    /**
     * List of files or directories to include or exclude to specifying the `NestJS` 
     * controllers.
     */
    export interface IInput {
        /**
         * List of files or directories containing the `NestJS` controller classes.
         */
        include: string[];

        /**
         * List of files or directories to be excluded.
         */
        exclude?: string[];
    }

    /**
     * Building `swagger.json` is also possible.
     */
    export interface ISwagger {
        /**
         * Output path of the `swagger.json`.
         * 
         * If you've configured only directory, the file name would be the `swagger.json`. 
         * Otherwise you've configured the full path with file name and extension, the 
         * `swagger.json` file would be renamed to it.
         */
        output: string;
    }
}
```
</details>

```typescript
@@filename(nestia.config)
import type { IConfiguration } from "nestia";

export const NESTIA_CONFIG: IConfiguration = {
    input: "./src/controllers",
    output: "./src/api",
    json: true,
    swagger: {
        output: "./public/swagger.json"
    }
};
export default NESTIA_CONFIG;
```